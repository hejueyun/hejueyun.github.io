<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>çƒå·¢</title>
  <icon>https://hejueyun.github.io/icon.png</icon>
  <subtitle>A Self-taught Idiot ğŸ–Š</subtitle>
  <link href="https://hejueyun.github.io/atom.xml" rel="self"/>
  
  <link href="https://hejueyun.github.io/"/>
  <updated>2022-04-21T22:43:23.959Z</updated>
  <id>https://hejueyun.github.io/</id>
  
  <author>
    <name>ä½•å†³äº‘</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ESBMC-An Efficient SMT-based Software Model Checker</title>
    <link href="https://hejueyun.github.io/posts/2f42f06c/"/>
    <id>https://hejueyun.github.io/posts/2f42f06c/</id>
    <published>2022-04-20T20:02:42.000Z</published>
    <updated>2022-04-21T22:43:23.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction">1. Introduction</h2><blockquote><p>It(ESBMC) does not require any special annotations in the source code to find such bugs, but it allows users to add their assertions and checks if they hold. In addition, ESBMC implements a k-induction proof rule and can be used to prove the absence of property violations (resp. the validity of user-defined assertions)</p><ul><li>å®ƒï¼ˆESBMCï¼‰ä¸éœ€è¦åœ¨æºä»£ç ä¸­è¿›è¡Œä»»ä½•ç‰¹æ®Šçš„æ³¨é‡Šæ¥å‘ç°è¿™ç§é”™è¯¯ï¼Œä½†å®ƒå…è®¸ç”¨æˆ·æ·»åŠ ä»–ä»¬çš„æ–­è¨€å¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦æˆç«‹ã€‚æ­¤å¤–ï¼ŒESBMCå®ç°äº†ä¸€ä¸ªk-å½’çº³è¯æ˜è§„åˆ™ï¼Œå¯ä»¥ç”¨æ¥è¯æ˜æ²¡æœ‰è¿åå±æ€§ï¼ˆå³ç”¨æˆ·å®šä¹‰çš„æ–­è¨€çš„æœ‰æ•ˆæ€§ï¼‰</li></ul></blockquote><h2 id="ESBMC-Architecture">2. ESBMC Architecture</h2><center><img loading="lazy" src="/posts/2f42f06c/1.png" width="600"></center><ul><li>One of the significant challenges in software verification is the development and maintenance of an infrastructure that can reliably and efficiently handle real-world programs; it is an issue that only intensifies given the ever-evolving programming language standards.<ul><li>æ–°æ ‡å‡†å‘å¸ƒéœ€è¦æ–°çš„æ”¯æŒ</li></ul></li></ul><h3 id="Front-end">2.1. Front-end</h3><ul><li>an important piece of technology that should facilitate the transition between the <strong>program</strong> under verification and a <strong>format</strong> the tool can work upon</li></ul><h4 id="Clang">2.1.1. Clang</h4><p>Clangæ˜¯LLVMç¼–è¯‘å™¨çš„c-familyå‰ç«¯ï¼ŒClangå¯èƒ½æ„æŒ‡ä¸‰ç§ä¸åŒçš„å®ä½“ï¼š</p><ul><li>å‰ç«¯ï¼ˆåœ¨Clangåº“ä¸­å®ç°ï¼‰</li><li>ç¼–è¯‘å™¨é©±åŠ¨ç¨‹åºï¼ˆåœ¨clangå‘½ä»¤å’ŒClangé©±åŠ¨ç¨‹åºåº“ä¸­å®ç°ï¼‰</li><li>å®é™…çš„ç¼–è¯‘å™¨ï¼ˆåœ¨clang -cc1å‘½ä»¤ä¸­å®ç°ï¼‰ã€‚clang -cc1ä¸­çš„ç¼–è¯‘å™¨ä¸ä»…æ˜¯ç”±Clangåº“å®ç°ï¼Œè¿˜å¹¿æ³›åœ°ä½¿ç”¨å…¶ä»–LLVMåº“æ¥å®ç°ç¼–è¯‘å™¨çš„ä¸­ç«¯ã€åç«¯ä»¥åŠé›†æˆçš„æ±‡ç¼–å™¨ã€‚</li><li><code>clang -emit-llvm -c size.c -o size.bc</code></li></ul><blockquote><p>Using the LLVM bitcode in the verification process <strong>brings some advantages</strong>; the bitcode is highly optimized by LLVM and will simplify the verification, thus reducing costs. <strong>However</strong>, <strong>there are disadvantages to this process</strong>, including <strong>losing context information</strong> (e.g., variable, class and function names are mangled in C++ ), source location information; <strong>in rare cases, optimizations can generate wrong results</strong> . While the latter can be avoided by disabling optimizations (and thus losing one of <strong>this approachâ€™s</strong> advantages), the other two are not easily avoided by software verifiers.</p></blockquote><ul><li>å…¶ä»–å‰ç«¯çš„ä¸è¶³è¿˜æ˜¯åœ¨äºä¼šä¸¢å¤±source location information<ul><li>ä¸¢å¤±äº†ä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿ</li></ul></li></ul><h4 id="ESBMC-Front-end">2.1.2. ESBMC Front-end</h4><ul><li>Instead of working on the LLVM bitcode, <strong>ESBMC accesses the AST that generates the bitcode</strong><ul><li>We developed a new front-end <strong>based on clang</strong>. </li><li>We use <strong>clang</strong> to parse the C program, which generates the clang AST, and we <strong>convert it to the ESBMC AST</strong></li></ul></li></ul><h4 id="versus">2.1.3. versus</h4><ul><li>The clang front-end brings several <strong>advantages</strong> to the verification process. <ul><li>First, clang has a powerful static analyzer. It can provide state-of-the-art compiler diagnostics of the program, thus <strong>issuing the same warnings and errors</strong> that one would expect from a conventional compilation. </li><li>Second, <strong>the support for new language features is simplified</strong>. A newAST node converter needs only to be added to the converter class in ESBMC, rather than layering in the feature from flex lexer to type-checker. </li><li>Finally, by choosing the AST instead of the bitcode, <strong>a complete representation of the original program is available, including the original names of every class, function, and variable</strong>.</li></ul></li><li>The <strong>disadvantage</strong> is that ESBMC is <strong>unable to access the optimizations</strong> that LLVM performs on the bitcode</li></ul><h3 id="GOTO-Converter">2.2. GOTO Converter</h3><ul><li><p>This representation is similar to the control flow graph (CFG) representation used by conventional compilers, but we associate program statements with edges. </p><ul><li>In this process, the GOTOprogram is also simplified, and <strong>new property checks and instructions can be added</strong>.</li></ul></li><li><p>The GOTOprogram is a simplified version ofthe program: a branch and a backward GOTO replace for and while loops. It is very similar to a C program, containing assignments, function calls and returns, and location information.</p></li><li><p>Once the GOTO program is generated, the following transformations can be applied, depending on the set of options given to ESBMC:</p><ul><li><strong>Function inlining</strong><ul><li>replaces function calls with the instructions of the called function.</li></ul></li><li><strong>Interval analysis</strong><ul><li>performs an <strong>interval analysis</strong>åŒºé—´åˆ†æ for integer variables</li><li>The intervals are added back into the GOTO program as assumptions</li></ul></li><li><strong>Code transformations</strong><ul><li>introduce new instructions depending on several factors. </li><li>In particular, concurrency instructions can be inserted if the program is multi-threaded, and k-induction specific instructions are introduced if kinduction verification is enabled</li></ul></li><li><strong>Property checks</strong><ul><li>can insert several property checks into the GOTO program, including division by zero checks, integer, and float overflow checks, NaN checks (i.e., whether the result of an operation can be NaN), data race checks, deadlock checks, and atomicity checks. All these properties are encoded as <strong>assertions</strong> in the GOTO program.</li></ul></li></ul></li></ul><h3 id="Symbolic-Engine-Generating-SSA">2.3. Symbolic Engine: Generating SSA</h3><p>static single assignment (SSA)</p><ul><li>unwindsè§£å¼€ the GOTO program from the previous step</li><li>add further property checks, including <strong>dynamic memory checks</strong> (bounds, memory alignment, offset pointer-free, and double-free) and unwinding assertions</li></ul><p>â€¦</p><h3 id="SMT-Solver-SMT-Encoding-of-C-Programs">2.4. SMT Solver: SMT Encoding of C Programs</h3><p>After the SSA set is created, the next step is to encode every (not sliced) assignment in SMT and check for satisfiability. </p><ul><li>We use a notation of constraints C and properties P when encoding the set of SSA. <ul><li>A <strong>constraint</strong> is an <strong>assignment</strong> or an <strong>assumption</strong> in the program. It constrains the value of a variable</li><li>while a <strong>property</strong> is an <strong>assertion</strong> in the program. <strong>This property needs to hold given the set of constraints</strong>.</li></ul></li><li>The constraints and properties are encoded in the form $Câˆ§Â¬P$: given the set of constraints, <strong>the SMT solver will try to find an assignment to variables</strong> that satisfies the constraints and violates at least one property. <ul><li>SMTæ±‚è§£å™¨å°†è¯•å›¾æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³çº¦æŸæ¡ä»¶å¹¶è‡³å°‘è¿åä¸€ä¸ªå±æ€§çš„å˜é‡èµ‹å€¼</li></ul></li><li>Finally, if the SMT solver finds a model, ESBMC will generate a program <strong>counterexample</strong>: a set of assignments and the programâ€™s violated property.</li></ul><p>â€¦</p><h2 id="ESBMCâ€™s-Verification-Modes">3. ESBMCâ€™s Verification Modes</h2><p>.</p><h2 id="å‚è€ƒ">4. å‚è€ƒ</h2><ul><li><a href="https://blog.csdn.net/qq_36287943/article/details/109626082">LLVM - å­¦ä¹ ç¬”è®°ä¸€ - zhugl0</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;It(ESBMC) does not require any special annotations in the source code to find such bugs, but it allows users to add their assertions and checks if they hold. In addition, ESBMC implements a k-induction proof rule and can be used to prove the absence of property violations (resp. the validity of user-defined assertions)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å®ƒï¼ˆESBMCï¼‰ä¸éœ€è¦åœ¨æºä»£ç ä¸­è¿›è¡Œä»»ä½•ç‰¹æ®Šçš„æ³¨é‡Šæ¥å‘ç°è¿™ç§é”™è¯¯ï¼Œä½†å®ƒå…è®¸ç”¨æˆ·æ·»åŠ ä»–ä»¬çš„æ–­è¨€å¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦æˆç«‹ã€‚æ­¤å¤–ï¼ŒESBMCå®ç°äº†ä¸€ä¸ªk-å½’çº³è¯æ˜è§„åˆ™ï¼Œå¯ä»¥ç”¨æ¥è¯æ˜æ²¡æœ‰è¿åå±æ€§ï¼ˆå³ç”¨æˆ·å®šä¹‰çš„æ–­è¨€çš„æœ‰æ•ˆæ€§ï¼‰&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ESBMC-Architecture&quot;&gt;2. ESBMC Architecture&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/2f42f06c/1.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;One of the significant challenges in software verification is the development and maintenance of an infrastructure that can reliably and efficiently handle real-world programs; it is an issue that only intensifies given the ever-evolving programming language standards.&lt;ul&gt;
&lt;li&gt;æ–°æ ‡å‡†å‘å¸ƒéœ€è¦æ–°çš„æ”¯æŒ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Front-end&quot;&gt;2.1. Front-end&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;an important piece of technology that should facilitate the transition between the &lt;strong&gt;program&lt;/strong&gt; under verification and a &lt;strong&gt;format&lt;/strong&gt; the tool can work upon&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Clang&quot;&gt;2.1.1. Clang&lt;/h4&gt;&lt;p&gt;Clangæ˜¯LLVMç¼–è¯‘å™¨çš„c-familyå‰ç«¯ï¼ŒClangå¯èƒ½æ„æŒ‡ä¸‰ç§ä¸åŒçš„å®ä½“ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å‰ç«¯ï¼ˆåœ¨Clangåº“ä¸­å®ç°ï¼‰&lt;/li&gt;
&lt;li&gt;ç¼–è¯‘å™¨é©±åŠ¨ç¨‹åºï¼ˆåœ¨clangå‘½ä»¤å’ŒClangé©±åŠ¨ç¨‹åºåº“ä¸­å®ç°ï¼‰&lt;/li&gt;
&lt;li&gt;å®é™…çš„ç¼–è¯‘å™¨ï¼ˆåœ¨clang -cc1å‘½ä»¤ä¸­å®ç°ï¼‰ã€‚clang -cc1ä¸­çš„ç¼–è¯‘å™¨ä¸ä»…æ˜¯ç”±Clangåº“å®ç°ï¼Œè¿˜å¹¿æ³›åœ°ä½¿ç”¨å…¶ä»–LLVMåº“æ¥å®ç°ç¼–è¯‘å™¨çš„ä¸­ç«¯ã€åç«¯ä»¥åŠé›†æˆçš„æ±‡ç¼–å™¨ã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clang -emit-llvm -c size.c -o size.bc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è½¯ä»¶å®‰å…¨å¤‡å¿˜å½•ï¼šCERT C Coding Standardç¬”è®°</title>
    <link href="https://hejueyun.github.io/posts/e8d0ec3/"/>
    <id>https://hejueyun.github.io/posts/e8d0ec3/</id>
    <published>2022-04-08T20:29:29.000Z</published>
    <updated>2022-04-17T22:59:27.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Expressions-EXP">1. Expressions (EXP)</h2><h3 id="EXP30-C-Do-not-depend-on-the-order-of-evaluation-for-side-effects">1.1. EXP30-C. Do not depend on the order of evaluation for side effects</h3><blockquote><p>At specific points during execution, known as <strong>sequence points</strong>, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i is modified twice between sequence points */</span> </span><br><span class="line">i = ++i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* i is read other than to determine the value to be stored */</span> </span><br><span class="line">a[i++] = i;</span><br></pre></td></tr></table></figure><ul><li>Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior</li></ul><h4 id="å‰¯ä½œç”¨">1.1.1. å‰¯ä½œç”¨</h4><blockquote><p>åœ¨äº§ç”Ÿä¸€ä¸ªå€¼çš„è¿‡ç¨‹ä¸­ï¼Œè¡¨è¾¾å¼å¯èƒ½ä¼šå¯¹ç¯å¢ƒåšå‡ºå…¶ä»–æ”¹å˜ï¼Œè¿™æ ·çš„æ”¹å˜è¢«ç§°ä¸ºå‰¯ä½œç”¨(side effect)ï¼Œè¯¸å¦‚å˜é‡çš„å€¼è¢«ä¿®æ”¹ï¼Œæˆ–è€…è¾“å…¥è¾“å‡ºæµçš„æ•°æ®æœ‰æ‰€å˜åŒ–</p></blockquote><ul><li>è¡¨è¾¾å¼<code>x + 1;</code>å°±äº§ç”Ÿäº†ä¸€ä¸ªå€¼ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰äº§ç”Ÿä¸€ä¸ªå‰¯ä½œç”¨</li><li>è¡¨è¾¾å¼<code>x = x+ 3;</code>äº§ç”Ÿäº†ä¸€ä¸ªå€¼ï¼ŒåŒæ—¶ä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªå‰¯ä½œç”¨</li></ul><center><img loading="lazy" src="/posts/e8d0ec3/1.png" width="600"></center><h3 id="EXP32-C-Do-not-access-a-volatile-object-through-a-nonvolatile-reference">1.2. EXP32-C. Do not access a volatile object through a nonvolatile reference</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> **ipp; </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> *ip;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i = %d.\n&quot;</span>, i);</span><br><span class="line">  ipp = &amp;ip; <span class="comment">/* May produce a warning diagnostic */</span> </span><br><span class="line">  ipp = (<span class="type">int</span>**) &amp;ip; <span class="comment">/* Constraint violation; may produce a warning diagnostic */</span></span><br><span class="line">  *ipp = &amp;i; <span class="comment">/* Valid */</span> </span><br><span class="line">  <span class="keyword">if</span> (*ip != <span class="number">0</span>) &#123; <span class="comment">/* Valid */</span> </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The assignment <code>ipp = &amp;ip</code> is not safe because it allows the valid code that follows to reference the value of the volatile object <code>i</code> through the non-volatile-qualified reference <code>ip</code></p></blockquote><ul><li>Accessing an object with a volatile-qualified type through a reference with a non-volatile-qualified type is undefined behavior</li></ul><h3 id="EXP33-C-Do-not-read-uninitialized-memory">1.3. EXP33-C. Do not read uninitialized memory</h3><blockquote><p>Although compilers and static analysis tools often detect uses of uninitialized variables when they have access to the source code, diagnosing the problem is difficult or impossible when either the initialization or the use takes place in object code for which the source code is inaccessible. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_negative</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign;</span><br><span class="line">  <span class="built_in">set_flag</span>(number, &amp;sign); </span><br><span class="line">  <span class="keyword">return</span> sign &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *array = (<span class="type">int</span> *)<span class="built_in">malloc</span>(OLD_SIZE * <span class="built_in">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == array) &#123; </span><br><span class="line">  <span class="comment">/* Handle error */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; OLD_SIZE; ++i) &#123; </span><br><span class="line">  array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>The programmer neglected to account for the case where <code>number</code> is equal to 0. Because the local variable <code>sign</code> is uninitialized when calling <code>set_flag()</code> and is never written to by <code>set_flag()</code>, the comparison operation exhibits undefined behavior when reading sign.</li><li>Reading uninitialized variables is undefined behavior and can result in <strong>unexpected program behavior</strong>. In some cases, these security flaws may allow the <strong>execution of arbitrary code</strong>.</li></ul><h3 id="EXP34-C-Do-not-dereference-null-pointers">1.4. EXP34-C. Do not dereference null pointers</h3><blockquote><p>Dereferencing a null pointer is undefined behavior</p></blockquote><ul><li>Dereferencing a null pointer is undefined behavior, typically <strong>abnormal program termination</strong>. In some situations, however, dereferencing a null pointer can lead to the execution of arbitrary code</li></ul><h3 id="EXP35-C-Do-not-modify-objects-with-temporary-lifetime">1.5. EXP35-C. Do not modify objects with temporary lifetime</h3><blockquote><p>The C11 Standard introduced a new term: <strong>temporary lifetime</strong>. Modifying an object with temporary lifetime is undefined behavior</p><ul><li>the <strong>structure</strong> or <strong>union</strong> contains a member with <strong>array</strong> type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime.</li></ul></blockquote><hr><blockquote><p>This noncompliant code example conforms to the C11 Standard; however, it fails to conform to C99. If compiled with a C99-conforming implementation, this code has undefined behavior <strong>because the sequence point preceding the call to <code>printf()</code> comes between the call and the access by <code>printf()</code> of the string in the returned object</strong></p></blockquote><ul><li>ä¹Ÿå°±æ˜¯è¯´C99ä¸‹å…ˆåé¡ºåºä¸ç¡®å®š</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">char</span> a[<span class="number">8</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> <span class="built_in">salutation</span>(<span class="type">void</span>) &#123; <span class="keyword">struct</span> <span class="title class_">X</span> result = &#123; <span class="string">&quot;Hello&quot;</span> &#125;; <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> <span class="built_in">addressee</span>(<span class="type">void</span>) &#123; <span class="keyword">struct</span> <span class="title class_">X</span> result = &#123; <span class="string">&quot;world&quot;</span> &#125;; <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Noncompliant*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, %s!\n&quot;</span>, <span class="built_in">salutation</span>().a, <span class="built_in">addressee</span>().a); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Compliant*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">X</span> my_salutation = <span class="built_in">salutation</span>(); </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">X</span> my_addressee = <span class="built_in">addressee</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, %s!\n&quot;</span>, my_salutation.a, my_addressee.a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Attempting to modify an array or access it after its lifetime expires may result in erroneous program behavior</li></ul><h3 id="EXP36-C-Do-not-cast-pointers-into-more-strictly-aligned-pointer-types">1.6. EXP36-C. Do not cast pointers into more strictly aligned pointer types</h3><blockquote><p>Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced type. Different alignments are possible for different types of objects. If the type-checking system is overridden by an explicit cast or the pointer is converted to a void pointer (void *) and then to a different type, the alignment of an object may be changed.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> *ip = (<span class="type">int</span> *)&amp;c; <span class="comment">/* This can lose information */</span> </span><br><span class="line">  <span class="type">char</span> *cp = (<span class="type">char</span> *)ip;</span><br><span class="line">  <span class="comment">/* Will fail on some conforming implementations */</span> </span><br><span class="line">  <span class="built_in">assert</span>(cp == &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// æ­£ç¡®çš„</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = c; </span><br><span class="line">  <span class="type">int</span> *ip = &amp;i;</span><br><span class="line">  <span class="built_in">assert</span>(ip == &amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>the char pointer <code>&amp;c</code> is converted to the more strictly aligned int pointer <code>ip</code>. On some implementations, <code>cp</code> will not match <code>&amp;c</code>.</li><li>Accessing a pointer or an object that is not properly aligned can cause a program to <strong>crash</strong> or give erroneous information, or it can cause <strong>slow pointer accesses</strong> (if the architecture allows misaligned accesses).</li></ul><h4 id="EXP36-C-EX2">1.6.1. EXP36-C-EX2</h4><blockquote><p>If a pointer is known to be correctly aligned to the target type, then a cast to that type is permitted. There are several cases where a pointer is known to be correctly aligned to the target type. The pointer could point to an object declared with a suitable alignment specifier. It could point to an object returned by aligned_alloc(), calloc(), malloc(), or realloc()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Align c to the alignment of an int */</span> </span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">int</span>) <span class="type">char</span> c = <span class="string">&#x27;x&#x27;</span>; </span><br><span class="line">  <span class="type">int</span> *ip = (<span class="type">int</span> *)&amp;c; </span><br><span class="line">  <span class="type">char</span> *cp = (<span class="type">char</span> *)ip;</span><br><span class="line">  <span class="comment">/* Both cp and &amp;c point to equally aligned objects */</span> </span><br><span class="line">  <span class="built_in">assert</span>(cp == &amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXP37-C-Call-functions-with-the-correct-number-and-type-of-arguments">1.7. EXP37-C. Call functions with the correct number and type of arguments</h3><ul><li>Do not call a function with the wrong number or type of arguments.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In another source file */</span> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">long</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this source file, no f prototype in scope */</span> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(x); <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>((<span class="type">long</span>)x); <span class="comment">//correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Calling a function with incorrect arguments can result in unexpected or unintended program behavior</li></ul><h3 id="EXP39-C-Do-not-access-a-variable-through-a-pointer-of-an-incompatible-type">1.8. EXP39-C. Do not access a variable through a pointer of an incompatible type</h3><ul><li>Modifying a variable through a pointer of an incompatible type (other than unsigned char) can lead to unpredictable results</li><li>Accessing an object by means of any other lvalue expression (other than unsigned char) is undefined behavior</li><li>Optimizing for performance can lead to aliasing errors that can be quite difficult to detect. Furthermore, as in the preceding example, unexpected results can lead to <strong>buffer overflow attacks</strong>, <strong>bypassing security checks</strong>, or unexpected execution.</li></ul><h3 id="EXP40-C-Do-not-modify-constant-objects">1.9. EXP40-C. Do not modify constant objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> **ipp; </span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">42</span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  ipp = &amp;ip; <span class="comment">/* Constraint violation */</span> </span><br><span class="line">  *ipp = &amp;i; <span class="comment">/* Valid */</span> </span><br><span class="line">  *ip = <span class="number">0</span>; <span class="comment">/* Modifies constant i (was 42) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXP42-C-Do-not-compare-padding-data">1.10. EXP42-C. Do not compare padding data</h3><ul><li>There may be unnamed padding within a structure object, but not at its beginning. . . . </li><li>There may be unnamed padding at the end of a structure or union.</li><li>unnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate value even after initialization<ul><li>ç»“æ„å’Œè”åˆç±»å‹çš„å¯¹è±¡çš„æœªå‘½åæˆå‘˜ä¸å‚ä¸åˆå§‹åŒ–ã€‚ç»“æ„ä½“å¯¹è±¡çš„æœªå‘½åæˆå‘˜åœ¨åˆå§‹åŒ–åä¹Ÿæœ‰ä¸ç¡®å®šçš„å€¼</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">s</span> &#123; </span><br><span class="line">  <span class="type">char</span> c; </span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">13</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wrong</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> s *left, <span class="type">const</span> <span class="keyword">struct</span> s *right)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">memcmp</span>(left, right, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> s))) &#123; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//correct</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> s *left, <span class="type">const</span> <span class="keyword">struct</span> s *right)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ((left &amp;&amp; right) &amp;&amp; (left-&gt;c == right-&gt;c) </span><br><span class="line">  &amp;&amp; (left-&gt;i == right-&gt;i) </span><br><span class="line">  &amp;&amp; (<span class="number">0</span> == <span class="built_in">memcmp</span>(left-&gt;buffer, right-&gt;buffer, <span class="number">13</span>))) &#123; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>memcmp()</code> is used to compare the contents of two structures, including any padding bytes</li></ul><h4 id="EXP42-C-EX1">1.10.1. EXP42-C-EX1</h4><center><img loading="lazy" src="/posts/e8d0ec3/2.png" width="550"></center><h3 id="EXP43-C-Avoid-undefined-behavior-when-using-restrict-qualified-pointers">1.11. EXP43-C. Avoid undefined behavior when using restrict-qualified pointers</h3><ul><li><p>deleting all instances of the qualifier from a program does not change its meaning (that is, observable behavior).</p></li><li><p>undefined behavior:</p><blockquote><p>A restrict-qualified pointer is assigned a value based on another restricted pointer whose associated block neither began execution before the block associated with this pointer, nor ended before the assignment </p></blockquote></li><li><p><strong><code>restrict</code> says that two pointers cannot point to overlappingé‡å çš„ memory regions. The most common usage is for function arguments.</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *restrict a; </span><br><span class="line"><span class="type">int</span> *restrict b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  c[<span class="number">0</span>] = <span class="number">17</span>; </span><br><span class="line">  c[<span class="number">1</span>] = <span class="number">18</span>;</span><br><span class="line">  a = &amp;c[<span class="number">0</span>]; </span><br><span class="line">  b = &amp;c[<span class="number">1</span>];</span><br><span class="line">  a = b; <span class="comment">/* Undefined behavior */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>The incorrect use of restrict-qualified pointers can result in undefined behavior that might be exploited to cause data <strong>integrity</strong> violations.</li></ul><h3 id="EXP44-C-Do-not-rely-on-side-effects-in-operands-to-sizeof-Alignof-or-Generic">1.12. EXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic</h3><ul><li>Some operators <strong>do not evaluate their operands beyond the type information the operands provide</strong>. When using one of these operators, do not pass an operand that would otherwise yield a side effect since the side effect will not be generated.</li><li>The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. In most cases, the operand is not evaluated. <ul><li>A possible exception is when the type of the operand is a variable length array typeï¼ˆVLAï¼‰</li><li>ç„¶è€Œin the case of a VLA used in sizeof, have <strong>unspecified results</strong></li><li>æ‰€ä»¥ç»“è®ºè¿˜æ˜¯ä¸è¦åœ¨sizeofé‡Œå‰¯ä½œç”¨VLA</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">sizeof</span>(a++);</span><br></pre></td></tr></table></figure><ul><li>expression <code>a++</code> is not evaluatedè®¡ç®—</li></ul><h3 id="EXP45-C-Do-not-perform-assignments-in-selection-statements">1.13. EXP45-C. Do not perform assignments in selection statements</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a = b) &#123; </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">/* ... */</span> &#125; <span class="keyword">while</span> (<span class="built_in">foo</span>(), x = y);</span><br></pre></td></tr></table></figure><h4 id="EXP45-C-EX2">1.13.1. EXP45-C-EX2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x = y)) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="EXP46-C-Do-not-use-a-bitwise-operator-with-a-Boolean-like-operand">1.14. EXP46-C. Do not use a bitwise operator with a Boolean-like operand</h3><ul><li>æ··æ·†äº†<code>&amp;</code>å’Œ<code>&amp;&amp;</code><ul><li>The expression <code>x &amp; y</code> will perform a bitwise operation on each individual bit in <code>x</code> and <code>y</code>. So if x is <code>1010</code> in binary and y is <code>1100</code> then <code>x &amp; y</code> will evaluate to <code>1000</code>.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">getuid</span>() &amp; <span class="built_in">geteuid</span>() == <span class="number">0</span>)) &#123; <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">getuid</span>() &amp;&amp; <span class="built_in">geteuid</span>() == <span class="number">0</span>)) &#123; <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Risk-Assessment">1.15. Risk Assessment</h3><table><thead><tr><th>Rule</th><th>Severity</th><th>Likelihood</th><th>Remediation Cost</th><th>Priority</th><th>Level</th></tr></thead><tbody><tr><td>EXP30-C</td><td>Medium</td><td>Probable</td><td>Medium</td><td>P8</td><td>L2</td></tr><tr><td>EXP32-C</td><td>Low</td><td>Likely</td><td>Medium</td><td>P6</td><td>L2</td></tr><tr><td>EXP33-C</td><td>High</td><td>Probable</td><td>Medium</td><td>P12</td><td>L1</td></tr><tr><td>EXP34-C</td><td>High</td><td>Likely</td><td>Medium</td><td>P18</td><td>L1</td></tr><tr><td>EXP35-C</td><td>Low</td><td>Probable</td><td>Medium</td><td>P4</td><td>L3</td></tr><tr><td>EXP36-C</td><td>Low</td><td>Probable</td><td>Medium</td><td>P4</td><td>L3</td></tr><tr><td>EXP37-C</td><td>Medium</td><td>Probable</td><td>High</td><td>P4</td><td>L3</td></tr><tr><td>EXP39-C</td><td>Medium</td><td>Unlikely</td><td>High</td><td>P2</td><td>L3</td></tr><tr><td>EXP40-C</td><td>Low</td><td>Unlikely</td><td>Medium</td><td>P2</td><td>L3</td></tr><tr><td>EXP42-C</td><td>Medium</td><td>Probable</td><td>Medium</td><td>P8</td><td>L2</td></tr><tr><td>EXP43-C</td><td>Medium</td><td>Probable</td><td>High</td><td>P4</td><td>L3</td></tr><tr><td>EXP44-C</td><td>Low</td><td>Unlikely</td><td>Low</td><td>P3</td><td>L3</td></tr><tr><td>EXP45-C</td><td>Low</td><td>Likely</td><td>Medium</td><td>P6</td><td>L2</td></tr><tr><td>EXP46-C</td><td>Low</td><td>Likely</td><td>Low</td><td>P9</td><td>L2</td></tr></tbody></table><h2 id="Memory-Mem">2. Memory (Mem)</h2><p>.</p><h2 id="Array-ARR">3. Array (ARR)</h2><p>.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Expressions-EXP&quot;&gt;1. Expressions (EXP)&lt;/h2&gt;&lt;h3 id=&quot;EXP30-C-Do-not-depend-on-the-order-of-evaluation-for-side-effects&quot;&gt;1.1. EXP30-C. Do not depend on the order of evaluation for side effects&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;At specific points during execution, known as &lt;strong&gt;sequence points&lt;/strong&gt;, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* i is modified twice between sequence points */&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i = ++i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* i is read other than to determine the value to be stored */&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a[i++] = i;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;å‰¯ä½œç”¨&quot;&gt;1.1.1. å‰¯ä½œç”¨&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;åœ¨äº§ç”Ÿä¸€ä¸ªå€¼çš„è¿‡ç¨‹ä¸­ï¼Œè¡¨è¾¾å¼å¯èƒ½ä¼šå¯¹ç¯å¢ƒåšå‡ºå…¶ä»–æ”¹å˜ï¼Œè¿™æ ·çš„æ”¹å˜è¢«ç§°ä¸ºå‰¯ä½œç”¨(side effect)ï¼Œè¯¸å¦‚å˜é‡çš„å€¼è¢«ä¿®æ”¹ï¼Œæˆ–è€…è¾“å…¥è¾“å‡ºæµçš„æ•°æ®æœ‰æ‰€å˜åŒ–&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;è¡¨è¾¾å¼&lt;code&gt;x + 1;&lt;/code&gt;å°±äº§ç”Ÿäº†ä¸€ä¸ªå€¼ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰äº§ç”Ÿä¸€ä¸ªå‰¯ä½œç”¨&lt;/li&gt;
&lt;li&gt;è¡¨è¾¾å¼&lt;code&gt;x = x+ 3;&lt;/code&gt;äº§ç”Ÿäº†ä¸€ä¸ªå€¼ï¼ŒåŒæ—¶ä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªå‰¯ä½œç”¨&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e8d0ec3/1.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;EXP32-C-Do-not-access-a-volatile-object-through-a-nonvolatile-reference&quot;&gt;1.2. EXP32-C. Do not access a volatile object through a nonvolatile reference&lt;/h3&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Software Security" scheme="https://hejueyun.github.io/categories/Security/Software-Security/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è½¯ä»¶å®‰å…¨å¤‡å¿˜å½•ï¼šMem Management</title>
    <link href="https://hejueyun.github.io/posts/de2aa2c7/"/>
    <id>https://hejueyun.github.io/posts/de2aa2c7/</id>
    <published>2022-04-01T11:56:49.000Z</published>
    <updated>2022-04-06T11:49:35.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="risk-assessment">1. risk assessment</h2><blockquote><p>CERT C Coding Standard contains a <strong>risk assessment</strong> section</p></blockquote><h3 id="Severity-ä¸¥é‡æ€§">1.1. Severity ä¸¥é‡æ€§</h3><ul><li>How serious are the consequences of the rule being ignored</li></ul><table><thead><tr><th>Value</th><th>Meaning</th><th>Examples of Vulnerabilities</th></tr></thead><tbody><tr><td>1</td><td>low</td><td>Denial-of-service attack, abnormal termination</td></tr><tr><td>2</td><td>medium</td><td>Data integrity violation, unintentional information disclosure</td></tr><tr><td>3</td><td>high</td><td>Run arbitrary code</td></tr></tbody></table><h3 id="Likelihood-å¯èƒ½æ€§">1.2. Likelihood å¯èƒ½æ€§</h3><ul><li>How likely is it that a flaw introduced by ignoring the rule can lead to an exploitable vulnerability</li></ul><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>1</td><td>Unlikely</td></tr><tr><td>2</td><td>Probable</td></tr><tr><td>3</td><td>likely</td></tr></tbody></table><h3 id="Detection-and-Correction-æ£€æµ‹å’Œçº æ­£">1.3. Detection and Correction æ£€æµ‹å’Œçº æ­£</h3><ul><li>How will we cope with detection and correction</li></ul><table><thead><tr><th>Value</th><th>Meaning</th><th>Detection</th><th>Correction</th></tr></thead><tbody><tr><td>1</td><td>low</td><td>Automatic(Static and Dynamic Analysis)</td><td>Automatic(Fault Localisation and Repair)</td></tr><tr><td>2</td><td>medium</td><td>Automatic(Static and Dynamic Analysis)</td><td>Manual</td></tr><tr><td>3</td><td>high</td><td>Manual(Code Inspection)</td><td>Manual</td></tr></tbody></table><h3 id="Risk-Management">1.4. Risk Management</h3><ul><li>The three values are then multiplied together for each rule: severity, likelihood and remediation cost<ul><li>10 distinct values are possible: 1, 2, 3, 4, 6, 8, 9, 12, 18, and 27</li></ul></li><li>priority range<ul><li>12 to 27 are Level 1</li><li>6 to 9 are Level 2</li><li>1 to 4 are Level 3</li></ul></li></ul><center><img loading="lazy" src="/posts/de2aa2c7/2.png" width="550"></center><h2 id="CERT-C-Coding-Standard">2. CERT C Coding Standard</h2><h3 id="MEM30-C-Do-not-access-freed-memory">2.1. MEM30-C. Do not access freed memory</h3><p><strong>dangling pointers</strong>æ‚¬ç©ºæŒ‡é’ˆ</p><ul><li>Pointers to memory that has been deallocated<ul><li>Accessing a dangling pointer is undefined behaviour and can result in exploitable vulnerabilities</li></ul></li></ul><p><strong>example</strong></p><ul><li><code>p</code> is freed before <code>p-&gt;next</code> is executed, so that <code>p-&gt;next</code> reads memory that has already been freed</li></ul><p><strong>Risk Assessment</strong></p><ul><li>Reading memory that has been freed<ul><li>abnormal program termination</li><li>denial-of-service attacks</li></ul></li><li>Writing memory<ul><li>execution of arbitrary code</li></ul></li></ul><h3 id="MEM31-C-Free-dynamically-allocated-memory-when-no-longer-needed">2.2. MEM31-C. Free dynamically allocated memory when no longer needed</h3><p><strong>example</strong></p><ul><li>The object allocated by the call to malloc() is not freed before the end of the lifetime of the last pointer</li></ul><center><img loading="lazy" src="/posts/de2aa2c7/3.png" width="550"></center><h3 id="MEM33-C-Allocate-and-copy-structures-containing-a-flexible-array-member-dynamically">2.3. MEM33-C. Allocate and copy structures containing a flexible array member dynamically</h3><blockquote><p>As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply.</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/de2aa2c7/4.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/5.png" width="550"></center><h3 id="MEM34-C-Only-free-memory-allocated-dynamically">2.4. MEM34-C. Only free memory allocated dynamically</h3><ul><li>Freeing memory that is not allocated dynamically can result in heap corruption</li></ul><p><strong>Risk Assessment</strong></p><ul><li>The consequences of this error depend on the implementation<ul><li>they range from nothing to arbitrary code execution if that memory is reused by <code>malloc()</code></li></ul></li></ul><h3 id="MEM35-C-Allocate-sufficient-memory-for-an-object">2.5. MEM35-C. Allocate sufficient memory for an object</h3><ul><li>An insufficient amount of memory can be allocated where sizeof(long) is larger than sizeof(int), which can cause a heap buffer overflow</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/de2aa2c7/6.png" width="550"></center><h3 id="MEM36-C-Do-not-modify-the-alignment-of-objects-by-calling-realloc">2.6. MEM36-C. Do not modify the alignment of objects by calling realloc()</h3><ul><li>Do not invoke realloc() to modify the size of allocated objects that have stricter alignment requirements than those guaranteed by malloc()</li></ul><center><img loading="lazy" src="/posts/de2aa2c7/7.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/8.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/9.png" width="550"></center><h2 id="Secure-C-Programming">3. Secure C Programming</h2><ol><li>Pointers should not be left uninitialized</li><li>They should be assigned either NULL or the address of a valid item in memory</li><li>When you use free to deallocate dynamically allocated memory, the pointer passed to free is not assigned a new value, so it still points to the memory location where the dynamically allocated memory used to be</li><li>When you free dynamically allocated memory, you should immediately assign the pointer either NULL or a valid address<ol><li>We chose not to do this for local pointer variables that immediately go out of scope after a call to free</li></ol></li><li>Undefined behavior occurs when you attempt to use free to deallocate dynamic memory that was already deallocatedâ€”this is known as a â€œdouble free vulnerabilityâ€</li><li>To ensure that you donâ€™t attempt to deallocate the same memory more than once, immediately set a pointer to NULL after the call to freeâ€” attempting to free a NULL pointer has no effect</li><li>Function malloc returns NULL if itâ€™s unable to allocate the requested memory</li><li>You should always ensure that malloc did not return NULL before attempting to use the pointer that stores mallocâ€™s return value</li></ol><h2 id="Tool-Selection-and-Validation">4. Tool Selection and Validation</h2><blockquote><p>Although rule checking can be performed manually, with increasing program size and complexity, it rapidly becomes infeasible. For this reason, the use of static analysis tools is recommended</p><p>When choosing a source code analysis tool, it is clearly desirable that the tool be able to enforce as many of the guidelines on the wiki as possible</p></blockquote><h3 id="Completeness-and-Soundness">4.1. Completeness and Soundness</h3><blockquote><p>It should be recognized that, in general, determining conformance to coding rules and recommendations is computationally undecidable. The precision of static analysis has practical limitations.</p><ul><li>åº”è¯¥è®¤è¯†åˆ°ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œç¡®å®šæ˜¯å¦ç¬¦åˆç¼–ç è§„åˆ™å’Œå»ºè®®åœ¨è®¡ç®—ä¸Šæ˜¯æ— æ³•å†³å®šçš„ã€‚é™æ€åˆ†æçš„ç²¾ç¡®æ€§æœ‰å®é™…çš„é™åˆ¶ã€‚</li></ul></blockquote><blockquote><p>For example, the halting theorem of computer science states that programs exist in which exact control flow cannot be determined statically. Consequently, any property dependent on control flowâ€”such as haltingâ€”may be indeterminate for some programs. A consequence of undecidability is that it may be impossible for any tool to determine statically whether a given guideline is satisfied in specific circumstances. The widespread presence of such code may also lead to unexpected results from an analysis tool.</p></blockquote><ul><li>the analysis may generate:<ul><li>Flase negatives</li><li>Flase positive</li></ul></li></ul><center><img loading="lazy" src="/posts/de2aa2c7/1.png" width="550"></center><ul><li>An analyzer is considered <strong>sound</strong> with respect to a specific guideline if it cannot give a false-negative result, meaning it finds all violations of the guideline within the entire program</li><li>An analyzer is considered <strong>complete</strong> if it cannot issue false-positive results, or false alarms</li><li>incomplete: <ul><li>You cannot prove everything that in the system is True</li><li>There are some assertion cannot be triggered.</li></ul></li></ul><h4 id="False-Negatives">4.1.1. False Negatives</h4><blockquote><p><strong>Failure to report a real flaw in the code is usually regarded as the most serious analysis error, as it may leave the user with a false sense of security</strong>. Most tools err on the side of caution and consequently generate false positives. </p></blockquote><h4 id="False-Positives">4.1.2. False Positives</h4><blockquote><p><strong>The tool reports a flaw when one does not exist</strong>. False positives may occur because the code is too complex for the tool to perform a complete analysis. The use of features such as function pointers and libraries may make false positives more likely</p></blockquote><h3 id="Taint-Analysis-æ±¡ç‚¹åˆ†æ">4.2. Taint Analysis æ±¡ç‚¹åˆ†æ</h3><ul><li>If the value of an operand or argument may be outside the domain of an operation or function that consumes that value, and the value is derived from any external input to the program (such as a command-line argument, data returned from a system call, or data in shared memory), that value is tainted, and its origin is known as a tainted source.</li></ul><h4 id="Sanitization">4.2.1. Sanitization</h4><p>To remove the taint from a value, the value must be sanitized to ensure that it is in the defined domain of any restricted sink into which it flows.</p><ul><li>Operands and arguments whose domain is a subset of the domain described by their types are called restricted sinks. Any integer operand used in a pointer arithmetic operation is a restricted sink for that operand<ul><li>æ¯”å¦‚æ•°ç»„è¶Šç•Œå°±ç®—out of domain?</li></ul></li></ul><p>æ›´å¤šå‚è€ƒ</p><ul><li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer â€” Clang 15.0.0git documentation</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;risk-assessment&quot;&gt;1. risk assessment&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CERT C Coding Standard contains a &lt;strong&gt;risk assessment&lt;/strong&gt; section&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Severity-ä¸¥é‡æ€§&quot;&gt;1.1. Severity ä¸¥é‡æ€§&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How serious are the consequences of the rule being ignored&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Examples of Vulnerabilities&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;low&lt;/td&gt;
&lt;td&gt;Denial-of-service attack, abnormal termination&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;medium&lt;/td&gt;
&lt;td&gt;Data integrity violation, unintentional information disclosure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;high&lt;/td&gt;
&lt;td&gt;Run arbitrary code&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;Likelihood-å¯èƒ½æ€§&quot;&gt;1.2. Likelihood å¯èƒ½æ€§&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How likely is it that a flaw introduced by ignoring the rule can lead to an exploitable vulnerability&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Unlikely&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Probable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;likely&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;Detection-and-Correction-æ£€æµ‹å’Œçº æ­£&quot;&gt;1.3. Detection and Correction æ£€æµ‹å’Œçº æ­£&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How will we cope with detection and correction&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Software Security" scheme="https://hejueyun.github.io/categories/Security/Software-Security/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>æœ‰ç•Œæ¨¡å‹æ£€æµ‹ç¬”è®°</title>
    <link href="https://hejueyun.github.io/posts/ade5e95e/"/>
    <id>https://hejueyun.github.io/posts/ade5e95e/</id>
    <published>2022-03-30T22:02:54.000Z</published>
    <updated>2022-04-01T13:15:20.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SMT-based-BMC">1. SMT-based BMC</h2><ul><li>In SMT-based BMC, Ïˆ is a <strong>quantifier-free</strong> formula in a <strong>decidable</strong> subset of <strong>first-order logic</strong> which is then checked for <strong>satisfiability</strong> by an SMT solver</li><li>SMT-based BMC must consider a number of <strong>issues that are not easily mapped into the theories supported by SMT solvers</strong> ï¼ˆi.e. embedded softwareï¼‰<blockquote><p>In previous work on SMTbased BMC for software only the theories of uninterpreted functions, arrays and linear arithmetic were considered, but no encoding was provided for <strong>ANSI-C constructs</strong> such as <strong>bit-level operations</strong>, <strong>fixedpoint</strong> <strong>arithmetic</strong>, <strong>pointers</strong> (i.e., pointer arithmetic and comparisons) and <strong>unions</strong>.</p></blockquote></li></ul><h3 id="Generation-of-VCs">1.1. Generation of VCs</h3><ul><li><p>VC: verification condition </p><blockquote><p>BMC unrolls the system k times and translates it into a verification condition (VC) Ïˆ such that Ïˆ is satisfiable if and only if Ï† has a counterexample of depth k or less</p><p>The VC Ïˆ is a quantifier-free formula in a decidable subset of first-order logic, which is then checked for satisfiability by an SMT solver</p></blockquote></li><li><p>checking safety properties of single-threaded programsï¼š$I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} Î³(s_j, s_{j+1}) \land \lnot Ï†(s_i)$</p><ul><li>Ï† is a safety property</li><li>I the set of initial states of M</li><li>$Î³(s_j, s_{j+1})$ the transition relation of M between time steps j and j + 1</li><li>$I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} Î³(s_j,s_{j+1})$ <ul><li>represents the executions of M of length i and the original formula can be satisfied if and only if for some $i â‰¤ k$ there exists a reachable state at time step i in which Ï† is violated</li></ul></li></ul></li><li><p>If it is <strong>satisfiable</strong>, then the SMT solver provides a satisfying assignment, from which we can extract the values of the program variables to construct a counter-example</p><ul><li>A counter-example for a property Ï† is a sequence of states $s_0, s_1,â€¦,s_k$ with $s_0 âˆˆ S_0$, $s_k âˆˆ S$, and $Î³(s_i, s_{i+1})$ for $0 â‰¤ i &lt; k$.</li></ul></li><li><p>If it is <strong>unsatisfiable</strong>, we can conclude that no error state is reachable in k steps or less</p></li></ul><div class="admonition caution"><p>It is important to note that this approach can be used only to find violations of the property up to the bound k. In order to prove properties we need to compute the completeness threshold (CT), which can be smaller than or equal to the maximum number of loop-iterations occurring in the program</p></div><ul><li>ä¹Ÿå°±æ˜¯æœ‰ä¸æœ‰ç•Œéƒ½å·®ä¸å¤šäº†</li></ul><p>points</p><ul><li>the encoding techniques that we use to convert the constraints and properties from the ANSI-C programs into the <strong>different background theories of the SMT solvers</strong></li><li>approach to decide the best encoding and solver to be used during the verification process.</li></ul><h2 id="ESBMC">2. ESBMC</h2><h3 id="CBMC">2.1. CBMC</h3><ul><li>CBMC implements BMC for ANSI-C&#x2F;C++ programs using <strong>SAT</strong> solvers<ul><li>process C&#x2F;C++ code using the goto-cc tool</li><li>process the C&#x2F;C++ files and to build an abstract syntax tree (AST) (via internal parser based on Flex&#x2F;Bison)<blockquote><p>The typechecker of CBMCâ€™s front-end annotates this AST with types and generates a symbol table. CBMCâ€™s IRep class then converts the annotated AST into an internal, language-independent format used by the remaining phase of the front-end.</p></blockquote></li></ul></li></ul><h3 id="Tool-Architecture">2.2. Tool Architecture</h3><h4 id="Frontend">2.2.1. Frontend</h4><ul><li>The <strong>white</strong> boxes (except for the SMT solver) represent the components that we reused from the CBMC model checker without any modification</li></ul><h4 id="Middleware">2.2.2. Middleware</h4><ul><li><p>The <strong>gray</strong> boxes with dashed lines represent the components that we modified in order to:</p><ul><li>generate VCs to check for memory leaks (implemented in GOTO program</li><li>to simplify the unrolled formula (implemented in GOTO symex</li><li>to perform an <strong>up-front analysis</strong>å…ˆæœŸåˆ†æ in the CFG of the program to determine the best encoding and solver for a particular program (implemented in GOTO symex</li></ul></li><li><p><strong>GOTO program component</strong></p><ul><li>converts the ANSI-C program into a GOTO-program, which simplifies the representation (e.g., replacement of switch and while by if and goto statements)</li><li>and handles the unrolling of the loops and the elimination of recursive functions</li></ul></li><li><p><strong>GOTO symex component</strong></p><ul><li>performs a symbolic simulation of the program</li></ul></li></ul><h4 id="Backend">2.2.3. Backend</h4><ul><li>In the back-end of ESBMC, we build two sets of quantifier-free formulae C (for the constraints) and P (for the properties)<ul><li>C encodes the first part of $Ïˆ_k$ (more precisely, $I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} Î³(s_j, s_{j+1})$ )</li><li>$Â¬P$ encodes the second part (more precisely, $\bigvee_{i&#x3D;0}^k \lnot Ï†(s_i)$)</li><li>we check $C \models_{\tau} P$ using an SMT solver<ul><li>If the answer is satisfiable, we have found a violation of the property Ï†, which is encoded in $Ïˆ_k$. </li><li>If not, the property holds up to the bound k.</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/2.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/3.png" width="650"></center>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SMT-based-BMC&quot;&gt;1. SMT-based BMC&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;In SMT-based BMC, Ïˆ is a &lt;strong&gt;quantifier-free&lt;/strong&gt; formula in a &lt;strong&gt;decidable&lt;/strong&gt; subset of &lt;strong&gt;first-order logic&lt;/strong&gt; which is then checked for &lt;strong&gt;satisfiability&lt;/strong&gt; by an SMT solver&lt;/li&gt;
&lt;li&gt;SMT-based BMC must consider a number of &lt;strong&gt;issues that are not easily mapped into the theories supported by SMT solvers&lt;/strong&gt; ï¼ˆi.e. embedded softwareï¼‰&lt;blockquote&gt;
&lt;p&gt;In previous work on SMTbased BMC for software only the theories of uninterpreted functions, arrays and linear arithmetic were considered, but no encoding was provided for &lt;strong&gt;ANSI-C constructs&lt;/strong&gt; such as &lt;strong&gt;bit-level operations&lt;/strong&gt;, &lt;strong&gt;fixedpoint&lt;/strong&gt; &lt;strong&gt;arithmetic&lt;/strong&gt;, &lt;strong&gt;pointers&lt;/strong&gt; (i.e., pointer arithmetic and comparisons) and &lt;strong&gt;unions&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Generation-of-VCs&quot;&gt;1.1. Generation of VCs&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;VC: verification condition &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BMC unrolls the system k times and translates it into a verification condition (VC) Ïˆ such that Ïˆ is satisfiable if and only if Ï† has a counterexample of depth k or less&lt;/p&gt;
&lt;p&gt;The VC Ïˆ is a quantifier-free formula in a decidable subset of first-order logic, which is then checked for satisfiability by an SMT solver&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;checking safety properties of single-threaded programsï¼š$I(s_0) \land \bigvee_{i&amp;#x3D;0}^k \bigwedge_{j&amp;#x3D;0}^{i-1} Î³(s_j, s_{j+1}) \land \lnot Ï†(s_i)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ï† is a safety property&lt;/li&gt;
&lt;li&gt;I the set of initial states of M&lt;/li&gt;
&lt;li&gt;$Î³(s_j, s_{j+1})$ the transition relation of M between time steps j and j + 1&lt;/li&gt;
&lt;li&gt;$I(s_0) \land \bigvee_{i&amp;#x3D;0}^k \bigwedge_{j&amp;#x3D;0}^{i-1} Î³(s_j,s_{j+1})$ &lt;ul&gt;
&lt;li&gt;represents the executions of M of length i and the original formula can be satisfied if and only if for some $i â‰¤ k$ there exists a reachable state at time step i in which Ï† is violated&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If it is &lt;strong&gt;satisfiable&lt;/strong&gt;, then the SMT solver provides a satisfying assignment, from which we can extract the values of the program variables to construct a counter-example&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A counter-example for a property Ï† is a sequence of states $s_0, s_1,â€¦,s_k$ with $s_0 âˆˆ S_0$, $s_k âˆˆ S$, and $Î³(s_i, s_{i+1})$ for $0 â‰¤ i &amp;lt; k$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If it is &lt;strong&gt;unsatisfiable&lt;/strong&gt;, we can conclude that no error state is reachable in k steps or less&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;admonition caution&quot;&gt;&lt;p&gt;It is important to note that this approach can be used only to find violations of the property up to the bound k. In order to prove properties we need to compute the completeness threshold (CT), which can be smaller than or equal to the maximum number of loop-iterations occurring in the program&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;ä¹Ÿå°±æ˜¯æœ‰ä¸æœ‰ç•Œéƒ½å·®ä¸å¤šäº†&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the encoding techniques that we use to convert the constraints and properties from the ANSI-C programs into the &lt;strong&gt;different background theories of the SMT solvers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;approach to decide the best encoding and solver to be used during the verification process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ESBMC&quot;&gt;2. ESBMC&lt;/h2&gt;&lt;h3 id=&quot;CBMC&quot;&gt;2.1. CBMC&lt;/h3&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-SMT</title>
    <link href="https://hejueyun.github.io/posts/39d160ca/"/>
    <id>https://hejueyun.github.io/posts/39d160ca/</id>
    <published>2022-03-10T16:05:21.000Z</published>
    <updated>2022-03-19T22:26:38.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SAT-vs-SMT-å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜-vs-å¯æ»¡è¶³æ€§æ¨¡ç†è®º">1. SAT vs SMT å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ vs  å¯æ»¡è¶³æ€§æ¨¡ç†è®º</h2><ul><li>SMTå°†SATæ¨å¹¿åˆ°æ¶‰åŠ å®æ•° ã€ æ•´æ•° å’Œ&#x2F;æˆ–å„ç§ æ•°æ®ç»“æ„ ï¼ˆå¦‚ åˆ—è¡¨ ã€ æ•°ç»„ ã€ ä½å‘é‡ å’Œ å­—ç¬¦ä¸²</li><li>ç”±äºå¸ƒå°”å¯æ»¡è¶³æ€§å·²ç»æ˜¯ NP å®Œå…¨çš„ï¼Œæ‰€ä»¥ SMT é—®é¢˜é€šå¸¸æ˜¯ NPå›°éš¾çš„ ï¼Œå¹¶ä¸”å¯¹äºè®¸å¤šç†è®ºæ¥è¯´å®ƒæ˜¯ ä¸å¯åˆ¤å®š(nondeterministic)</li></ul><center><img loading="lazy" src="/posts/39d160ca/1.png" width="550"></center><p>SMTæ˜¯æŒ‡å¦å¤–ä¸€ç±»å…¬å¼çš„å¯æ»¡è¶³æ€§åˆ¤å®šé—®é¢˜ã€‚è¿™ä¸€ç±»å…¬å¼å…·æœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š</p><ul><li>åœ¨å‘½é¢˜é€»è¾‘å…¬å¼é‡Œé¢æ··å…¥äº†ä¸€äº›ä¸€é˜¶é€»è¾‘è¡¨è¾¾å¼</li><li>å…·æœ‰ä»»æ„çš„å¸ƒå°”ç»“æ„</li></ul><blockquote><p>SAT solvers are automatic and efficient</p><p>However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. <strong>A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of todayâ€™s Boolean engines</strong></p></blockquote><hr><ul><li><strong>SMT Solver &#x3D; SAT Solver + Theory Solver</strong></li></ul><h2 id="Solver-vs-Checker">2. Solver vs Checker</h2><ul><li>In model checking, you have a model and a specification (or property), and you check if the model meets the specification.</li><li>In SAT solving, you have a formula and you try to find a satisfying assignment to it.</li></ul><hr><ul><li>To perform model checking a reachability analysis is needed and to do this the program transitions are often executed symbolically</li><li>The solution to the resulting satisfaction problem is created by a solver</li></ul><h2 id="overflow-æº¢å‡º">3. overflow æº¢å‡º</h2><h3 id="arithmetic-overflow-ç®—æœ¯æº¢å‡º">3.1. arithmetic overflow ç®—æœ¯æº¢å‡º</h3><ul><li>å½“è®¡ç®—äº§ç”Ÿå‡ºæ¥çš„ç»“æœæ˜¯éå¸¸å¤§çš„ï¼Œå¤§äºå¯„å­˜å™¨æˆ–å­˜å‚¨å™¨æ‰€èƒ½å­˜å‚¨æˆ–è¡¨ç¤ºçš„èƒ½åŠ›é™åˆ¶</li><li>ä»»ä½•æ•°é™¤ä»¥é›¶çš„è®¡ç®—ï¼ˆDivided by zeroï¼‰â€œä¸æ˜¯â€ç®—æœ¯æº¢å‡ºçš„ä¸€ç§ã€‚åœ¨æ•°å­¦ä¸Šåªèƒ½æ˜æ˜¾ç®—æ˜¯ä¸æ˜ç¡®çš„å®šä¹‰ï¼ˆUndefinedï¼‰ï¼›å®ƒè®¡ç®—å‡ºæ¥çš„ç»“æœåªèƒ½å½“æˆæ˜¯â€œæ²¡æœ‰â€å€¼ï¼Œè€Œä¸æ˜¯éå¸¸å¤§çš„æ— é™æ•°å€¼</li></ul><h3 id="arithmetic-underflowç®—æœ¯ä¸‹æº¢">3.2. arithmetic underflowç®—æœ¯ä¸‹æº¢</h3><ul><li>ç®—æœ¯ä¸‹æº¢ä¹Ÿç§°ä¸ºæµ®ç‚¹æ•°ä¸‹æº¢ï¼Œæ˜¯æŒ‡è®¡ç®—æœºæµ®ç‚¹æ•°è®¡ç®—çš„ç»“æœå°äºå¯ä»¥è¡¨ç¤ºçš„æœ€å°æ•°</li><li>ä¾‹å¦‚ï¼Œæµ®ç‚¹æ•°æŒ‡æ•°èŒƒå›´ä¸º-128è‡³127ï¼Œä¸€ä¸ªç»å¯¹å€¼å°äº2âˆ’127çš„æµ®ç‚¹æ•°å°±ä¼šé€ æˆä¸‹æº¢ï¼ˆå‡è®¾-128çš„é˜¶ç ç”¨äºè¡¨ç¤ºè´Ÿæ— ç©·ï¼‰</li></ul><h2 id="Theory-ç†è®º">4. Theory ç†è®º</h2><ul><li>A theory T is a consistentä¸€è‡´çš„ set of first-order formulas<ul><li><strong>Equality</strong> (also called theory of uninterpreted functions UF</li><li><strong>Linear arithmetic</strong></li><li><strong>Arrays</strong></li><li>â€¦</li></ul></li></ul><h3 id="ä¸€è‡´æ€§ï¼ˆconsistency">4.1. ä¸€è‡´æ€§ï¼ˆconsistency)</h3><ul><li>æŒ‡ä¸€ä¸ªå½¢å¼ç³»ç»Ÿä¸­ä¸è•´æ¶µçŸ›ç›¾<ul><li>è¯­ä¹‰ä¸Šï¼šå½“ä¸€ä¸ªå‘½é¢˜Sæ˜¯ç”±è®¸å¤šå‘½é¢˜ç»„æˆæ—¶ï¼Œå¦‚æœæ‰€æœ‰å‘½é¢˜å¯åŒæ—¶ä¸ºçœŸï¼Œåˆ™Sæ˜¯ä¸€è‡´çš„ï¼Œå¦åˆ™Sæ˜¯ä¸ä¸€è‡´çš„</li><li>è¯­æ³•ä¸Šï¼šå…¬ç†ç³»ç»Ÿä¸èƒ½æ¨å¯¼å‡ºä¸¤ä¸ªç›¸åçš„ç»“æœã€‚äº¦å³ä¸å­˜åœ¨å‘½é¢˜Pï¼Œä½¿å¾—Pâ†’Qå’ŒPâ†’~QåŒæ—¶æˆç«‹</li></ul></li></ul><h3 id="Validity-modulo-theories-æœ‰æ•ˆæ€§æ¨¡å¼ç†è®º">4.2. Validity modulo theories æœ‰æ•ˆæ€§æ¨¡å¼ç†è®º</h3><ul><li>$T_1âˆªT_2âˆªâ€¦âˆªT_n \models{} âˆ€\bar{x}F(\bar{x})$</li><li>here each $T_i$ is a first-order theory and $F(\bar{x})$ is a quantifier-free formule</li></ul><center><img loading="lazy" src="/posts/39d160ca/3.png" width="550"></center><ul><li>$\simeq{}$ å¤§æ¦‚æ˜¯æŒ‡logical equivalence<ul><li>éåå¸¸è¯†çš„ï¼Œå¯ä»¥ç”¨å¸¸è¯†æ¥ç†è§£</li></ul></li></ul><h3 id="Satisfiability-Modulo-Theories-å¯æ»¡è¶³æ€§æ¨¡å¼ç†è®º">4.3. Satisfiability Modulo Theories å¯æ»¡è¶³æ€§æ¨¡å¼ç†è®º</h3><ul><li>From Validity Modulo Theories to Satisfiability Modulo Theories:</li></ul><center><img loading="lazy" src="/posts/39d160ca/4.png" width="550"></center><h3 id="SMT-solvers">4.4. SMT solvers</h3><center><img loading="lazy" src="/posts/39d160ca/5.png" width="550"></center><h2 id="Theory-of-equality-QF-UF-and-UF">5. Theory of equality (QF_UF and UF)</h2><ul><li>QFæ˜¯æŒ‡<code>quantifier-free</code></li></ul><center><img loading="lazy" src="/posts/39d160ca/6.png" width="550"></center><ul><li>Function congruence: å‡½æ•°åŒæ„<ul><li><em>å·®ä¸å¤šç›¸å½“äºåŒå°„ï¼Ÿ</em></li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/7.png" width="550"></center><p><strong>issue</strong></p><ul><li>Equality axioms are very prolificå¤šäº§çš„, resolution will quickly generate many irrelevant clauses.</li><li>Resolving with symmetry axiom we can produce all permutations of left and right sides of all equations. Transitivity axiom can resolve with symmetry axioms and itself producing longer clauses.</li></ul><h3 id="Inference-rules">5.1. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/8.png" width="550"></center><ul><li>Paramodulation: è°ƒèŠ‚</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/9.png" width="550"></center><ul><li>Idea: Only replace â€œbiggerâ€ terms by â€œsmallerâ€ terms</li><li>æ³¨æ„ç¬¬ä¸ƒæ­¥ä¸æ˜¯ $f(b)&#x3D;f(b)$ ï¼Œä¸è¦é©¬è™</li></ul><h3 id="Uninterpreted-function">5.2. Uninterpreted function</h3><ul><li>In mathematical logic, an uninterpreted function or function symbol is one that has no other property than its name and n-ary form. Function symbols are used, together with constants and variables, to form terms.<ul><li>ç›¸å½“äºå•çº¯0-aryç¬¦å·$f$</li></ul></li><li>The theory of uninterpreted functions is also sometimes called the free theory, because it is freely generated, and thus a free object<ul><li>ä¸è¢«é‡è¯çº¦æŸçš„</li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/10.png" width="550"></center><h2 id="Theory-of-Arrays">6. Theory of Arrays</h2><ul><li>Array signature $Î£array &#x3D;&lt; { select&#x2F;2, store&#x2F;3 } , { \simeq{}} &gt;$</li></ul><h3 id="Axiomså…¬ç†">6.1. Axiomså…¬ç†</h3><ul><li>$âˆ€A, I , E [select(store(A, I , E ), I ) \simeq{} E ]$<ul><li>if we store an element in an array and read from the same position then we should obtain the same element</li><li>æ³¨æ„storeçš„è¿”å›å€¼æ˜¯ä¸€ä¸ªæ–°çš„Array</li></ul></li><li>$âˆ€A, I , J, E [I \not\simeq{} J â†’ select(store(A, I , E ), J) \simeq{} select(A, J)]$<ul><li>if we store an element at position i then at all other positions elements are unchanged</li></ul></li></ul><h2 id="Theory-of-Linear-Arithmetic-ï¼ˆQF-LRAï¼‰">7. Theory of Linear Arithmetic ï¼ˆQF_LRAï¼‰</h2><h3 id="linear-constraints-çº¿æ€§çº¦æŸ">7.1. linear constraints çº¿æ€§çº¦æŸ</h3><center><img loading="lazy" src="/posts/39d160ca/11.png" width="550"></center><hr><center><img loading="lazy" src="/posts/39d160ca/12.png" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/15.png" width="550"></center><h3 id="Inference-rules-1">7.2. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/14.png" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/16.png" width="550"></center><h2 id="SMT-solver">8. SMT solver</h2><center><img loading="lazy" src="/posts/39d160ca/13.png" width="550"></center><h3 id="Abstract-DPLL">8.1. Abstract DPLL</h3><center><img loading="lazy" src="/posts/39d160ca/17.jpg" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/18.jpg" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/19.jpg" width="550"></center><ul><li>å¯ä»¥çœ‹åˆ°theory unsatçš„åŸå› æ˜¯1ï¼Œ2æ‰€ä»¥å¯ä»¥ç›´æ¥å›é€€</li><li>æ³¨æ„æœ€åä¸€æ­¥ä¸æ˜¯decideæ‰€ä»¥æ²¡æœ‰back jump</li></ul><h3 id="minimal-steps">8.2. minimal steps</h3><center><img loading="lazy" src="/posts/39d160ca/21.png" width="550"></center><ul><li>ç®€è€Œè¨€ä¹‹å°±æ˜¯åªè€ƒè™‘äº§ç”Ÿå½±å“çš„é‚£å‡ æ­¥</li></ul><center><img loading="lazy" src="/posts/39d160ca/20.jpg" width="550"></center><h2 id="å‚è€ƒ">9. å‚è€ƒ</h2><ul><li><a href="https://stackoverflow.com/questions/43908872/smt-sat-solver-vs-model-checker">SMT&#x2F;SAT Solver vs Model Checker - Stack Overflow</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SAT-vs-SMT-å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜-vs-å¯æ»¡è¶³æ€§æ¨¡ç†è®º&quot;&gt;1. SAT vs SMT å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ vs  å¯æ»¡è¶³æ€§æ¨¡ç†è®º&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SMTå°†SATæ¨å¹¿åˆ°æ¶‰åŠ å®æ•° ã€ æ•´æ•° å’Œ&amp;#x2F;æˆ–å„ç§ æ•°æ®ç»“æ„ ï¼ˆå¦‚ åˆ—è¡¨ ã€ æ•°ç»„ ã€ ä½å‘é‡ å’Œ å­—ç¬¦ä¸²&lt;/li&gt;
&lt;li&gt;ç”±äºå¸ƒå°”å¯æ»¡è¶³æ€§å·²ç»æ˜¯ NP å®Œå…¨çš„ï¼Œæ‰€ä»¥ SMT é—®é¢˜é€šå¸¸æ˜¯ NPå›°éš¾çš„ ï¼Œå¹¶ä¸”å¯¹äºè®¸å¤šç†è®ºæ¥è¯´å®ƒæ˜¯ ä¸å¯åˆ¤å®š(nondeterministic)&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/39d160ca/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;SMTæ˜¯æŒ‡å¦å¤–ä¸€ç±»å…¬å¼çš„å¯æ»¡è¶³æ€§åˆ¤å®šé—®é¢˜ã€‚è¿™ä¸€ç±»å…¬å¼å…·æœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨å‘½é¢˜é€»è¾‘å…¬å¼é‡Œé¢æ··å…¥äº†ä¸€äº›ä¸€é˜¶é€»è¾‘è¡¨è¾¾å¼&lt;/li&gt;
&lt;li&gt;å…·æœ‰ä»»æ„çš„å¸ƒå°”ç»“æ„&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SAT solvers are automatic and efficient&lt;/p&gt;
&lt;p&gt;However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. &lt;strong&gt;A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of todayâ€™s Boolean engines&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SMT Solver &amp;#x3D; SAT Solver + Theory Solver&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Solver-vs-Checker&quot;&gt;2. Solver vs Checker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;In model checking, you have a model and a specification (or property), and you check if the model meets the specification.&lt;/li&gt;
&lt;li&gt;In SAT solving, you have a formula and you try to find a satisfying assignment to it.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-å½’ç»“</title>
    <link href="https://hejueyun.github.io/posts/e24b211f/"/>
    <id>https://hejueyun.github.io/posts/e24b211f/</id>
    <published>2022-03-06T21:08:15.000Z</published>
    <updated>2022-03-13T23:47:03.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="atom-vs-literal-vs-term">1. atom vs literal  vs term</h2><ul><li>a: $p$<ul><li>åœ¨ä¸€é˜¶é€»è¾‘ä¸‹å¾—åˆ°æ‰©å±•</li></ul></li><li>l: $p$  $\lnot{p}$  <ul><li>æ³¨æ„æ‰©å±•åˆ°å‘½é¢˜é€»è¾‘ä¸­æ—¶ï¼Œ$P$å°±å¯ä»¥å¸¦ä¸Šå‡½æ•°å’Œè°“è¯<blockquote><ul><li>In propositional calculus a literal is simply a propositional variable or its negation.</li><li>In predicate calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, ${\displaystyle P(t_{1},\ldots ,t_{n})}$ with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example,  ${\displaystyle \neg Q(f(g(x),y,2),x)}$ is a negative literal with the <strong>constant symbol</strong> 2, the <strong>variable symbols</strong> x, y, the <strong>function symbol</strong>s f, g, and the <strong>predicate symbol</strong> Q.</li></ul></blockquote></li></ul></li><li>t: $p$  $f^{n}$  $a$</li></ul><h2 id="åˆä¸€-Unification">2. åˆä¸€ Unification</h2><ul><li>Let s and t be two terms (or atoms), A <strong>unifier</strong> of s and t is a substitition <strong>Ïƒ</strong> that makes the two identical, formally<ul><li>sÏƒ &#x3D; tÏƒ</li></ul></li></ul><center><img loading="lazy" src="/posts/e24b211f/1.png" width="550"></center><h3 id="æœ€ä¸€èˆ¬çš„åˆä¸€-Most-general-unifier">2.1. æœ€ä¸€èˆ¬çš„åˆä¸€ Most general unifier</h3><p>Ïƒ is a most general unifier of s and t, denoted mgu(s, t),</p><ul><li>if Ïƒ is a unifier of s and t and for any other unifier Î¸ of s and t,</li><li><strong>there is</strong> a substitution Ï such that<ul><li>ÏƒÏ &#x3D; Î¸</li></ul></li></ul><h3 id="Unifiers-and-most-general-unifiers-in-general">2.2. Unifiers and most general unifiers, in general</h3><center><img loading="lazy" src="/posts/e24b211f/2.png" width="550"></center><ul><li>simultaneous&#x2F;ËŒsaÉª.mÉ™lËˆteÉª.ni.É™s&#x2F; åŒæ—¶çš„</li></ul><h2 id="unification-algorithm-åˆä¸€ç®—æ³•æ±‚è§£mgu">3. unification algorithm åˆä¸€ç®—æ³•æ±‚è§£mgu</h2><ul><li>Input: An equational system E</li><li>Goal: Determine if E is unifiable, and <strong>if it is, to read off mgu</strong></li><li>Output: Equational system Eâ€™ in <strong>solved form</strong>, or âŠ¥ (for not unifiable)</li><li>Perform the following transformations on the set of equations <strong>as long as any one of them is applicable</strong>:<ul><li>æ³¨æ„ä¸€å®šè¦ç”¨åˆ°ä¸èƒ½ç”¨ä¸ºæ­¢ï¼Œä¸€èˆ¬ç»“æœä¼šæ˜¯å·¦å¼ç”±å¸¦æœ‰åŒä¸€å˜é‡çš„å³å¼è¡¨è¾¾ï¼Œä¾‹å¦‚ï¼š<ul><li>$x&#x3D;y$</li><li>$z&#x3D;f(y)$</li></ul></li></ul></li></ul><ol><li>Transform t&#x3D;x, where t is not a variable, to x&#x3D;t. å˜é‡æ¢åˆ°å·¦ä¾§ï¼Œéå˜é‡æ¢åˆ°å³è¾¹</li><li>Erase the equation x&#x3D;x. æ¶ˆé™¤ç›¸ç­‰å¼</li><li>Let tâ€²&#x3D;tâ€³ be an equation where tâ€², tâ€³ are not variables. â€œéå˜é‡&#x3D;éå˜é‡â€çš„æƒ…å†µ<ol><li>If the outermost function symbols of tâ€² and tâ€³ are not identical, terminate the algorithm and report not unifiable. å¦‚æœtâ€²å’Œtâ€³çš„æœ€å¤–å±‚å‡½æ•°ç¬¦å·ä¸ä¸€è‡´ï¼Œåˆ™ç»ˆæ­¢ç®—æ³•ï¼Œå¹¶æŠ¥å‘Š<strong>ä¸å¯åˆä¸€</strong></li><li>Otherwise, replace the equation $f(t_1^{â€˜},â€¦t_k^{â€˜})&#x3D;f(t_1^{â€˜â€™},â€¦t_k^{â€˜â€™})$ by the k equations $t_1^{â€˜}&#x3D;t_1^{â€˜â€™},â€¦t_k^{â€˜}&#x3D;t_k^{â€˜â€™}$ . å¦åˆ™æ›¿æ¢</li></ol></li><li>Let x&#x3D;t be an equation such that x has another occurrence in the set. åŒä¸€å˜é‡å¤šæ¬¡å‡ºç°<ol><li>If x occurs in t and x differs from t, terminate the algorithm and report not unifiable</li><li>Otherwise, transform the set by replacing all occurrences of x in other equations by t. å¦åˆ™ï¼Œé€šè¿‡å°†å…¶ä»–æ–¹ç¨‹ä¸­æ‰€æœ‰å‡ºç°çš„xæ›¿æ¢ä¸ºtæ¥è½¬æ¢è¿™ä¸ªé›†åˆ</li><li>rule 4 also called the <strong>occurs-check</strong></li></ol></li></ol><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/3.png" width="650"></center><ul><li>å¾—åˆ°mgu</li></ul><h3 id="â‡’-U-unification-rules">3.1. $â‡’_{U^-}$unification rules</h3><center><img loading="lazy" src="/posts/e24b211f/4.png" width="550"></center><ul><li>Orientation: æ–¹å‘</li><li>Trivial: çç¢ï¼ˆå¯ç†è§£ä¸ºæ— ä»·å€¼ï¼‰</li><li>Disagreement&#x2F;Clashï¼šåˆ†æ­§&#x2F;å†²çª</li><li>Decompositionï¼šåˆ†è§£</li><li>Occur-checkï¼šå‡ºç°æ£€æŸ¥ï¼ˆå¯ç†è§£ä¸ºå­˜åœ¨æ£€æŸ¥ï¼‰</li><li>Substitutionï¼šæ›¿æ¢</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/5.png" width="550"></center><h3 id="term-equation">3.2. term equation</h3><ul><li>The unifiability of ${p(f(x)),g(y),p(f(f(a))),g(z)}$ is expressed by the set of term equations<ul><li>${f(x)&#x3D;f(f(a)), g(y)&#x3D;g(z)}$</li></ul></li></ul><h3 id="solved-form">3.3. solved form</h3><ul><li>A set of term equations is in solved form iff:<ul><li>All equations are of the form $x_i &#x3D;t_i$ where x i is a variable.</li><li>Each variable $x_i$ that appears on the left-hand side of an equation does not appear elsewhere in the set.</li></ul></li><li>A set of equations in solved form defines a substitution:<ul><li>${x_1\leftarrow{t_1},â€¦,x_n\leftarrow{t_n}}$</li></ul></li></ul><h2 id="Ordered-resolution-with-selection">4. Ordered resolution with selection</h2><h3 id="Selection-functions">4.1. Selection functions</h3><ul><li>A selection function is a mapping<ul><li>$S : C\rightarrowtail{}$ (multi-)set of occurrences of <strong>negative</strong> literals in C</li></ul></li></ul><center><img loading="lazy" src="/posts/e24b211f/7.png" width="550"></center><h3 id="Maximal-and-strictly-maximal-literals">4.2. Maximal and strictly maximal literals</h3><center><img loading="lazy" src="/posts/e24b211f/6.png" width="550"></center><ul><li>ç‰¹åˆ«æ³¨æ„ç¬¬ä¸‰ä¸ªï¼Œè¦æ±‚çš„æ˜¯there existå°±å¯ï¼Œå› æ­¤ç±»ä¼¼ $P(f (x)) âˆ¨ P (g(y))$ä¸­æ‰¾æœ€å¤§ï¼Œå°±å¾—åˆ†æƒ…å†µè®¨è®º<ul><li>æ˜¯å¦å¯èƒ½ç›¸ç­‰ï¼Ÿ</li></ul></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/8.png" width="550"></center><ul><li>A literal L is (strictly) maximal wrt. a general clause C<ul><li>iff âˆƒ gr. Ïƒ s.t. LÏƒ and $C_Ïƒ$ are ground and for all Lâ€™ in $C_Ïƒ$: $L_Ïƒ\geq{Lâ€™}$ ($L_Ïƒ&gt;{Lâ€™}$)</li></ul></li></ul><h2 id="General-resolution-system">5. General resolution system</h2><p>Ordered resolution with selection is parameterisedå‚æ•°åŒ– with:</p><ul><li>a fixed total, well-founded ordering $&gt;$ on ground atoms</li><li>a fixed selection function S</li></ul><h3 id="Resolution-rule">5.1. Resolution rule</h3><center><img loading="lazy" src="/posts/e24b211f/9.png" width="550"></center><ul><li>Note: Renaming variables apart needs to be applied to the premises before applying resolution</li></ul><h3 id="Factoring-rule">5.2. Factoring rule</h3><center><img loading="lazy" src="/posts/e24b211f/10.png" width="550"></center><ul><li>Factorså³ä¸º: $Câˆ¨A$</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/11.png" width="550"></center><center><img loading="lazy" src="/posts/e24b211f/16.png" width="550"></center><p><strong>æ³¨æ„</strong></p><center><img loading="lazy" src="/posts/e24b211f/17.png" width="550"></center><h3 id="for-propositional-x2F-ground-clauses-å›é€€åˆ°å‘½é¢˜é€»è¾‘">5.3. for propositional&#x2F;ground clauses å›é€€åˆ°å‘½é¢˜é€»è¾‘</h3><center><img loading="lazy" src="/posts/e24b211f/12.png" width="550"></center><h3 id="Search-spaces-become-smaller">5.4. Search spaces become smaller</h3><center><img loading="lazy" src="/posts/e24b211f/13.png" width="550"></center><h3 id="Properties-of-ordered-resolution-with-selection">5.5. Properties of ordered resolution with selection</h3><center><img loading="lazy" src="/posts/e24b211f/15.png" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/14.png" width="550"></center>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;atom-vs-literal-vs-term&quot;&gt;1. atom vs literal  vs term&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;a: $p$&lt;ul&gt;
&lt;li&gt;åœ¨ä¸€é˜¶é€»è¾‘ä¸‹å¾—åˆ°æ‰©å±•&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;l: $p$  $\lnot{p}$  &lt;ul&gt;
&lt;li&gt;æ³¨æ„æ‰©å±•åˆ°å‘½é¢˜é€»è¾‘ä¸­æ—¶ï¼Œ$P$å°±å¯ä»¥å¸¦ä¸Šå‡½æ•°å’Œè°“è¯&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In propositional calculus a literal is simply a propositional variable or its negation.&lt;/li&gt;
&lt;li&gt;In predicate calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, ${\displaystyle P(t_{1},\ldots ,t_{n})}$ with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example,  ${\displaystyle \neg Q(f(g(x),y,2),x)}$ is a negative literal with the &lt;strong&gt;constant symbol&lt;/strong&gt; 2, the &lt;strong&gt;variable symbols&lt;/strong&gt; x, y, the &lt;strong&gt;function symbol&lt;/strong&gt;s f, g, and the &lt;strong&gt;predicate symbol&lt;/strong&gt; Q.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;t: $p$  $f^{n}$  $a$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;åˆä¸€-Unification&quot;&gt;2. åˆä¸€ Unification&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Let s and t be two terms (or atoms), A &lt;strong&gt;unifier&lt;/strong&gt; of s and t is a substitition &lt;strong&gt;Ïƒ&lt;/strong&gt; that makes the two identical, formally&lt;ul&gt;
&lt;li&gt;sÏƒ &amp;#x3D; tÏƒ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e24b211f/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;æœ€ä¸€èˆ¬çš„åˆä¸€-Most-general-unifier&quot;&gt;2.1. æœ€ä¸€èˆ¬çš„åˆä¸€ Most general unifier&lt;/h3&gt;&lt;p&gt;Ïƒ is a most general unifier of s and t, denoted mgu(s, t),&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if Ïƒ is a unifier of s and t and for any other unifier Î¸ of s and t,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;there is&lt;/strong&gt; a substitution Ï such that&lt;ul&gt;
&lt;li&gt;ÏƒÏ &amp;#x3D; Î¸&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Unifiers-and-most-general-unifiers-in-general&quot;&gt;2.2. Unifiers and most general unifiers, in general&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e24b211f/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ç¨‹åºéªŒè¯-åè®®å®‰å…¨åˆ†æ</title>
    <link href="https://hejueyun.github.io/posts/fa02fe64/"/>
    <id>https://hejueyun.github.io/posts/fa02fe64/</id>
    <published>2022-03-03T12:53:42.000Z</published>
    <updated>2022-03-20T19:29:40.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Neuman-Stubblebine-key-exchange-protocol">1. The Neuman-Stubblebine key exchange protocol</h2><center><img loading="lazy" src="/posts/fa02fe64/1.png" width="550"></center><center><img loading="lazy" src="/posts/fa02fe64/2.png" width="550"></center><h3 id="breaking">1.1. breaking</h3><center><img loading="lazy" src="/posts/fa02fe64/5.png" width="550"></center><ul><li>The intruder now sends a message to B, and the message will make B believe itâ€™s actually from A. Thus B will start to use the wrong key, i.e. an insecure key. <ul><li>å…¥ä¾µè€…ç°åœ¨å‘Bå‘é€ä¸€ä¸ªä¿¡æ¯ï¼Œè¿™ä¸ªä¿¡æ¯å°†ä½¿Bç›¸ä¿¡å®ƒå®é™…ä¸Šæ¥è‡ªAï¼Œå› æ­¤Bå°†å¼€å§‹ä½¿ç”¨é”™è¯¯çš„å¯†é’¥ï¼Œå³ä¸€ä¸ªä¸å®‰å…¨çš„å¯†é’¥ã€‚</li></ul></li></ul><h2 id="Verification-of-security-protocols-using-resolution">2. Verification of security protocols using resolution</h2><ul><li>The idea is that the security property says an unsafe state is possible</li><li>Since first-order logic is not <strong>decidable</strong>, there is however no guarantee that the saturation will terminate when the security property does not hold. Non-termination can therefore indicate the existence of a potential attack on the protocol.</li></ul><center><img loading="lazy" src="/posts/fa02fe64/3.png" width="550"></center><h2 id="Assumptions-in-security-protocol-analysis">3. Assumptions in security protocol analysis</h2><p>What can an intruder do?</p><ul><li>The intruder can capture all messages sent by one participant to another</li><li>It can send a message it has constructed to any other participant</li><li>It can generate new keys, new nonces, timestamps . . .</li><li>It can construct new messages from the ones it has, using legal constructors</li><li>The intruder can decomposeåˆ†è§£ tuples from which messages are formed</li><li>It can decrypt encrypted parts, but only if it knows the key I.e. we assume perfect cryptography: an intruder cannot break any keys nor does it know any of the initial keys $K_{at}$ at or $K_{bt}$</li></ul><h2 id="Encoding">4. Encoding</h2><center><img loading="lazy" src="/posts/fa02fe64/4.png" width="550"></center><h3 id="The-capabilities-of-the-intruderå…¥ä¾µè€…">4.1. The capabilities of the intruderå…¥ä¾µè€…</h3><center><img loading="lazy" src="/posts/fa02fe64/6.png" width="550"></center><center><img loading="lazy" src="/posts/fa02fe64/7.png" width="550"></center><h2 id="SPASS">5. SPASS</h2><blockquote><p>SPASS is an automated theorem prover for first-order logic with equality. So the input for the prover is a first-order formula in our syntax. </p><ul><li>Running SPASS on such a formula results in the final output SPASS beiseite: <code>Proof found.</code> if the formula is valid, </li><li>SPASS beiseite: <code>Completion found.</code> if the formula is not valid </li><li>and because validity in first-order logic is undecidable, <strong>SPASS may run forever without producing any final result.</strong></li></ul></blockquote><hr><blockquote><p>An SPASS input file consists of three parts, a description part started with list_of_descriptions., a part where the signature is declared starting with list_of_symbols., a part where all axioms are given, starting with list_of_formulae(axioms). and a final part where all conjectures are presented, starting with list_of_formulae(conjectures)</p><p>Then SPASS tries to prove that the conjunction of all axiom formulae implies the disjunction of all conjectures</p></blockquote><h2 id="Saturation">6. Saturation</h2><blockquote><p>Aclause C is a <strong>condensation</strong> of a clause D,if C is a proper (unordered) factor of D that subsumes D</p><p>A set of clauses N is called <strong>saturated</strong> if it is closed under condensation, the deletion of subsumed clauses and any clause generated by an ordered resolution inference from clauses from N is subsumed by some clause in N</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;The-Neuman-Stubblebine-key-exchange-protocol&quot;&gt;1. The Neuman-Stubblebine key exchange protocol&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;breaking&quot;&gt;1.1. breaking&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/5.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;The intruder now sends a message to B, and the message will make B believe itâ€™s actually from A. Thus B will start to use the wrong key, i.e. an insecure key. &lt;ul&gt;
&lt;li&gt;å…¥ä¾µè€…ç°åœ¨å‘Bå‘é€ä¸€ä¸ªä¿¡æ¯ï¼Œè¿™ä¸ªä¿¡æ¯å°†ä½¿Bç›¸ä¿¡å®ƒå®é™…ä¸Šæ¥è‡ªAï¼Œå› æ­¤Bå°†å¼€å§‹ä½¿ç”¨é”™è¯¯çš„å¯†é’¥ï¼Œå³ä¸€ä¸ªä¸å®‰å…¨çš„å¯†é’¥ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Verification-of-security-protocols-using-resolution&quot;&gt;2. Verification of security protocols using resolution&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The idea is that the security property says an unsafe state is possible&lt;/li&gt;
&lt;li&gt;Since first-order logic is not &lt;strong&gt;decidable&lt;/strong&gt;, there is however no guarantee that the saturation will terminate when the security property does not hold. Non-termination can therefore indicate the existence of a potential attack on the protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/3.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Assumptions-in-security-protocol-analysis&quot;&gt;3. Assumptions in security protocol analysis&lt;/h2&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è¥¿è¡Œæ¼«è®°-å…¶å…­</title>
    <link href="https://hejueyun.github.io/posts/2ba8f82c/"/>
    <id>https://hejueyun.github.io/posts/2ba8f82c/</id>
    <published>2022-02-26T22:26:20.000Z</published>
    <updated>2022-03-27T12:26:12.528Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Authenticaiton Failed." data-whm="Authentication Error.">  <script id="hbeData" type="hbeData" data-hmacdigest="a3bc817c3908ae67f704dabface47ef124dac94f6605c34ea7c8fd49515ab6c8">63a8672ddbb5b9158eb55097173249fad22b496a8876cf71b079381ad234cb95f094e21606daf1717aa32ac9bb46c3ec99a387f812d0a9e5a45bfd529c7b8ed5f86a0a6f45900b64a15b4130bd6ed52d8ef450f58e114d4fe18874ddcc125aa94adc7a4a8723b962b279a3d4fb7200835168fbe214ea68576e259f43343e2c7a777ab0f877cfb6fb4968bbe09478ebb4c8d82d533ea85f08a5195375f39c020dcf3cc513e539010453d4dc45f2948ba6de705108a00df9f7fc634cf34cf86bc985f7ae3ca2e1587e4469e2a695bfe5527047967d1184b513411930c48dbd3b183dbfe7eee873eff520957b049943bd7990c9027c77c010cf1c251f76064497d73aea9ab2a92c884d7e6a130b44100c9333493c6642eb39253827e8e7ee7be21ffa64373cba57238a83b953034350313408910b4f2679f2f08874a410bd240537e5df887e00d303bf15e0484321af3906101f651a5df62e1da0c56825bc53493bbacbdf596d137e27fd97b6c628bac1d18116316522c0f356832bdd769f420308aa8da425e501748296d0620ffcd2d204a6dc5558914c11fd7a1524e4a74f9b204bbd20c161cc1478f443c050f4ba0a2a920b98de1a54ffce1c44fc2f468058f0bb1e886e03126f45b33810e77bf6f346451c74bd304ed8bab57935484589bc2b1a746cb687de37762f1e3b10d6cfd7444ea4341b5bbaa363926e42f063f44b8f46d6605499ae1f341a8c790ae5bd18455a40510f81640659cedde4b9a1fc6db20b8923908bfcf4ae5c13fc518f33bc48541a2a7d3d6fa89d14d5b18660c04253e8df7a62ce6fc0f4ad77bacf3ed63e1debcc332519106136f1b2641e6b830db62a33b2814ade061b05c363610e54b4c33600d8f2a0b2cf0b5403307e91398cbbbb0ce1f3b35c40cf626f9a795e2c058a9888a016c8c300275a53050c70428dc6d716a592ca1dce1d3197c52f6b275d568a2743e0a76310126832d79fdcfc43732d3899a62320175ad5adfe51baf995eab391023ce63c80e7455f778279bae1b6cfa16a1f3fd6064e80b6edb960c9308f82803b28c9816effd3c9f18b7513a3462ff3283e482b374f639c4d371942db68469fbb882df4fba4cb46057f569b75b81dd528d80365daf13cf487e52bc0d872243dbcfa67e2662311be95169f4e3457537866e44a36183036a169aacb02f0364d0d8cd0e140707d5209b2a1af7333465fb987f7b541f65c6cc0fbd606bfe4f0c894625694563e1066468c3eb3621726bd64d23457ecfd39f2a80d573eaaf792330c5f431e88122d3cfa94437d24ab67b6275def89af510353f2a7489517b3c411db28635f7153403306aad70c5e9df7334a7fd589a6a3f75a51a7d6b6f787483545bfa8792edc7b2e4dcfc0fe43266617f408469c97bec089db0698d88bb025bfbd78f55264612f849e271cccf941010f831a58402c52173aa717e8b37950c2a3b460296672b585a2ae788b6f3b7c8090b5607688c4cafd8127c8e4ee6cd27a674759cae2d3491fa85850f8b7a2a6e4bcafe4b7130eb79a9520098f2fb0b47a58bc5befda2d0dff0985f0a5cc7b772d813bba5ef07576a87164e367fc73f2a0bf6835de598f88ecd078a36b94b34b8a357e603cded2557ec4f70929061db31af874a1464d0e0dd987fc578a673d0a337ae4e741be8864ab69bbc3bdebd6cc40f6ca541d2da832b73a9e0a784ec4a2a9881589cf5f1eca7ced187f2d61810e0605850bb28a2e0ddfd6d5fda5f6daf84446297a9ed808180db8985a74dc9bda783c8404a40816f5aa2e46472bfb0910fcbbf951ef6c00918ad218dd9ab2987f761d0925d0ef773c46fe4b7a161cedfc9b45c3ffdeb1de189b73be8fb6b988d56f7a0995999f0142f5cff66e3f48f8ff9aa4fa5d55cae1b3b28982f24b60eb6b2a013d1dbfe24a8ae7d060303846c826d30750266845c421f1cfb6284aaacfb809aa1f8cb2569943fa79b0a62156ce334515f7c49b2b3d7e15e7119bb61de88efddfcdddef82aa1c03a6a406a5558f5a19366ac18a0592f71ca072505313fb73a1170cdf6a366ab5af2c52234c20f20d5aa161384bc13a4181564db10d98fe6cd0df70f7d0b656d4cf22a4452ac33ed23ab0850e97ec391945ea2d35aa57102d3f7c9a52caa07c69252cc294b2917a61a22745bba81d0ab2cf3ab8fe96f5f8b88743444dea132dbb071087860a659b2f898c983e26249acf4e28b490b33a068809d43ee74895d7151833327cf9292c66c06fc66cc9e95586aba56fae820ff58101e2f3e7ccd5822b040cfc1c056b6ef68f8969d3c99f5a30d315b6a034bc88297af5601d1871e16caf265742b3c6a642b19e9f6f6794db94031bf90772091158922f53eec44078767c2b91d0a3209f32579c1a614ee5ecd41649d5e2914539a1b5099d13ea62045953d898e3c3299aa755f8a7d7f66d786f96a0678ba89744e1c1dd8eaed3853524794b50e94d5e42ec7d0c081151729648645308b00e9c95cc05ec5d649abf41b0a3ee729dc47aaffba089a3a7e228db9872879a8ce2750c66da4ab6c4e7062ab5ba7d323a2a07152a76f579c7cde3de94b9ac3a40049a6657917455fb6aeb02b75a7624e0f9bd302f852f98cc5949dbc91698a64c9cc57ad6a9c381ed372f0c3a390c9fe743e3855f7ee27289155bad0ef53c288fee088346517abc31e122e4897ff8fa5ce878ef35d93a1ba0e1a4ce39959c887525c1c1b8067f157686a8f7ac89d55078ec7230c4f62dfe01f6ae148cf3c62e428bc058a2121b8ea479aee258882493a4d5a91b633c6ec15f907ca53b06a3f0d0e05ec37e3a1db600461ce81b5b93ed5f894aa7f2feb1ed509912cdb3efd473444055d0fb07e0b456c6e1ad1bd4abd6ac38b2d01087f8baeffcb7594332834ea8295fa7d4668f0abb95f0242cfcd5953fd3b11b643a4e25b9c5ec13387e99faf24235dfdb215433217508d107c4393a84ca6bc4bd49bb562b77298220918e52e2d88f2a3c5177795aae347a4177f6d4937cacbd5e5c4ecbcc7081181b4bd65e862d818047d7e16712db3b8ec117d6230e832c8c9f590223188ca37d7f49620c3cf0fd771bb277bb4d1ccbbaa4c604248234fcbe3ed2a3cfb01c6ff72184ebaca088ccdb479e3bc41f475386277fbef50af51554d77d319aee4583a3a914df0fcf1461522c583cc55feac3e639133f196a8dc98a2c3d0fb746fe35ff6c87415712b49f144b33dc595c82daef511a693bf77f20537d7856befc651a7fb168cd3712c1bd8fe7018d8bdb296acfbdbac10427ab9b04b9aff10661fb759f66015099dab02de9ea25d9e6899a4ee5f2521f7e2093571ee1228005f4ca42af51d8cac3d507aecc9683a7105e89f467c7d451255b92fc2fe5822b3c3b31ec1d8caa8efdcd124545938a1751f30e3f7307f946ddf0d57c2cc8b4506663fd1f4b86beb3d82364c1ad1c63f22610b425d698806564308e162117445c0cf4f5fdc901ec86268162e776d60b7625189fdbdf9dc92e5655c8ccf2a7370d6bdbf69292964890d64be44c88f7b630e96bbfcd852eb083fd79ca55c7f12a4d378a54b9bfb074d3e916112d5a58cf8d749b5cd74d4007f1aaf349dfe63a400b06a507852c241b1aa296162365e0ad043a47209ae80845e6e4fced64b7f52dd8a9163d896f4bf443d5b199766366013d062a794181fde28ac9331795bc2cc77a5e0b52de3c3c00c099e9d3cb373ef771c69c20aed9255385280c3e42eec53920469ab690c8c6d49158146388b401b3186fd462ac2abd820b57e5e9325d859030d70616b14d2bb991ba7b20883a93425828fc70ae6f8171160be59150b2491816f49d6e832bb6c66f5f513ddbfb0d59f6a045dc88288ca21bba554a7a134fa3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password Required.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Authenticaiton Failed.&quot; data-whm=&quot;Authentication Error.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;a3bc817c3908ae67f704dabface47ef124dac94f6605c34ea7c8fd49515ab6c8&quot;&gt;63a8672ddbb5b9158eb55097173249fad22b496a8876cf71b079381ad234cb95f094e21606daf1717aa32ac9bb46c3ec99a387f812d0a9e5a45bfd529c7b8ed5f86a0a6f45900b64a15b4130bd6ed52d8ef450f58e114d4fe18874ddcc125aa94adc7a4a8723b962b279a3d4fb7200835168fbe214ea68576e259f43343e2c7a777ab0f877cfb6fb4968bbe09478ebb4c8d82d533ea85f08a5195375f39c020dcf3cc513e539010453d4dc45f2948ba6de705108a00df9f7fc634cf34cf86bc985f7ae3ca2e1587e4469e2a695bfe5527047967d1184b513411930c48dbd3b183dbfe7eee873eff520957b049943bd7990c9027c77c010cf1c251f76064497d73aea9ab2a92c884d7e6a130b44100c9333493c6642eb39253827e8e7ee7be21ffa64373cba57238a83b953034350313408910b4f2679f2f08874a410bd240537e5df887e00d303bf15e0484321af3906101f651a5df62e1da0c56825bc53493bbacbdf596d137e27fd97b6c628bac1d18116316522c0f356832bdd769f420308aa8da425e501748296d0620ffcd2d204a6dc5558914c11fd7a1524e4a74f9b204bbd20c161cc1478f443c050f4ba0a2a920b98de1a54ffce1c44fc2f468058f0bb1e886e03126f45b33810e77bf6f346451c74bd304ed8bab57935484589bc2b1a746cb687de37762f1e3b10d6cfd7444ea4341b5bbaa363926e42f063f44b8f46d6605499ae1f341a8c790ae5bd18455a40510f81640659cedde4b9a1fc6db20b8923908bfcf4ae5c13fc518f33bc48541a2a7d3d6fa89d14d5b18660c04253e8df7a62ce6fc0f4ad77bacf3ed63e1debcc332519106136f1b2641e6b830db62a33b2814ade061b05c363610e54b4c33600d8f2a0b2cf0b5403307e91398cbbbb0ce1f3b35c40cf626f9a795e2c058a9888a016c8c300275a53050c70428dc6d716a592ca1dce1d3197c52f6b275d568a2743e0a76310126832d79fdcfc43732d3899a62320175ad5adfe51baf995eab391023ce63c80e7455f778279bae1b6cfa16a1f3fd6064e80b6edb960c9308f82803b28c9816effd3c9f18b7513a3462ff3283e482b374f639c4d371942db68469fbb882df4fba4cb46057f569b75b81dd528d80365daf13cf487e52bc0d872243dbcfa67e2662311be95169f4e3457537866e44a36183036a169aacb02f0364d0d8cd0e140707d5209b2a1af7333465fb987f7b541f65c6cc0fbd606bfe4f0c894625694563e1066468c3eb3621726bd64d23457ecfd39f2a80d573eaaf792330c5f431e88122d3cfa94437d24ab67b6275def89af510353f2a7489517b3c411db28635f7153403306aad70c5e9df7334a7fd589a6a3f75a51a7d6b6f787483545bfa8792edc7b2e4dcfc0fe43266617f408469c97bec089db0698d88bb025bfbd78f55264612f849e271cccf941010f831a58402c52173aa717e8b37950c2a3b460296672b585a2ae788b6f3b7c8090b5607688c4cafd8127c8e4ee6cd27a674759cae2d3491fa85850f8b7a2a6e4bcafe4b7130eb79a9520098f2fb0b47a58bc5befda2d0dff0985f0a5cc7b772d813bba5ef07576a87164e367fc73f2a0bf6835de598f88ecd078a36b94b34b8a357e603cded2557ec4f70929061db31af874a1464d0e0dd987fc578a673d0a337ae4e741be8864ab69bbc3bdebd6cc40f6ca541d2da832b73a9e0a784ec4a2a9881589cf5f1eca7ced187f2d61810e0605850bb28a2e0ddfd6d5fda5f6daf84446297a9ed808180db8985a74dc9bda783c8404a40816f5aa2e46472bfb0910fcbbf951ef6c00918ad218dd9ab2987f761d0925d0ef773c46fe4b7a161cedfc9b45c3ffdeb1de189b73be8fb6b988d56f7a0995999f0142f5cff66e3f48f8ff9aa4fa5d55cae1b3b28982f24b60eb6b2a013d1dbfe24a8ae7d060303846c826d30750266845c421f1cfb6284aaacfb809aa1f8cb2569943fa79b0a62156ce334515f7c49b2b3d7e15e7119bb61de88efddfcdddef82aa1c03a6a406a5558f5a19366ac18a0592f71ca072505313fb73a1170cdf6a366ab5af2c52234c20f20d5aa161384bc13a4181564db10d98fe6cd0df70f7d0b656d4cf22a4452ac33ed23ab0850e97ec391945ea2d35aa57102d3f7c9a52caa07c69252cc294b2917a61a22745bba81d0ab2cf3ab8fe96f5f8b88743444dea132dbb071087860a659b2f898c983e26249acf4e28b490b33a068809d43ee74895d7151833327cf9292c66c06fc66cc9e95586aba56fae820ff58101e2f3e7ccd5822b040cfc1c056b6ef68f8969d3c99f5a30d315b6a034bc88297af5601d1871e16caf265742b3c6a642b19e9f6f6794db94031bf90772091158922f53eec44078767c2b91d0a3209f32579c1a614ee5ecd41649d5e2914539a1b5099d13ea62045953d898e3c3299aa755f8a7d7f66d786f96a0678ba89744e1c1dd8eaed3853524794b50e94d5e42ec7d0c081151729648645308b00e9c95cc05ec5d649abf41b0a3ee729dc47aaffba089a3a7e228db9872879a8ce2750c66da4ab6c4e7062ab5ba7d323a2a07152a76f579c7cde3de94b9ac3a40049a6657917455fb6aeb02b75a7624e0f9bd302f852f98cc5949dbc91698a64c9cc57ad6a9c381ed372f0c3a390c9fe743e3855f7ee27289155bad0ef53c288fee088346517abc31e122e4897ff8fa5ce878ef35d93a1ba0e1a4ce39959c887525c1c1b8067f157686a8f7ac89d55078ec7230c4f62dfe01f6ae148cf3c62e428bc058a2121b8ea479aee258882493a4d5a91b633c6ec15f907ca53b06a3f0d0e05ec37e3a1db600461ce81b5b93ed5f894aa7f2feb1ed509912cdb3efd473444055d0fb07e0b456c6e1ad1bd4abd6ac38b2d01087f8baeffcb7594332834ea8295fa7d4668f0abb95f0242cfcd5953fd3b11b643a4e25b9c5ec13387e99faf24235dfdb215433217508d107c4393a84ca6bc4bd49bb562b77298220918e52e2d88f2a3c5177795aae347a4177f6d4937cacbd5e5c4ecbcc7081181b4bd65e862d818047d7e16712db3b8ec117d6230e832c8c9f590223188ca37d7f49620c3cf0fd771bb277bb4d1ccbbaa4c604248234fcbe3ed2a3cfb01c6ff72184ebaca088ccdb479e3bc41f475386277fbef50af51554d77d319aee4583a3a914df0fcf1461522c583cc55feac3e639133f196a8dc98a2c3d0fb746fe35ff6c87415712b49f144b33dc595c82daef511a693bf77f20537d7856befc651a7fb168cd3712c1bd8fe7018d8bdb296acfbdbac10427ab9b04b9aff10661fb759f66015099dab02de9ea25d9e6899a4ee5f2521f7e2093571ee1228005f4ca42af51d8cac3d507aecc9683a7105e89f467c7d451255b92fc2fe5822b3c3b31ec1d8caa8efdcd124545938a1751f30e3f7307f946ddf0d57c2cc8b4506663fd1f4b86beb3d82364c1ad1c63f22610b425d698806564308e162117445c0cf4f5fdc901ec86268162e776d60b7625189fdbdf9dc92e5655c8ccf2a7370d6bdbf69292964890d64be44c88f7b630e96bbfcd852eb083fd79ca55c7f12a4d378a54b9bfb074d3e916112d5a58cf8d749b5cd74d4007f1aaf349dfe63a400b06a507852c241b1aa296162365e0ad043a47209ae80845e6e4fced64b7f52dd8a9163d896f4bf443d5b199766366013d062a794181fde28ac9331795bc2cc77a5e0b52de3c3c00c099e9d3cb373ef771c69c20aed9255385280c3e42eec53920469ab690c8c6d49158146388b401b3186fd462ac2abd820b57e5e9325d859030d70616b14d2bb991ba7b20883a93425828fc70ae6f8171160be59150b2491816f49d6e832bb6c66f5f513ddbfb0d59f6a045dc88288ca21bba554a7a134fa3&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-default&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-default&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-default&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-default&quot;&gt;Password Required.&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script data-pjax src=&quot;/lib/hbe.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/hbe.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</summary>
    
    
    
    <category term="éšç¬”" scheme="https://hejueyun.github.io/categories/essay/"/>
    
    
    <category term="essay" scheme="https://hejueyun.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-é€»è¾‘ç¼–ç¨‹</title>
    <link href="https://hejueyun.github.io/posts/faaea58c/"/>
    <id>https://hejueyun.github.io/posts/faaea58c/</id>
    <published>2022-02-25T22:58:44.000Z</published>
    <updated>2022-02-27T00:04:40.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Resolution was originally developed as a method for automatic theorem proving. Later, it was discovered that a restricted form of resolution can be used for programming a computation. This approach is called logic programming. </p><ul><li>A <strong>program</strong> is expressed as <strong>a set of clauses</strong> </li><li>A <strong>query</strong> is expressed as <strong>an additional clause</strong> that can <strong>clash</strong>å†²çª with one or more of the program clauses. <strong>The query is assumed to be the negation of result of the program</strong>. If a refutation succeeds, the <strong>query</strong> is not a <strong>logical consequence</strong> of the program, so its <strong>negation</strong> must be a <strong>logical consequence</strong>.</li></ul><p>è§£ææœ€åˆæ˜¯ä½œä¸ºä¸€ç§è‡ªåŠ¨å®šç†è¯æ˜çš„æ–¹æ³•è€Œå¼€å‘çš„ã€‚åæ¥ï¼Œäººä»¬å‘ç°ï¼Œä¸€ç§å—é™åˆ¶çš„å†³è®®å½¢å¼å¯ä»¥ç”¨äºè®¡ç®—çš„ç¼–ç¨‹ã€‚è¿™ç§æ–¹æ³•è¢«ç§°ä¸ºé€»è¾‘ç¼–ç¨‹ã€‚</p><ul><li>ä¸€ä¸ªç¨‹åºè¢«è¡¨è¾¾ä¸ºä¸€ç»„å­å¥</li><li>ä¸€ä¸ªæŸ¥è¯¢è¢«è¡¨è¾¾ä¸ºä¸€ä¸ªé¢å¤–çš„å­å¥ï¼Œå¯ä»¥ä¸ä¸€ä¸ªæˆ–å¤šä¸ªç¨‹åºå­å¥å‘ç”Ÿå†²çªã€‚æŸ¥è¯¢è¢«è®¤ä¸ºæ˜¯å¯¹ç¨‹åºç»“æœçš„å¦å®šã€‚å¦‚æœåé©³æˆåŠŸï¼ŒæŸ¥è¯¢ä¸æ˜¯ç¨‹åºçš„é€»è¾‘ç»“æœï¼Œæ‰€ä»¥å®ƒçš„å¦å®šå¿…é¡»æ˜¯ä¸€ä¸ªé€»è¾‘ç»“æœ</li></ul></blockquote><h2 id="From-Formulas-in-Logic-to-Logic-Programming">1. From Formulas in Logic to Logic Programming</h2><p><strong>program clauses</strong></p><ul><li>æŒ‰æˆ‘çš„ç†è§£å°±æ˜¯éœæ©å­å¥</li></ul><p><strong>goal clause</strong></p><ul><li>Suppose now that we have a set of program clauses and we want to prove that some formula:<ul><li>$G_1\land{}â€¦\land{}G_n$</li></ul></li><li>is a <strong>logical consequence</strong> of the set. This can be done by taking the negation of the formula:<ul><li>$\lnot{}G_1\lor{}â€¦\lor{}\lnot{}G_n$</li></ul></li><li>and refuting it by resolution with the program clauses<blockquote><p>The formula $Â¬â€‰G_1âˆ¨â‹¯âˆ¨Â¬â€‰G_n$ , called a <strong>goal clause</strong>, consists entirely of negative literals, so it can only clash on the single positive literal of a program clause</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Resolution was originally developed as a method for automatic theorem proving. Later, it was discovered that a restricted form of resolution can be used for programming a computation. This approach is called logic programming. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;program&lt;/strong&gt; is expressed as &lt;strong&gt;a set of clauses&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;query&lt;/strong&gt; is expressed as &lt;strong&gt;an additional clause&lt;/strong&gt; that can &lt;strong&gt;clash&lt;/strong&gt;å†²çª with one or more of the program clauses. &lt;strong&gt;The query is assumed to be the negation of result of the program&lt;/strong&gt;. If a refutation succeeds, the &lt;strong&gt;query&lt;/strong&gt; is not a &lt;strong&gt;logical consequence&lt;/strong&gt; of the program, so its &lt;strong&gt;negation&lt;/strong&gt; must be a &lt;strong&gt;logical consequence&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è§£ææœ€åˆæ˜¯ä½œä¸ºä¸€ç§è‡ªåŠ¨å®šç†è¯æ˜çš„æ–¹æ³•è€Œå¼€å‘çš„ã€‚åæ¥ï¼Œäººä»¬å‘ç°ï¼Œä¸€ç§å—é™åˆ¶çš„å†³è®®å½¢å¼å¯ä»¥ç”¨äºè®¡ç®—çš„ç¼–ç¨‹ã€‚è¿™ç§æ–¹æ³•è¢«ç§°ä¸ºé€»è¾‘ç¼–ç¨‹ã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¸€ä¸ªç¨‹åºè¢«è¡¨è¾¾ä¸ºä¸€ç»„å­å¥&lt;/li&gt;
&lt;li&gt;ä¸€ä¸ªæŸ¥è¯¢è¢«è¡¨è¾¾ä¸ºä¸€ä¸ªé¢å¤–çš„å­å¥ï¼Œå¯ä»¥ä¸ä¸€ä¸ªæˆ–å¤šä¸ªç¨‹åºå­å¥å‘ç”Ÿå†²çªã€‚æŸ¥è¯¢è¢«è®¤ä¸ºæ˜¯å¯¹ç¨‹åºç»“æœçš„å¦å®šã€‚å¦‚æœåé©³æˆåŠŸï¼ŒæŸ¥è¯¢ä¸æ˜¯ç¨‹åºçš„é€»è¾‘ç»“æœï¼Œæ‰€ä»¥å®ƒçš„å¦å®šå¿…é¡»æ˜¯ä¸€ä¸ªé€»è¾‘ç»“æœ&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;From-Formulas-in-Logic-to-Logic-Programming&quot;&gt;1. From Formulas in Logic to Logic Programming&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;program clauses&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æŒ‰æˆ‘çš„ç†è§£å°±æ˜¯éœæ©å­å¥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;goal clause&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suppose now that we have a set of program clauses and we want to prove that some formula:&lt;ul&gt;
&lt;li&gt;$G_1\land{}â€¦\land{}G_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;is a &lt;strong&gt;logical consequence&lt;/strong&gt; of the set. This can be done by taking the negation of the formula:&lt;ul&gt;
&lt;li&gt;$\lnot{}G_1\lor{}â€¦\lor{}\lnot{}G_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;and refuting it by resolution with the program clauses&lt;blockquote&gt;
&lt;p&gt;The formula $Â¬â€‰G_1âˆ¨â‹¯âˆ¨Â¬â€‰G_n$ , called a &lt;strong&gt;goal clause&lt;/strong&gt;, consists entirely of negative literals, so it can only clash on the single positive literal of a program clause&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-æ—¶åºé€»è¾‘-è¯­æ³•ä¸è¯­ä¹‰</title>
    <link href="https://hejueyun.github.io/posts/150c47ae/"/>
    <id>https://hejueyun.github.io/posts/150c47ae/</id>
    <published>2022-02-24T13:30:06.000Z</published>
    <updated>2022-03-29T20:30:44.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction">1. Introduction</h2><blockquote><p>Temporal logic is a formal system for reasoning about time. Temporal logic has found extensive application in computer science, because the behavior of both hardware and software is a function of time.</p></blockquote><blockquote><p>Temporal logics are related to formal systems called modal logics. Modal logics express the distinction between what is necessarily true and what is possibly true. For example, the statement â€˜7 is a prime numberâ€™ is necessarily true becauseâ€”given the definitions of the concepts in the statementâ€”the statement is true always and everywhere. In contrast, the statement the head of state of this country is a king is possibly true, because its truth changes from place to place and from time to time. Temporal logic and modal logic are related because â€˜alwaysâ€™ is similar to â€˜necessarilyâ€™ and â€˜eventuallyâ€™ to â€˜possiblyâ€™.</p><p>æ—¶é—´é€»è¾‘ä¸ç§°ä¸ºæ¨¡æ€é€»è¾‘çš„å½¢å¼ç³»ç»Ÿæœ‰å…³ã€‚æ¨¡æ€é€»è¾‘è¡¨è¾¾äº†ä»€ä¹ˆæ˜¯å¿…ç„¶çœŸå®å’Œä»€ä¹ˆæ˜¯å¯èƒ½çœŸå®ä¹‹é—´çš„åŒºåˆ«ã€‚ä¾‹å¦‚ï¼Œâ€7æ˜¯è´¨æ•° â€œè¿™ä¸ªé™ˆè¿°å¿…ç„¶æ˜¯çœŸå®çš„ï¼Œå› ä¸ºâ€“è€ƒè™‘åˆ°é™ˆè¿°ä¸­æ¦‚å¿µçš„å®šä¹‰â€“è¿™ä¸ªé™ˆè¿°æ€»æ˜¯çœŸå®çš„ï¼Œè€Œä¸”æ— å¤„ä¸åœ¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™ä¸ªå›½å®¶çš„å›½å®¶å…ƒé¦–æ˜¯å›½ç‹çš„è¯´æ³•å¯èƒ½æ˜¯çœŸçš„ï¼Œå› ä¸ºå®ƒçš„çœŸç†åœ¨ä¸åŒçš„åœ°æ–¹å’Œä¸åŒçš„æ—¶é—´ä¼šå‘ç”Ÿå˜åŒ–ã€‚æ—¶é—´é€»è¾‘å’Œæ¨¡æ€é€»è¾‘æ˜¯ç›¸å…³çš„ï¼Œå› ä¸º â€œæ€»æ˜¯ â€œç±»ä¼¼äº â€œå¿…ç„¶â€ï¼Œâ€æœ€ç»ˆ â€œç±»ä¼¼äº â€œå¯èƒ½â€ã€‚</p></blockquote><ul><li>æ—¶é—´é€»è¾‘ä¸æ¨¡æ€é€»è¾‘ç›¸ä¼¼ï¼Œåªæ˜¯<strong>çŠ¶æ€</strong>è¢«è®¤ä¸ºæ˜¯æŒ‡å®šåœ¨æŸä¸€ç‰¹å®šæ—¶é—´ç‚¹ä¸Šçš„çœŸå®æƒ…å†µï¼Œè€Œ<strong>è½¬æ¢</strong>åˆ™å®šä¹‰äº†æ—¶é—´çš„æµé€</li></ul><h2 id="PTL">2. PTL</h2><h3 id="Syntax">2.1. Syntax</h3><ul><li>The syntax of propositional temporal logic (PTL) is defined like the syntax of propositional logic, <strong>except for the addition of two additional unary operators</strong>:<ul><li><code>â–¡</code> , read always</li><li><code>â—Š</code> , read eventually</li></ul></li><li>$(Â¬â€‰â—Šp)âˆ§(â–¡Â¬â€‰q)$<ul><li>the temporal operators and negation have higher precedenceä¼˜å…ˆæƒ than the conjunction operator</li></ul></li></ul><h3 id="semantic">2.2. semantic</h3><ul><li>Informally, â–¡ is a universal operator meaning â€˜<strong>for any time t in the future</strong>â€™, while â—Š is an existential operator meaning â€˜<strong>for some time t in the future</strong>â€™</li></ul><h3 id="transition-diagram-çŠ¶æ€è½¬æ¢å›¾">2.3. transition diagram çŠ¶æ€è½¬æ¢å›¾</h3><ul><li><p><strong>Interpretations</strong> of PTL formulas are based upon state transition diagrams. </p><ul><li>The intuitiveç›´è§‚ meaning is that each state represents a world and <strong>a formula can have different truth values in different worlds</strong>. The transitions represent changes from one world to another.</li></ul></li><li><p>A state transition diagram is a <strong>directed graph</strong>æœ‰å‘å›¾.</p><ul><li>The nodes are states and the edges are transitions. èŠ‚ç‚¹æ˜¯çŠ¶æ€ï¼Œè¾¹æ˜¯è½¬æ¢</li><li>Each state is labeled with a set of propositional literals such that clashing literals do not appear in any state. æ¯ä¸ªçŠ¶æ€éƒ½æ ‡æœ‰ä¸€ä¸ªå‘½é¢˜å­—é¢é‡çš„é›†åˆï¼Œè¿™æ ·å†²çªçš„å­—é¢é‡å°±ä¸ä¼šå‡ºç°åœ¨ä»»ä½•çŠ¶æ€ä¸­</li></ul></li><li><p>A formula that contains a <strong>temporal operator</strong> is interpreted using the transitions between the states</p><ul><li>ä¸€ä¸ªåŒ…å«æ—¶é—´è¿ç®—ç¬¦çš„å…¬å¼è¢«è§£é‡Šä¸ºä½¿ç”¨çŠ¶æ€ä¹‹é—´çš„è½¬æ¢</li></ul></li></ul><center><img loading="lazy" src="/posts/150c47ae/2.gif" width="550"></center><center><img loading="lazy" src="/posts/150c47ae/1.gif" width="550"></center><ul><li>If an atom is not shown in the label of a state, it is assumed to be assigned <strong>F</strong>.</li></ul><center><img loading="lazy" src="/posts/150c47ae/3.gif" width="550"></center><center><img loading="lazy" src="/posts/150c47ae/4.gif" width="550"></center><ul><li>$s:P \rightarrow { T,F }$</li><li>A <strong>binary relation</strong> can be considered to be <strong>a mapping from a state to a set of states</strong> $Ï:Sâ†’2^{S}$ , so the relational notation $(s_1,s_2)âˆˆÏ$ will usually be written functionally as $s_2âˆˆÏ(s_1)$<ul><li>æ³¨æ„$s_1$å’Œ$s_2$é¡ºåºå…³ç³»</li></ul></li></ul><h3 id="truth-value">2.4. truth value</h3><center><img loading="lazy" src="/posts/150c47ae/5.png" width="550"></center><ul><li><p>æ³¨æ„æœ€åä¸€è¡Œå¾—notation</p></li><li><p>$Ï(s_0)&#x3D;{s_1,s_2}$. Since $s_1âŠ¨q$ and $s_2âŠ¨q$, it follows that $s_0âŠ¨â–¡q$. By the semantics of $âˆ¨$, $s _0âŠ¨â–¡pâˆ¨â–¡q$.</p></li><li><p>$s_3âˆˆÏ(s_1)$, but $s_3 \not\models p$ and $s_3 \not\models q$ , so $s_1 \not\models â–¡p$ and $s_1 \not\models â–¡q$ . Therefore, $s_1 \not\models â–¡p \lor â–¡q$</p></li></ul><h3 id="Satisfiability-and-Validity">2.5. Satisfiability and Validity</h3><blockquote><p>The definition of semantic properties in PTL is more complex than it is in propositional or first-order logic, because an interpretation consists of <strong>both states and truth values</strong></p></blockquote><center><img loading="lazy" src="/posts/150c47ae/6.png" width="550"></center><blockquote><p>There are other formulas of PTL that are valid because of properties of temporal logic and not as instances of propositional validities. We will prove the validity of two formulas directly from the semantic definition. The first establishes a duality between â–¡ and â—Š, and the second is the distribution of â–¡ over â†’, similar to the distribution of âˆ€ over â†’.</p></blockquote><h4 id="Duality">2.5.1. Duality</h4><ul><li>$âŠ¨â–¡pâ†”Â¬â€‰â—ŠÂ¬â€‰p$</li></ul><h2 id="Models-of-Time">3. Models of Time</h2><blockquote><p><strong>In modal and temporal logics, different logics can be obtained by placing restrictions on the transition relation</strong></p><ul><li>åœ¨æ¨¡æ€å’Œæ—¶é—´é€»è¾‘ä¸­ï¼Œé€šè¿‡å¯¹è½¬æ¢å…³ç³»çš„é™åˆ¶å¯ä»¥å¾—åˆ°ä¸åŒçš„é€»è¾‘</li></ul></blockquote><ul><li>ä¹Ÿå°±æ˜¯è¯´True valueæ— å…³ï¼Œé€»è¾‘æ˜¯é€šè¿‡transition relationå®ç°çš„</li></ul><h3 id="Reflexivity">3.1. Reflexivity</h3><ul><li>An interpretation $I&#x3D;(S,Ï)$ is reflexive iff $Ï$ is a reflexive <strong>relation</strong>: for all $s \in S$, $(s,s)âˆˆÏ$, or $sâˆˆÏ(s)$ in functional notation.<ul><li>æ”¾åœ¨çŠ¶æ€å›¾ä¸Šå°±æ˜¯ä¸ªè‡ªå·±æŒ‡å‘è‡ªå·±çš„åœˆ</li></ul></li></ul><h3 id="Transitivity">3.2. Transitivity</h3><ul><li>An interpretation with a transitive relation is characterized by the formula $â–¡Aâ†’â–¡â–¡A$ (or by the formula $â—Šâ—ŠAâ†’â—ŠA$)</li><li>In an interpretation that both is reflexive and transitive, $âŠ¨â–¡Aâ†”â–¡â–¡A$ and $âŠ¨â—ŠAâ†”â—Šâ—ŠA$.</li></ul><h3 id="Linearity-çº¿æ€§å…³ç³»">3.3. Linearity çº¿æ€§å…³ç³»</h3><ul><li>An interpretation $I&#x3D;(S,Ï)$  is linear if $Ï$ is a <strong>function</strong>, that is, for all $s \in S$, there is at most one $s^{â€˜} \in S$ such that $s^{â€˜} âˆˆÏ(s)$<ul><li>ä¹Ÿå°±æ˜¯æœ€å°‘æ²¡æœ‰åç»­çŠ¶æ€ï¼Œæœ€å¤šä¸€ä¸ªåç»­çŠ¶æ€</li></ul></li></ul><blockquote><p>It might appear that a linear temporal logic would be limited to expressing properties of <strong>sequential programs</strong> and could not express properties of <strong>concurrent programs</strong>, where each state can have several possible successors depending on the interleaving of the statements of the processes. However, linear temporal logic is successful precisely in the context of concurrent programs because <strong>there is an implicit universal quantification in the definitions</strong></p><p>çœ‹èµ·æ¥çº¿æ€§æ—¶æ€é€»è¾‘ä»…é™äºè¡¨è¾¾<strong>é¡ºåºç¨‹åº</strong>çš„å±æ€§ï¼Œè€Œä¸èƒ½è¡¨è¾¾<strong>å¹¶å‘ç¨‹åº</strong>çš„å±æ€§ï¼Œå› ä¸ºåœ¨å¹¶å‘ç¨‹åºä¸­ï¼Œæ¯ä¸ªçŠ¶æ€å¯ä»¥æœ‰å‡ ä¸ªå¯èƒ½çš„åç»§è€…ï¼Œè¿™å–å†³äºè¿›ç¨‹è¯­å¥çš„äº¤é”™æƒ…å†µã€‚ç„¶è€Œï¼Œçº¿æ€§æ—¶é—´é€»è¾‘æ°æ°åœ¨å¹¶å‘ç¨‹åºçš„èƒŒæ™¯ä¸‹æ˜¯æˆåŠŸçš„ï¼Œå› ä¸ºåœ¨å®šä¹‰ä¸­æœ‰ä¸€ä¸ªéšå«çš„æ™®éé‡åŒ–</p></blockquote><p><strong>example</strong></p><ul><li>a temporal logic formula like $A&#x3D;â–¡â—Šrunning$</li><li><strong>In any state, the execution will eventually reach a state in which the computation is running</strong></li><li>The program will be correct if this formula is <strong>true in every possible execution of the program obtained by interleaving the instructions of its processes</strong>. <ul><li>Each <code>interleaving</code>äº¤é”™ can be considered as a single linear interpretation, so if we prove $\models{_I} A$ for an arbitrary linear interpretation $I$, then the correctness property holds for the program</li></ul></li></ul><h3 id="Discreteness-ç¦»æ•£">3.4. Discreteness ç¦»æ•£</h3><blockquote><p>Although the passage of time is often considered to be continuous and expressible by real numbers, the execution of a program is considered to be <strong>a sequence of discrete steps, where each step consists of the execution of a single instruction of the CPU</strong>. Thus it makes sense to express the concept of the next instant in time. To express discrete steps in temporal logic, an additional operator is added</p><ul><li>è™½ç„¶æ—¶é—´çš„æµé€é€šå¸¸è¢«è®¤ä¸ºæ˜¯è¿ç»­çš„ï¼Œå¯ä»¥ç”¨å®æ•°æ¥è¡¨è¾¾ï¼Œä½†ç¨‹åºçš„æ‰§è¡Œè¢«è®¤ä¸ºæ˜¯ä¸€è¿ä¸²ç¦»æ•£çš„æ­¥éª¤ï¼Œå…¶ä¸­æ¯ä¸€æ­¥éƒ½åŒ…æ‹¬æ‰§è¡ŒCPUçš„ä¸€æ¡æŒ‡ä»¤ã€‚å› æ­¤ï¼Œ<strong>ç”¨æ—¶é—´æ¥è¡¨è¾¾ä¸‹ä¸€ä¸ªç¬é—´çš„æ¦‚å¿µæ˜¯æœ‰æ„ä¹‰çš„</strong>ã€‚ä¸ºäº†åœ¨æ—¶é—´é€»è¾‘ä¸­è¡¨è¾¾ç¦»æ•£çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å¢åŠ äº†ä¸€ä¸ªé¢å¤–çš„æ“ä½œç¬¦</li></ul></blockquote><ul><li>The unary operator $\bigcirc$ is called <strong>next</strong></li><li>truth value<ul><li>f $A$ is $\bigcirc A^{â€˜}$ then $v(A)&#x3D;T$ iff $v(A^{â€˜})&#x3D;T$ for some $s^{â€˜}âˆˆÏ(s)$</li><li><em>æ˜¾ç„¶åé¢çš„çŠ¶æ€æƒ³è¦æ˜¯Té‚£ä¹ˆå‰é¢çš„çŠ¶æ€è‚¯å®šå¾—æ˜¯Tï¼Œä½†åªéœ€è¦<strong>some</strong>å°±è¡Œ</em></li></ul></li><li>æ³¨æ„è¦$\bigcirc A$ä¸ºTï¼Œåªéœ€AæŒ‡å‘çš„stateä¸ºTï¼Œå’Œ$A$æœ¬èº«Tæˆ–Fæ²¡æœ‰å…³ç³»</li></ul><h4 id="self-dual">3.4.1. self-dual</h4><ul><li>$\bigcirc A \leftrightarrow \lnot \bigcirc \lnot A$</li></ul><blockquote><p>The operator $\bigcirc$ plays a crucial role in the theory of temporal logic and in algorithms for deciding properties like satisfiability, but it is rarely used to express properties of programs. In a concurrent program, not much can be said about what happens next since we donâ€™t know which operation will be executed in the next step. Furthermore, we want a correctness statement to hold regardless of how the interleaving selects a next operation. Therefore, properties are almost invariably expressed in terms of always and eventually, not in terms of next.</p><ul><li>è¿ç®—ç¬¦ $\bigcircâ—¯$ åœ¨æ—¶é—´é€»è¾‘ç†è®ºå’Œå†³å®šå¯æ»¡è¶³æ€§ç­‰å±æ€§çš„ç®—æ³•ä¸­èµ·ç€å…³é”®ä½œç”¨ï¼Œä½†å®ƒå¾ˆå°‘è¢«ç”¨æ¥è¡¨è¾¾<strong>ç¨‹åºçš„å±æ€§</strong>ã€‚åœ¨ä¸€ä¸ª<strong>å¹¶å‘ç¨‹åº</strong>ä¸­ï¼Œå¯¹äºä¸‹ä¸€æ­¥ä¼šå‘ç”Ÿä»€ä¹ˆå¹¶æ²¡æœ‰å¤ªå¤šå¯è¯´çš„ï¼Œ<strong>å› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“ä¸‹ä¸€æ­¥ä¼šæ‰§è¡Œå“ªä¸ªæ“ä½œã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¸Œæœ›æ­£ç¡®æ€§å£°æ˜æ€»èƒ½å¤Ÿæˆç«‹â€”â€”ä¸ç®¡äº¤é”™å¦‚ä½•é€‰æ‹©ä¸‹ä¸€ä¸ªæ“ä½œã€‚å› æ­¤ï¼Œ</strong>å±æ€§å‡ ä¹éƒ½æ˜¯ç”¨alwayså’Œeventuallyæ¥è¡¨è¾¾ï¼Œè€Œä¸æ˜¯ç”¨nextæ¥è¡¨è¾¾**ã€‚</li></ul></blockquote><h2 id="LTL">4. LTL</h2><ul><li>In the context of programs, the natural interpretations of temporal logic formulas are discrete, reflexive, transitive and linear. There is another restriction that simplifies the presentation: the transition function must be total so that each state has exactly one next state. An interpretation for a computation that terminates in state s is assumed to have a transition from s to s.<ul><li>åœ¨ç¨‹åºçš„èƒŒæ™¯ä¸‹ï¼Œæ—¶é—´é€»è¾‘å…¬å¼çš„è‡ªç„¶è§£é‡Šæ˜¯<strong>ç¦»æ•£çš„ã€åå°„çš„ã€ä¼ é€’çš„å’Œçº¿æ€§çš„</strong>ã€‚è¿˜æœ‰ä¸€ä¸ªç®€åŒ–è¡¨è¿°çš„é™åˆ¶ï¼šè½¬æ¢å‡½æ•°å¿…é¡»æ˜¯<strong>å®Œå…¨çš„</strong>ï¼Œä»¥ä¾¿æ¯ä¸ªçŠ¶æ€æ­£å¥½æœ‰ä¸€ä¸ªä¸‹ä¸€ä¸ªçŠ¶æ€ <em>ï¼ˆå³<strong>ä¸€ä¸€å¯¹åº”</strong>ï¼‰</em> ã€‚ä¸€ä¸ªç»ˆæ­¢äºçŠ¶æ€sçš„è®¡ç®—çš„è§£é‡Šè¢«å‡å®šä¸ºæœ‰ä¸€ä¸ªä»såˆ°sçš„è¿‡æ¸¡</li></ul></li></ul><hr><ul><li><strong>Linear temporal logic (LTL)</strong> is propositional temporal logic whose interpretations are limited to transitions which are discrete, reflexive, transitive, linear and total.</li><li>Since there is only one transition out of each state, it need not be explicitly represented, so interpretations in LTL are defined to be paths of states<ul><li>ä¹Ÿå°±æ˜¯åŸæ¥çš„çŠ¶æ€è½¬æ¢$Ï:Sâ†’2^{S}$è¢«çœç•¥äº†</li></ul></li></ul><center><img loading="lazy" src="/posts/150c47ae/7.png" width="550"></center><ul><li><p>Let A be a formula in LTL. A is satisfiable iff there is an interpretation Ïƒ for A such that ÏƒâŠ¨A. A is valid iff for all interpretations Ïƒ for A, ÏƒâŠ¨A. Notation: âŠ¨A</p></li><li><p>A formula of the form $\bigcirc A$ or $\lnot \bigcirc A$ is a <strong>next formula</strong>. </p></li><li><p>A formula of the form $â—ŠA$ or $Â¬â€‰â–¡A$ (â€˜eventuallyâ€™ and â€˜not alwaysâ€™) is a <strong>future formula</strong>.</p></li><li><p>any substitution instance of a formula in propositional logic is also an LTL formula</p></li><li><p>The method of semantic tableaux is a decision procedure for satisfiability in LTL</p></li></ul><h2 id="Binary-Temporal-Operators">5. Binary Temporal Operators</h2><ul><li>binary operator $\cap$ (read until)<ul><li>The output lines maintain their values until the set-line is asserted</li><li>If A is $A_1 \cap A_2$ then $v_Ïƒ(A)&#x3D;T$ iff $v_{Ïƒ_{i}}(A_2)&#x3D;T$ for some $iâ‰¥0$ and for all $0â‰¤k&lt;i$,  $v_{Ïƒ_k}(A_1)&#x3D;T$</li></ul></li></ul><p><strong>example</strong></p><ul><li>$p \cap q$ is not true in the following interpretation assuming that state $s$ is repeated indefinitely:</li></ul><center><img loading="lazy" src="/posts/150c47ae/8.gif" width="550"></center><ul><li>The Weak Until Operator<ul><li>Sometimes it is convenient to express precedence properties without actually requiring that something eventually occur. $W$ (read weak until) is the same as the operator except that <strong>it is not required that the second formula ever become true</strong></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Temporal logic is a formal system for reasoning about time. Temporal logic has found extensive application in computer science, because the behavior of both hardware and software is a function of time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Temporal logics are related to formal systems called modal logics. Modal logics express the distinction between what is necessarily true and what is possibly true. For example, the statement â€˜7 is a prime numberâ€™ is necessarily true becauseâ€”given the definitions of the concepts in the statementâ€”the statement is true always and everywhere. In contrast, the statement the head of state of this country is a king is possibly true, because its truth changes from place to place and from time to time. Temporal logic and modal logic are related because â€˜alwaysâ€™ is similar to â€˜necessarilyâ€™ and â€˜eventuallyâ€™ to â€˜possiblyâ€™.&lt;/p&gt;
&lt;p&gt;æ—¶é—´é€»è¾‘ä¸ç§°ä¸ºæ¨¡æ€é€»è¾‘çš„å½¢å¼ç³»ç»Ÿæœ‰å…³ã€‚æ¨¡æ€é€»è¾‘è¡¨è¾¾äº†ä»€ä¹ˆæ˜¯å¿…ç„¶çœŸå®å’Œä»€ä¹ˆæ˜¯å¯èƒ½çœŸå®ä¹‹é—´çš„åŒºåˆ«ã€‚ä¾‹å¦‚ï¼Œâ€7æ˜¯è´¨æ•° â€œè¿™ä¸ªé™ˆè¿°å¿…ç„¶æ˜¯çœŸå®çš„ï¼Œå› ä¸ºâ€“è€ƒè™‘åˆ°é™ˆè¿°ä¸­æ¦‚å¿µçš„å®šä¹‰â€“è¿™ä¸ªé™ˆè¿°æ€»æ˜¯çœŸå®çš„ï¼Œè€Œä¸”æ— å¤„ä¸åœ¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™ä¸ªå›½å®¶çš„å›½å®¶å…ƒé¦–æ˜¯å›½ç‹çš„è¯´æ³•å¯èƒ½æ˜¯çœŸçš„ï¼Œå› ä¸ºå®ƒçš„çœŸç†åœ¨ä¸åŒçš„åœ°æ–¹å’Œä¸åŒçš„æ—¶é—´ä¼šå‘ç”Ÿå˜åŒ–ã€‚æ—¶é—´é€»è¾‘å’Œæ¨¡æ€é€»è¾‘æ˜¯ç›¸å…³çš„ï¼Œå› ä¸º â€œæ€»æ˜¯ â€œç±»ä¼¼äº â€œå¿…ç„¶â€ï¼Œâ€æœ€ç»ˆ â€œç±»ä¼¼äº â€œå¯èƒ½â€ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;æ—¶é—´é€»è¾‘ä¸æ¨¡æ€é€»è¾‘ç›¸ä¼¼ï¼Œåªæ˜¯&lt;strong&gt;çŠ¶æ€&lt;/strong&gt;è¢«è®¤ä¸ºæ˜¯æŒ‡å®šåœ¨æŸä¸€ç‰¹å®šæ—¶é—´ç‚¹ä¸Šçš„çœŸå®æƒ…å†µï¼Œè€Œ&lt;strong&gt;è½¬æ¢&lt;/strong&gt;åˆ™å®šä¹‰äº†æ—¶é—´çš„æµé€&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;PTL&quot;&gt;2. PTL&lt;/h2&gt;&lt;h3 id=&quot;Syntax&quot;&gt;2.1. Syntax&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The syntax of propositional temporal logic (PTL) is defined like the syntax of propositional logic, &lt;strong&gt;except for the addition of two additional unary operators&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;â–¡&lt;/code&gt; , read always&lt;/li&gt;
&lt;li&gt;&lt;code&gt;â—Š&lt;/code&gt; , read eventually&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$(Â¬â€‰â—Šp)âˆ§(â–¡Â¬â€‰q)$&lt;ul&gt;
&lt;li&gt;the temporal operators and negation have higher precedenceä¼˜å…ˆæƒ than the conjunction operator&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;semantic&quot;&gt;2.2. semantic&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Informally, â–¡ is a universal operator meaning â€˜&lt;strong&gt;for any time t in the future&lt;/strong&gt;â€™, while â—Š is an existential operator meaning â€˜&lt;strong&gt;for some time t in the future&lt;/strong&gt;â€™&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;transition-diagram-çŠ¶æ€è½¬æ¢å›¾&quot;&gt;2.3. transition diagram çŠ¶æ€è½¬æ¢å›¾&lt;/h3&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ç¨‹åºéªŒè¯-å¹¶å‘ç¨‹åº</title>
    <link href="https://hejueyun.github.io/posts/cf619a86/"/>
    <id>https://hejueyun.github.io/posts/cf619a86/</id>
    <published>2022-02-23T01:15:37.000Z</published>
    <updated>2022-04-01T11:49:22.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Verification is routinely used when developing computer hardware and concurrent programs. A sequential program can always be tested and retested, but the nondeterministic nature of hardware and concurrent programs limits the effectiveness of testing as a method to demonstrate that the system is correct. Slight variations in timing, perhaps caused by congestion on a network, mean that two executions of the same program might give different results. Even if a bug is found by testing and then fixed, we have no way of knowing if the next test runs correctly because we fixed the bug or because the execution followed a different scenario, one in which the bug cannot occur.</p><p>åœ¨å¼€å‘è®¡ç®—æœºç¡¬ä»¶å’Œå¹¶å‘ç¨‹åºæ—¶ï¼Œç»å¸¸ä¼šç”¨åˆ°éªŒè¯ã€‚ä¸€ä¸ªé¡ºåºç¨‹åºæ€»æ˜¯å¯ä»¥è¢«æµ‹è¯•å’Œé‡æ–°æµ‹è¯•ï¼Œä½†ç¡¬ä»¶å’Œå¹¶å‘ç¨‹åºçš„éç¡®å®šæ€§é™åˆ¶äº†æµ‹è¯•ä½œä¸ºè¯æ˜ç³»ç»Ÿæ­£ç¡®çš„æ–¹æ³•çš„æœ‰æ•ˆæ€§ã€‚<strong>æ—¶é—´ä¸Šçš„å¾®å°å˜åŒ–ï¼Œä¹Ÿè®¸æ˜¯ç”±ç½‘ç»œä¸Šçš„æ‹¥å µé€ æˆçš„ï¼Œæ„å‘³ç€åŒä¸€ä¸ªç¨‹åºçš„ä¸¤æ¬¡æ‰§è¡Œå¯èƒ½ä¼šå¾—åˆ°ä¸åŒçš„ç»“æœã€‚å³ä½¿é€šè¿‡æµ‹è¯•å‘ç°äº†ä¸€ä¸ªé”™è¯¯ï¼Œç„¶åè¿›è¡Œäº†ä¿®å¤ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰åŠæ³•çŸ¥é“ä¸‹ä¸€æ¬¡æµ‹è¯•çš„æ­£ç¡®è¿è¡Œæ˜¯å› ä¸ºæˆ‘ä»¬ä¿®å¤äº†è¿™ä¸ªé”™è¯¯ï¼Œè¿˜æ˜¯å› ä¸ºæ‰§è¡Œäº†ä¸€ä¸ªä¸åŒçš„åœºæ™¯ï¼Œåœ¨è¿™ä¸ªåœºæ™¯ä¸­ï¼Œè¿™ä¸ªé”™è¯¯ä¸ä¼šå‘ç”Ÿ</strong></p></blockquote><ul><li>é¡ºåºç¨‹åºçš„éªŒè¯è²Œä¼¼æ²¡æœ‰ç”¨åˆ°æ—¶æ€é€»è¾‘</li></ul><h2 id="Concurrent-Program-å¹¶å‘ç¨‹åº">1. Concurrent Program å¹¶å‘ç¨‹åº</h2><ul><li>A <strong>concurrent program</strong> is a set of <strong>sequential programs</strong> together with a set of <strong>global variables</strong></li><li>A concurrent program is a set of <code>processes</code> ${ p_1,p_2,â€¦,p_n }$, where each <strong>process</strong> is a <strong>sequential program</strong><ul><li><strong>Processes</strong> are also known as <strong>threads</strong>; in some contexts, the two terms have different meanings but the difference is not relevant here<ul><li>è¿›ç¨‹ä¸çº¿ç¨‹åœ¨æ­¤å¤„æ— éœ€åŒºåˆ«</li></ul></li></ul></li><li>The variables declared in each process are its <code>local variables</code>; a local variable can be read and written only by the process where it is declared.</li><li>There may be <code>global variables</code> that can be read and written by all of the processes.</li></ul><h3 id="state-çŠ¶æ€">1.1. state çŠ¶æ€</h3><ul><li>The state of a concurrent programs consists of <ul><li><strong>the values of its variables</strong> (both local and global),</li><li>together with the <strong>location counters</strong> of its processes.</li></ul></li></ul><center><img loading="lazy" src="/posts/cf619a86/2.png" width="550"></center><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/cf619a86/3.gif" width="350"></center><blockquote><p>There are $5Ã—3Ã—3&#x3D;45$ different states, because the variable n can have the values $0, 1, 2, 3, 4$ and there are <strong>three</strong> labels for <strong>each</strong> process. </p><ul><li>These seems like quite a large number of states for such a simple program, but many of the states (for example, (0,end,end)) will never occur in any computation.</li></ul></blockquote><ul><li>possible computations:</li></ul><center><img loading="lazy" src="/posts/cf619a86/4.gif" width="350"></center><h3 id="Interleaving-äº¤é”™">1.2. Interleaving äº¤é”™</h3><ul><li>A computation of a concurrent program is obtained by asynchronous interleaving of atomic instructions<ul><li>å¹¶å‘ç¨‹åºçš„è®¡ç®—æ˜¯é€šè¿‡åŸå­æŒ‡ä»¤çš„å¼‚æ­¥äº¤é”™å¾—åˆ°çš„</li></ul></li><li>Each statement is executed to completion before the execution of another statement (from the same process or another process) is started<ul><li>these statements are <strong>atomic operations</strong></li></ul></li></ul><center><img loading="lazy" src="/posts/cf619a86/5.png" width="550"></center><center><img loading="lazy" src="/posts/cf619a86/6.png" width="550"></center><h2 id="Formalization-of-Correctness">2. Formalization of Correctness</h2><ul><li><strong>Correctness properties</strong> of concurrent programs can be expressed in <strong>linear temporal logic</strong>. </li><li>There are two types of properties: <ul><li>safety properties that require that <strong>something bad never happens</strong> </li><li>livenessæ´»æ³¼ properties that require that <strong>something good eventually happen</strong>.</li></ul></li></ul><hr><ul><li>Each process consists of a <code>critical section</code> and a <code>non-critical section</code>. <ul><li>A process may stay indefinitely in its non-critical section, orâ€”at any timeâ€”it may request to enter its critical section. </li><li>A process that has entered its critical section will eventually leave it</li><li><strong>Mutual exclusion</strong>: It is forbidden for the two processes to be in their critical sections simultaneously.</li><li><strong>Liveness</strong>: If a process attempts to enter its critical section, it will eventually succeed</li></ul></li></ul><h3 id="Petersonâ€™s-algorithm-å½¼å¾—æ£®ç®—æ³•">2.1. Petersonâ€™s algorithm å½¼å¾—æ£®ç®—æ³•</h3><center><img loading="lazy" src="/posts/cf619a86/8.png" width="500"></center><center><img loading="lazy" src="/posts/cf619a86/13.gif" width="500"></center><ul><li>The statement: <code>wait until (!wantq or turn == 2)</code> is a more intuitive way of writing:<ul><li><code>while (!(!wantq or turn == 2)) /* do nothing */</code></li></ul></li><li>The variables <code>wantp</code> and <code>wantq</code> are set to <strong>true</strong> by the processes to indicate that they are trying to enter their critical sections and reset to <strong>false</strong> when they leave their critical sections. </li><li>A trying-process <strong>waits</strong> until the other process is neither trying to enter its critical section nor is it in its critical section (<code>!wantq</code> or <code>!wantp</code>). Since the algorithm is <strong>symmetric</strong>, the variable turn is used to break ties when both processes are trying to enter their critical sections. </li><li>A tie is broken in favor of the first process which set turn. Suppose that process p set turn to 1 and then process q set turn to 2. The expression <code>turn==2</code> will be true and allow process p to enter its critical section.</li></ul><hr><center><img loading="lazy" src="/posts/cf619a86/24.gif" width="450"></center><ul><li>The following two LTL formulas express the correctness of Petersonâ€™s algorithm for the critical section problem:</li></ul><center><img loading="lazy" src="/posts/cf619a86/7.gif" width="350"></center><ul><li>cs &#x3D; critical section</li></ul><blockquote><ul><li>Mutual exclusion forbids (always false) a computation from including a state where both processes are in their critical section, </li><li>while liveness requires that (always) if a computation includes a state where a process is trying to enter its critical section then (eventually) the computation will include a state where the process is in its critical section.</li></ul></blockquote><h3 id="progress-axioms">2.2. progress axioms</h3><center><img loading="lazy" src="/posts/cf619a86/9.gif" width="350"></center><center><img loading="lazy" src="/posts/cf619a86/23.png" width="550"></center><h3 id="Invariants-ä¸å˜é‡">2.3. Invariants ä¸å˜é‡</h3><ul><li>$r$ is invariant, meaning that $r$ is true initially and remains true in any interpretation</li><li>deduction rule:</li></ul><center><img loading="lazy" src="/posts/cf619a86/14.png" width="350"></center><h2 id="Programs-as-Automata-â€“-model-checking">3. Programs as Automata â€“ model checking</h2><ul><li>There is a different approach to the verification of the correctness of a program: <strong>generate all possible computations</strong>ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è®¡ç®— and check that the correctness property holds for each of them. Of course, <strong>this is possible only if there are a finite number of states so that each computation is finite or finitely presented</strong>. æ‰€åŸºäºçš„å‡è®¾<ul><li>For the program for integer square rootæ•´æ•°å¹³æ–¹æ ¹çš„ç¨‹åº, we could prove its correctness this way for any <strong>specific</strong> value of a, but we could not prove it in <strong>general</strong> for all values of a. </li><li>However, many concurrent algorithms have a finite number of states</li></ul></li><li>This approach to verification is called <code>model checking</code>. <ul><li>A concurrent system is represented by an abstract finite model that ignores details of the computation</li><li>a <strong>correctness property</strong> is expressed as a <strong>formula</strong> (usually in temporal logic) and we wish to show that the <strong>program</strong> is a <strong>modelè§£</strong> of the <strong>formula</strong>, that is, an interpretation in which the formula is true</li></ul></li></ul><h3 id="Modeling-Concurrent-Programs-as-Automata">3.1. Modeling Concurrent Programs as Automata</h3><ul><li><p>Concurrent programs can be modeled as <strong>finite automata</strong>æœ‰é™è‡ªåŠ¨æœº</p><ul><li>Each <strong>value of the location counter</strong> is a <strong>state</strong> of one of the automata</li><li>while each <strong>transition</strong> is labeled with the <strong>Boolean condition</strong> that enables it to be taken or with the <strong>assignment statements</strong> that change the values of the variables.</li></ul></li><li><p>ç›¸æ¯”ä¹‹ä¸‹ï¼Œé¡ºåºç¨‹åºçš„correctnessæ˜¯é€šè¿‡ <strong>inductive expressions</strong> ${ p }S{ q }$æ¥è¡¨ç¤ºçš„</p></li><li><p>The abbreviatedç®€ç•¥çš„ version of Petersonâ€™s algorithm</p></li></ul><center><img loading="lazy" src="/posts/cf619a86/10.gif" width="350"></center><ul><li>The <strong>automata</strong> for the individual processes do not define the entire concurrent program. We must combine these automata into one <strong>automaton</strong>(automataçš„å¤æ•°å½¢å¼)</li><li>The states are defined as the Cartesian product of the states of the automata for the individual processes.</li></ul><center><img loading="lazy" src="/posts/cf619a86/11.png" width="550"></center><h3 id="The-State-Space-çŠ¶æ€ç©ºé—´">3.2. The State Space çŠ¶æ€ç©ºé—´</h3><blockquote><p>The <strong>reachable states</strong> of a concurrent program are the states that can actually occur in a computation. The state space of the program is a directed graph: </p><ul><li>each reachable state is a <strong>node</strong> </li><li>and there is an <strong>edge</strong> from state $s_1$ to state $s_2$ if some transition of the program which is enabled in $s_1$ moves the state of the computation to $s_2$.</li></ul><p>â€ƒ</p></blockquote><ul><li>State space for Petersonâ€™s algorithm</li></ul><center><img loading="lazy" src="/posts/cf619a86/12.gif" width="450"></center><h2 id="Model-Checking-of-Invariance-Properties">4. Model Checking of Invariance Properties</h2><blockquote><p>We now consider the second meaning of the term model: Is the state space a <strong>model</strong> of a correctness property? Consider the <strong>correctness property</strong> for mutual exclusion in Petersonâ€™s algorithm $A&#x3D;â–¡Â¬â€‰(cspâˆ§csq)$ . Since the state spacerepresents all the reachable states and all the transitions between them, any interpretation for $A$ must be an infinite path in this directed graph. A quick inspection of the graph shows that all of the ten reachable states satisfy the formula $Â¬â€‰(cspâˆ§csq)$; therefore, for any interpretation (that is, for any path constructed from these states), $â–¡Â¬â€‰(cspâˆ§csq)$ is true.</p><hr><p>Once we have written the program and the correctness property, there are <strong>algorithms</strong> to perform the rest of the proof: </p><ul><li>compile the program to a set of automata</li><li>construct the product automaton</li><li>generate the state space </li><li>check the truth of the formula expressing the correctness property at each state.</li></ul></blockquote><h3 id="Algorithms-for-Searching-the-State-Space">4.1. Algorithms for Searching the State Space</h3><ul><li>breadth-first search (BFS)</li><li>depth-first search (DFS)</li></ul><h2 id="Model-Checking-of-Liveness-Properties">5. Model Checking of Liveness Properties</h2><ul><li>Using negation, we have: the correctness property does not hold iff there exists a computation is which Â¬â€‰A is true, where: <ul><li>$\lnot A \equiv \lnot â–¡ \lnot (csp \land csq) \equiv â—Š (csp \land csq)$</li></ul></li><li>The model checking algorithm â€˜succeedsâ€™ if it finds a computation where Â¬â€‰A is true; it succeeds by finding a <code>counterexample</code> proving that the program is incorrect.</li></ul><center><img loading="lazy" src="/posts/cf619a86/15.gif" width="450"></center><ul><li>The states on the stack of a depth first search form a <code>path</code>. If the construction ever tries to generate a state that already exists higher up on the stack, the transition to this node defines a finitely-presented infinite computation like the ones shown above.</li><li>we could generate the entire state space and then check each distinct path to see if it model, but it is more efficient if the checking can be done on-the-flyå³æ—¶å®Œæˆ as we did for safety properties. <strong>The key is to transform an LTL formula into an automaton whose computations can be generated at the same time as those of the program.</strong></li></ul><h2 id="Expressing-an-LTL-Formula-as-an-Automaton">6. Expressing an LTL Formula as an Automaton</h2><ul><li>An LTL formula can be algorithmically transformed into an automaton that accepts an input if and only if <strong>the input represents a computation that satisfies the LTL formula</strong>.</li><li>The automaton is a non-deterministic BÃ¼chi automaton (NBA), which is the same as a non-deterministic finite automaton (NFA) <strong>except that it reads an infinite string</strong> as its input and its definition of acceptance is changed accordingly</li><li>åœ¨è®¡ç®—ç†è®ºä¸­ï¼Œ<strong>éç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœº</strong>æˆ–<strong>éç¡®å®šæœ‰é™è‡ªåŠ¨æœº</strong>æ˜¯å¯¹æ¯ä¸ªçŠ¶æ€å’Œè¾“å…¥ç¬¦å·å¯¹å¯ä»¥æœ‰å¤šä¸ªå¯èƒ½çš„ä¸‹ä¸€ä¸ªçŠ¶æ€çš„æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºã€‚è¿™åŒºåˆ«äºç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼Œå®ƒçš„ä¸‹ä¸€ä¸ªå¯èƒ½çŠ¶æ€æ˜¯å”¯ä¸€ç¡®å®šçš„</li></ul><center><img loading="lazy" src="/posts/cf619a86/16.gif" width="450"></center><ul><li>the negation of the liveness formula <ul><li>$\lnot â–¡A â‰¡ \not â–¡(waitpâ†’â—Šcsp) â‰¡ â—Š(waitp \land â–¡ \not csp)$</li></ul></li><li>The intuitive meaning of the formula is that the computation can do anything (expressed as true), but it may nondeterministically decide to enter a state where waitp is true and csp is and remains false from then on. Such a computation falsifies the liveness property.</li><li>In state $s_1$, if csp ever becomes true, there is no transition from the state; as with NFA, <strong>an automaton that cannot continue with its computation is considered to have rejected its input</strong></li></ul><h2 id="Model-Checking-Using-the-Synchronous-Automaton">7. Model Checking Using the Synchronous Automaton</h2><blockquote><p>On-the-fly model checking for an invariance property simply evaluates the correctness property as each new state is generated</p></blockquote><center><img loading="lazy" src="/posts/cf619a86/17.gif" width="450"></center><blockquote><p>When checking a <strong>liveness property</strong> (or a <strong>safety property</strong> expressed in LTL as $â–¡A$), every step of the program automatonâ€”the asynchronous product automaton of the processesâ€”is immediately followed by a step of the NBA corresponding to the LTL formula expressing the negation of the correctness property. The product of the asynchronous automaton and the NBA is called a <strong>synchronous automaton</strong> since the steps of the two automata are synchronized. </p></blockquote><center><img loading="lazy" src="/posts/cf619a86/18.gif" width="450"></center><h3 id="Model-checking-the-liveness-of-Petersonâ€™s-algorithm">7.1. Model checking the liveness of Petersonâ€™s algorithm</h3><center><img loading="lazy" src="/posts/cf619a86/19.gif" width="450"></center><ul><li>Starting from the initial state 1, state 2 is reached and $â—Š(waitpâˆ§â–¡Â¬â€‰csp)$ will be true, provided that we can find a reachable MSCCï¼ˆå¼ºè¿é€šåˆ†é‡ï¼ŒStrongly connected componentï¼‰where $Â¬â€‰csp$ holds in all its states.</li><li>A nested DFS is initiated. Clearly, states 4 and 8 cannot be part of the MSCC since Â¬â€‰csp is false in those states</li><li>the computation can continue: $1,2,5,5,â€¦$ and the state 5 with its self-loop forms an MSCC such that $Â¬â€‰csp$ is false in all its states<ul><li><strong>rejected</strong></li></ul></li><li>Continuing the DFS, we encounter two more states 6 and 9 where waitp is true. We leave it as an exercise to show that the nested DFS will find computations in which Â¬â€‰csp holds in all states, but that these computations are also unfair. Therefore, the liveness holds for Petersonâ€™s algorithm</li></ul><h3 id="Fair">7.2. Fair</h3><ul><li>A computation is (weakly) fair if a transition that is always <strong>enabled</strong> is eventually executed in the computation.</li><li>The statement wait <code>until (!wantq or turn == 2)</code> is always <strong>enabled</strong> because <code>turn=2</code>, but it is never taken. Therefore, we reject this counterexample</li></ul><h2 id="Branching-Time-Temporal-Logic">8. Branching-Time Temporal Logic</h2><p>. </p><h2 id="Symbolic-Model-Checking-ç¬¦å·æ¨¡å‹æ£€éªŒ">9. Symbolic Model Checking ç¬¦å·æ¨¡å‹æ£€éªŒ</h2><ul><li>In symbolic model checking, the <strong>states</strong> and <strong>transitions</strong> are not represented explicitly; instead, they are encoded as formulas in <strong>propositional logic</strong><ul><li>åœ¨ç¬¦å·æ¨¡å‹æ£€æŸ¥ä¸­ï¼ŒçŠ¶æ€å’Œè½¬æ¢æ²¡æœ‰æ˜ç¡®è¡¨ç¤ºï¼›ç›¸åï¼Œå®ƒä»¬è¢«ç¼–ç ä¸ºå‘½é¢˜é€»è¾‘çš„å…¬å¼</li></ul></li></ul><p><strong>exampl</strong></p><ul><li><p>A state in the state space of Petersonâ€™s algorithm can be represented as a propositional formula using five atomic propositions. </p><ul><li>There are <strong>three</strong> locations in each process, so <strong>two</strong> bits for each process can represent these values ${p_0,p_1,q_0,q_1}$</li></ul><center><img loading="lazy" src="/posts/cf619a86/20.png" width="450"></center><ul><li>The variable turn can take <strong>two</strong> values so <strong>one</strong> bit is sufficient. The atomic proposition t will encode turn: <strong>true</strong> for turn&#x3D;1 and <strong>false</strong> for turn&#x3D;2</li></ul></li><li><p>The initial state of the state space is encoded by the formula:</p><ul><li>$p_0 \land p_1 \land q_0 \land q_1 \land t$</li></ul></li><li><p>To encode the transitions, we need another set of atomic propositions: </p><ul><li>the original set will encode the state <strong>before</strong> the transition </li><li>and the new set (denoted by primes) will encode the <strong>state</strong> after the transition</li></ul></li><li><p>The encoding of the transition from $s_5&#x3D;(waitp,waitq,2)$ to $s_8$ is given by the formula:</p><center><img loading="lazy" src="/posts/cf619a86/21.gif" width="350"></center></li><li><p>There are two ways of proceeding from here</p><ul><li>One is to encode the formulas using <strong>BDDs</strong><ul><li>The algorithms on BDDs can be used to compute the formulas corresponding to new sets of states: union, predecessor, and so on</li></ul></li><li>The other approach to <strong>symbolic model checking</strong> is called <strong>bounded model checking</strong>. <ul><li>Recall that a formula in temporal logic has the finite model property: if a formula is satisfiable then it is satisfied in a finitely-presented model. For an LTL formula, we showed that a model consists of MSCCs that are reachable from the initial state. In fact, by unwindingè§£å¼€ the MSCCs, we can always find a model that consists of a single cycle reachable from the initial state </li><li>In bounded model checking, a maximum size $k$ for the model is guessed. The <strong>behavior of the program</strong> and the <strong>negation of a correctness property</strong> are expressed as a <strong>propositional formula</strong> obtained by encoding each state that can appear at distance $i$ from the initial state $0â‰¤iâ‰¤k$. This formula is the input to a <strong>SAT solver</strong>; if a satisfying interpretation is found, then there is a computation that satisfies the negation of the correctness property is true and the program is not correct.</li></ul></li></ul></li></ul><h3 id="BDD">9.1. BDD</h3><p>( äºŒå…ƒå†³ç­–å›¾ Binary decision diagram)</p><blockquote><p>A binary decision diagram (BDD) is a data structure for representing the semantics of a formula in propositional logic. A formula is represented by a directed graph and an algorithm is used to reduce the graph.</p></blockquote><hr><blockquote><p>A Boolean function can be represented as a rooted, directed, acyclic graph, which consists of several (<strong>decision</strong>) nodes and two <strong>terminal</strong> nodes. The two terminal nodes are labeled 0 (FALSE) and 1 (TRUE). Each (decision) node ${\displaystyle u}$ is labeled by a Boolean variable ${\displaystyle x_{i}}$ and has two child nodes called <strong>low child</strong> and <strong>high child</strong>. The edge from node ${\displaystyle u}$ to a low (or high) child represents an assignment of the value FALSE (or TRUE, respectively) to variable ${\displaystyle x_{i}}$. Such a BDD is called â€˜orderedâ€™ if different variables appear in the same order on all paths from the root. A BDD is said to be â€˜<strong>reduced</strong>â€˜ if the following two rules have been applied to its graph:</p><ul><li>Merge any isomorphic subgraphs.</li><li>Eliminate any node whose two children are isomorphic.</li></ul></blockquote><ul><li>In the figures below, <strong>dotted</strong> lines represent edges to a <strong>low</strong> child, while <strong>solid</strong> lines represent edges to a <strong>high</strong> child.<ul><li>For function ${\displaystyle f(x1,x2,x3)}$, to find ${\displaystyle f(0,1,1)}$, begin at x1, traverse down the dotted line to x2 (since x1 has an assignment to 0), then down two solid lines (since x2 and x3 each have an assignment to one). This leads to the terminal 1, which is the value of ${\displaystyle f(0,1,1)}$</li></ul></li><li>The <strong>binary decision tree</strong> of the left figure can be transformed into a <strong>binary decision diagram</strong> by maximally reducing it according to the two reduction rules. The resulting BDD is shown in the right figure.</li></ul><center><img loading="lazy" src="/posts/cf619a86/22.png" width="550"></center>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Verification is routinely used when developing computer hardware and concurrent programs. A sequential program can always be tested and retested, but the nondeterministic nature of hardware and concurrent programs limits the effectiveness of testing as a method to demonstrate that the system is correct. Slight variations in timing, perhaps caused by congestion on a network, mean that two executions of the same program might give different results. Even if a bug is found by testing and then fixed, we have no way of knowing if the next test runs correctly because we fixed the bug or because the execution followed a different scenario, one in which the bug cannot occur.&lt;/p&gt;
&lt;p&gt;åœ¨å¼€å‘è®¡ç®—æœºç¡¬ä»¶å’Œå¹¶å‘ç¨‹åºæ—¶ï¼Œç»å¸¸ä¼šç”¨åˆ°éªŒè¯ã€‚ä¸€ä¸ªé¡ºåºç¨‹åºæ€»æ˜¯å¯ä»¥è¢«æµ‹è¯•å’Œé‡æ–°æµ‹è¯•ï¼Œä½†ç¡¬ä»¶å’Œå¹¶å‘ç¨‹åºçš„éç¡®å®šæ€§é™åˆ¶äº†æµ‹è¯•ä½œä¸ºè¯æ˜ç³»ç»Ÿæ­£ç¡®çš„æ–¹æ³•çš„æœ‰æ•ˆæ€§ã€‚&lt;strong&gt;æ—¶é—´ä¸Šçš„å¾®å°å˜åŒ–ï¼Œä¹Ÿè®¸æ˜¯ç”±ç½‘ç»œä¸Šçš„æ‹¥å µé€ æˆçš„ï¼Œæ„å‘³ç€åŒä¸€ä¸ªç¨‹åºçš„ä¸¤æ¬¡æ‰§è¡Œå¯èƒ½ä¼šå¾—åˆ°ä¸åŒçš„ç»“æœã€‚å³ä½¿é€šè¿‡æµ‹è¯•å‘ç°äº†ä¸€ä¸ªé”™è¯¯ï¼Œç„¶åè¿›è¡Œäº†ä¿®å¤ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰åŠæ³•çŸ¥é“ä¸‹ä¸€æ¬¡æµ‹è¯•çš„æ­£ç¡®è¿è¡Œæ˜¯å› ä¸ºæˆ‘ä»¬ä¿®å¤äº†è¿™ä¸ªé”™è¯¯ï¼Œè¿˜æ˜¯å› ä¸ºæ‰§è¡Œäº†ä¸€ä¸ªä¸åŒçš„åœºæ™¯ï¼Œåœ¨è¿™ä¸ªåœºæ™¯ä¸­ï¼Œè¿™ä¸ªé”™è¯¯ä¸ä¼šå‘ç”Ÿ&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;é¡ºåºç¨‹åºçš„éªŒè¯è²Œä¼¼æ²¡æœ‰ç”¨åˆ°æ—¶æ€é€»è¾‘&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Concurrent-Program-å¹¶å‘ç¨‹åº&quot;&gt;1. Concurrent Program å¹¶å‘ç¨‹åº&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;concurrent program&lt;/strong&gt; is a set of &lt;strong&gt;sequential programs&lt;/strong&gt; together with a set of &lt;strong&gt;global variables&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A concurrent program is a set of &lt;code&gt;processes&lt;/code&gt; ${ p_1,p_2,â€¦,p_n }$, where each &lt;strong&gt;process&lt;/strong&gt; is a &lt;strong&gt;sequential program&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Processes&lt;/strong&gt; are also known as &lt;strong&gt;threads&lt;/strong&gt;; in some contexts, the two terms have different meanings but the difference is not relevant here&lt;ul&gt;
&lt;li&gt;è¿›ç¨‹ä¸çº¿ç¨‹åœ¨æ­¤å¤„æ— éœ€åŒºåˆ«&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The variables declared in each process are its &lt;code&gt;local variables&lt;/code&gt;; a local variable can be read and written only by the process where it is declared.&lt;/li&gt;
&lt;li&gt;There may be &lt;code&gt;global variables&lt;/code&gt; that can be read and written by all of the processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;state-çŠ¶æ€&quot;&gt;1.1. state çŠ¶æ€&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The state of a concurrent programs consists of &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;the values of its variables&lt;/strong&gt; (both local and global),&lt;/li&gt;
&lt;li&gt;together with the &lt;strong&gt;location counters&lt;/strong&gt; of its processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cf619a86/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cf619a86/3.gif&quot; width=&quot;350&quot;&gt;&lt;/center&gt;

&lt;blockquote&gt;
&lt;p&gt;There are $5Ã—3Ã—3&amp;#x3D;45$ different states, because the variable n can have the values $0, 1, 2, 3, 4$ and there are &lt;strong&gt;three&lt;/strong&gt; labels for &lt;strong&gt;each&lt;/strong&gt; process. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These seems like quite a large number of states for such a simple program, but many of the states (for example, (0,end,end)) will never occur in any computation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ç¨‹åºéªŒè¯-é¡ºåºç¨‹åº</title>
    <link href="https://hejueyun.github.io/posts/ab706956/"/>
    <id>https://hejueyun.github.io/posts/ab706956/</id>
    <published>2022-02-23T01:15:14.000Z</published>
    <updated>2022-03-28T19:38:48.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Program">1. Program</h2><blockquote><p>A <strong>computer program</strong> is not very different from a logical formula. It consists of a sequence of <strong>symbols</strong> constructed according to <strong>formal syntactical rules</strong> and it has a meaning which is assigned by an <strong>interpretation</strong> of the elements of the language. In programming, the symbols are called <strong>statements or commands</strong> and the intended interpretation is the <strong>execution</strong> of the program on a computer. The syntax of programming languages is specified using formal systems such as BNF, but the semantics is usually informally specified.</p><p>ä¸€ä¸ªè®¡ç®—æœºç¨‹åºä¸ä¸€ä¸ªé€»è¾‘å…¬å¼æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚å®ƒç”±ä¸€è¿ä¸²çš„ç¬¦å·ç»„æˆï¼Œè¿™äº›ç¬¦å·æ˜¯æ ¹æ®æ­£å¼çš„å¥æ³•è§„åˆ™æ„å»ºçš„ï¼Œå®ƒæœ‰ä¸€ä¸ªæ„ä¹‰ï¼Œè¿™ä¸ªæ„ä¹‰æ˜¯é€šè¿‡å¯¹è¯­è¨€å…ƒç´ çš„è§£é‡Šè€Œèµ‹äºˆçš„ã€‚åœ¨ç¼–ç¨‹ä¸­ï¼Œè¿™äº›ç¬¦å·è¢«ç§°ä¸ºè¯­å¥æˆ–å‘½ä»¤ï¼Œé¢„æœŸçš„è§£é‡Šæ˜¯ç¨‹åºåœ¨è®¡ç®—æœºä¸Šçš„æ‰§è¡Œã€‚<strong>ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•æ˜¯ç”¨BNFè¿™æ ·çš„å½¢å¼åŒ–ç³»ç»ŸæŒ‡å®šçš„ï¼Œä½†è¯­ä¹‰é€šå¸¸æ˜¯éæ­£å¼åœ°æŒ‡å®šçš„</strong></p></blockquote><h3 id="è€ƒè™‘ä¸€é—¨è¯­è¨€çš„è®¾è®¡">1.1. è€ƒè™‘ä¸€é—¨è¯­è¨€çš„è®¾è®¡</h3><ul><li>A program is a <strong>statement</strong> S, where statements are defined recursively using the concepts of variables and expressions<ul><li>ç¨‹åºæœ¬èº«å°±æ˜¯ä¸€ä¸ªæŠ½è±¡çš„å¤§statement</li></ul></li></ul><center><img loading="lazy" src="/posts/ab706956/6.gif" width="550"></center><ul><li>A <strong>statement</strong> in a programming language can be considered to be a function that transforms the state of a computation<ul><li>ç¼–ç¨‹è¯­è¨€å¯ä»¥è¢«è§†ä½œçŠ¶æ€è½¬æ¢å‡½æ•°</li></ul></li></ul><blockquote><p>Let $S$ be a <strong>program</strong> with $n$ <strong>variables</strong> $(x1,â€¦,xn)$. A <strong>state</strong> $s$ of $S$ consists of an $n+1$-tuple of values $(lc,x_1,â€¦,x_n )$, where $lc$ is the value of the <strong>location counter</strong>(sometimes called the <strong>instruction pointer</strong>ï¼Œå­˜å‚¨ä¸‹ä¸€ä¸ªæŒ‡ä»¤çš„åœ°å€)  and $x_i$ is the value of the variable $xi$.</p></blockquote><ul><li><strong>we aim to verify the program by proving: if the input to the program satisfies the precondition, then the output of the program will satisfy the postcondition</strong></li></ul><p><strong>example</strong></p><ul><li>If the variables (x,y) have the values (8,7) in a state, then the result of executing the statement x &#x3D; 2*y+1 is the state in which (x,y)&#x3D;(15,7) and the location counter is incremented</li></ul><h2 id="Correctness-Formulas">2. Correctness Formulas</h2><ul><li><p>A <strong>correctness formula</strong> is a triple ${ p } S { q }$ , where $S$ is a program, and $p$ and $q$ are formulas called the precondition and postcondition, respectively. S is <strong>partially correct</strong> with respect to p and qï¼Œ$âŠ§ { p } S { q }$,iff</p><ul><li>If $S$ is started in a state where $p$ is true and if the computation of $S$ terminates, then it terminates in a state where $q$ is true</li></ul></li><li><p>correctness formulas also call <strong>inductive expressions</strong></p></li></ul><center><img loading="lazy" src="/posts/ab706956/1.gif" width="550"></center><blockquote><p>åªè¦ P åœ¨ C æ‰§è¡Œå‰çš„çŠ¶æ€ä¸‹æˆç«‹ï¼Œåˆ™åœ¨æ‰§è¡Œä¹‹å Q ä¹Ÿæˆç«‹ã€‚æ³¨æ„å¦‚æœ C ä¸ç»ˆæ­¢ï¼Œä¹Ÿå°±æ²¡æœ‰â€ä¹‹åâ€äº†ï¼Œæ‰€ä»¥ Q åœ¨æ ¹æœ¬ä¸Šå¯ä»¥æ˜¯ä»»ä½•è¯­å¥ã€‚å®é™…ä¸Šï¼Œä½ å¯ä»¥é€‰æ‹© Q ä¸ºå‡æ¥è¡¨è¾¾ C ä¸ç»ˆæ­¢ã€‚äº‹å®ä¸Šï¼Œè¿™ç§æƒ…å½¢å«åš â€œéƒ¨åˆ†æ­£ç¡®ï¼ˆpartial correctnessï¼‰â€ã€‚å¦‚æœ C ç»ˆæ­¢å¹¶ä¸”åœ¨ç»ˆæ­¢æ—¶ Q æ˜¯çœŸï¼Œåˆ™è¡¨è¾¾å¼è¢«ç§°ä½œ â€œå…¨éƒ¨æ­£ç¡®æ€§ï¼ˆtotal correctnessï¼‰â€ã€‚ç»ˆæ­¢å¿…é¡»è¢«å•ç‹¬è¯æ˜ã€‚</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/ab706956/7.png" width="550"></center><h3 id="characteristic-predicate">2.1. characteristic predicate</h3><blockquote><p>Let U be the set of all n-tuples of values over some domain(s), and let Uâ€²âŠ†U be a <strong>relation</strong> over U. The n-ary predicat $P_{Uâ€²}$ is the <strong>characteristic predicate</strong>ç‰¹å¾è°“è¯ of Uâ€² if it is interpreted over the domain U by the relation Uâ€². That is, $v(P_{Uâ€²}($x_1$,â€¦,$x_n$))&#x3D;T iff ($x_1$,â€¦,$x_n$)âˆˆUâ€²$.</p></blockquote><ul><li>We can write {(x 1,â€¦,x n )âˆ£(x 1,â€¦,x n )âˆˆUâ€²} as {(x 1,â€¦,x n )âˆ£ $P_{Uâ€²}$ }</li><li>å³ï¼šå¦‚æœå˜é‡éƒ½åœ¨domainä¸Šï¼Œåˆ™ä¸ºT</li></ul><h3 id="semantics-of-programming-language">2.2. semantics of programming language</h3><ul><li>ç¼–ç¨‹è¯­è¨€çš„<strong>è¯­ä¹‰</strong>æ˜¯é€šè¿‡æŒ‡å®šè¯­è¨€ä¸­çš„æ¯ä¸ªè¯­å¥å¦‚ä½•å°†ä¸€ç§çŠ¶æ€è½¬åŒ–ä¸ºå¦ä¸€ç§çŠ¶æ€è€Œç»™å‡ºçš„</li></ul><p><strong>example</strong></p><ul><li>Let S be the statement x &#x3D; 2*y+1. <ul><li>If started in an arbitrary state (x,y), the statement terminates in the state (xâ€²,yâ€²) where xâ€²&#x3D;2yâ€²+1. </li><li>Another way of expressing this is to say that S transforms the set of states {(x,y)âˆ£true} into the set {(x,y)âˆ£x&#x3D;2y+1}.</li><li>The statement S also transforms the set of states {(x,y)âˆ£yâ‰¤3} into the set {(x,y)âˆ£(xâ‰¤7)âˆ§(yâ‰¤3)}, because if yâ‰¤3 then 2y+1â‰¤7</li></ul></li></ul><h2 id="Deductive-System-HL-éœå°”é€»è¾‘">3. Deductive System HL éœå°”é€»è¾‘</h2><ul><li>Instead, we will simply take all true formulas in the domain as axioms. For example, (xâ‰¥y)â†’(x+1â‰¥y+1) is true in arithmetic and will be used as an axiom. This is reasonable since we wish to concentrate on the verification that a program S is correct without the complication of verifying arithmetic formulas that are well known.</li></ul><center><img loading="lazy" src="/posts/ab706956/2.png" width="550"></center><p>example</p><center><img loading="lazy" src="/posts/ab706956/3.png" width="550"></center><ul><li>The formula p in the loop rule is called an <strong>invariant</strong>ä¸å˜é‡: it describes the behavior of a single execution of the statement S in the body of the while-statement.</li><li>æ„Ÿè§‰æœ‰ç‚¹ç±»ä¼¼sed</li></ul><h2 id="Program-Verification">4. Program Verification</h2><center><img loading="lazy" src="/posts/ab706956/8.png" width="650"></center>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Program&quot;&gt;1. Program&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;computer program&lt;/strong&gt; is not very different from a logical formula. It consists of a sequence of &lt;strong&gt;symbols&lt;/strong&gt; constructed according to &lt;strong&gt;formal syntactical rules&lt;/strong&gt; and it has a meaning which is assigned by an &lt;strong&gt;interpretation&lt;/strong&gt; of the elements of the language. In programming, the symbols are called &lt;strong&gt;statements or commands&lt;/strong&gt; and the intended interpretation is the &lt;strong&gt;execution&lt;/strong&gt; of the program on a computer. The syntax of programming languages is specified using formal systems such as BNF, but the semantics is usually informally specified.&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªè®¡ç®—æœºç¨‹åºä¸ä¸€ä¸ªé€»è¾‘å…¬å¼æ²¡æœ‰ä»€ä¹ˆä¸åŒã€‚å®ƒç”±ä¸€è¿ä¸²çš„ç¬¦å·ç»„æˆï¼Œè¿™äº›ç¬¦å·æ˜¯æ ¹æ®æ­£å¼çš„å¥æ³•è§„åˆ™æ„å»ºçš„ï¼Œå®ƒæœ‰ä¸€ä¸ªæ„ä¹‰ï¼Œè¿™ä¸ªæ„ä¹‰æ˜¯é€šè¿‡å¯¹è¯­è¨€å…ƒç´ çš„è§£é‡Šè€Œèµ‹äºˆçš„ã€‚åœ¨ç¼–ç¨‹ä¸­ï¼Œè¿™äº›ç¬¦å·è¢«ç§°ä¸ºè¯­å¥æˆ–å‘½ä»¤ï¼Œé¢„æœŸçš„è§£é‡Šæ˜¯ç¨‹åºåœ¨è®¡ç®—æœºä¸Šçš„æ‰§è¡Œã€‚&lt;strong&gt;ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•æ˜¯ç”¨BNFè¿™æ ·çš„å½¢å¼åŒ–ç³»ç»ŸæŒ‡å®šçš„ï¼Œä½†è¯­ä¹‰é€šå¸¸æ˜¯éæ­£å¼åœ°æŒ‡å®šçš„&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;è€ƒè™‘ä¸€é—¨è¯­è¨€çš„è®¾è®¡&quot;&gt;1.1. è€ƒè™‘ä¸€é—¨è¯­è¨€çš„è®¾è®¡&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A program is a &lt;strong&gt;statement&lt;/strong&gt; S, where statements are defined recursively using the concepts of variables and expressions&lt;ul&gt;
&lt;li&gt;ç¨‹åºæœ¬èº«å°±æ˜¯ä¸€ä¸ªæŠ½è±¡çš„å¤§statement&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ab706956/6.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;statement&lt;/strong&gt; in a programming language can be considered to be a function that transforms the state of a computation&lt;ul&gt;
&lt;li&gt;ç¼–ç¨‹è¯­è¨€å¯ä»¥è¢«è§†ä½œçŠ¶æ€è½¬æ¢å‡½æ•°&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Let $S$ be a &lt;strong&gt;program&lt;/strong&gt; with $n$ &lt;strong&gt;variables&lt;/strong&gt; $(x1,â€¦,xn)$. A &lt;strong&gt;state&lt;/strong&gt; $s$ of $S$ consists of an $n+1$-tuple of values $(lc,x_1,â€¦,x_n )$, where $lc$ is the value of the &lt;strong&gt;location counter&lt;/strong&gt;(sometimes called the &lt;strong&gt;instruction pointer&lt;/strong&gt;ï¼Œå­˜å‚¨ä¸‹ä¸€ä¸ªæŒ‡ä»¤çš„åœ°å€)  and $x_i$ is the value of the variable $xi$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;we aim to verify the program by proving: if the input to the program satisfies the precondition, then the output of the program will satisfy the postcondition&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the variables (x,y) have the values (8,7) in a state, then the result of executing the statement x &amp;#x3D; 2*y+1 is the state in which (x,y)&amp;#x3D;(15,7) and the location counter is incremented&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>academic writing-Literature Review</title>
    <link href="https://hejueyun.github.io/posts/dd5e4fc6/"/>
    <id>https://hejueyun.github.io/posts/dd5e4fc6/</id>
    <published>2022-02-22T22:23:20.000Z</published>
    <updated>2022-02-22T23:51:14.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-literature">1. What is literature</h2><ul><li>Published written works (publications)</li><li>Unpublished written works</li></ul><h2 id="Why-literature-review">2. Why literature review</h2><ul><li>First step of research</li><li>Help you obtain background knowledge</li><li>Identify related work to yours</li><li>Understand <strong>the state of the art</strong>å°–ç«¯æŠ€æœ¯ in your project area</li><li>To frame your arguments and research questions based on the state-of-the-art</li><li>Identify knowledge gaps or limitations in your project area</li></ul><h2 id="Where-to-find-publications">3. Where to find publications</h2><ol><li>ACM Digital Library (<a href="https://dl.acm.org/">https://dl.acm.org/</a>) hosts ACM Journals and ACM Conference Proceedings</li><li>IEEE Xplore (<a href="https://ieeexplore.ieee.org/">https://ieeexplore.ieee.org/</a>) hosts IEEE Journals and IEEE Conference Proceedings</li><li>SpringerLink (<a href="https://link.springer.com/">https://link.springer.com/</a>) hosts Springer Journals (including Nature) and Springer Conference Proceedings</li><li>ScienceDirect (<a href="https://www.sciencedirect.com/">https://www.sciencedirect.com/</a>) hosts Elsevier Journals and e-books</li><li>Wiley Online Library (<a href="https://onlinelibrary.wiley.com/">https://onlinelibrary.wiley.com/</a>) hosts Wiley Journals and e-books</li><li>Google Scholar (<a href="https://scholar.google.com/">https://scholar.google.com/</a>) â€“ Web search engine for scholarly literature</li></ol><h2 id="How-to-do-literature-review">4. How to do literature review</h2><ul><li>Systematic literature review (SLR) methods<ul><li>Traditional SLR</li><li>Snowballing</li></ul></li></ul><h3 id="Traditional-SLR">4.1. Traditional SLR</h3><ul><li>ä½¿ç”¨ç”±ä¸€ç»„å…³é”®è¯ç»„æˆçš„æœç´¢å­—ç¬¦ä¸²</li><li>å¯¹æ¯ä¸€ä¸ªå·²çŸ¥çš„æ•°å­—å›¾ä¹¦é¦†è¿›è¡Œè¯¦å°½çš„æœç´¢</li><li>æ—¨åœ¨é€‰æ‹©æ‰€æœ‰ç›¸å…³çš„è®ºæ–‡</li><li>è€—è´¹æ—¶é—´ï¼Œè€Œä¸”ä½œä¸ºä¸ªäººå¾ˆéš¾åšåˆ°è¿™ä¸€ç‚¹</li></ul><h3 id="Snowballing">4.2. Snowballing</h3><center><img loading="lazy" src="/posts/dd5e4fc6/1.png" width="550"></center><ol><li>Identify the start set<ol><li>Ask your supervisor to suggest 3-5 good quality, relevant papers</li><li>Add 3-5 top cited and relevant papers from Google Scholar search</li></ol></li><li>Perform backward snowballing<ol><li>Go through the <strong>reference list</strong> of each paper in the start set to identify new papers to include</li><li>Exclude papers that do not fulfil the basic criteria such as, for example, language, publication year and type of publication</li><li>Remove papers from the list that have already been examined in the earlier iteration</li><li>Add the remaining papers to the start set</li><li>Repeat from step1 å°†å‰©ä½™çš„è®ºæ–‡æ·»åŠ åˆ°èµ·å§‹é›†</li><li>End if you have gone through the reference list of all the papers in the start set</li></ol></li><li>Perform <strong>forward</strong> snowballing<ol><li>For each paper in the start set, identify the papers that cite this paper using Google Scholar ä½¿ç”¨è°·æ­Œå­¦æœ¯æ‰¾å‡º<strong>å¼•ç”¨è¯¥è®ºæ–‡</strong>çš„è®ºæ–‡</li><li>For each citing paper that is not in the start set, download it from its DL, read, in the order of: 1) abstract, 2) introduction, 3) conclusion or 4) full text to see if itâ€™s relevant to your project</li><li>Repeat from step 1 until you have gone through all the papers in the start set</li></ol></li><li>Iterations<ol><li>Repeat backward snowballing at least once</li><li>Repeat forward snowballing at least once</li><li>Iterate from forward snowballing to backward, to ensure a comprehensive inclusion of good quality, relevant papers</li><li>The results of iterations are the set of the papers for detailed review and <strong>to be included in your dissertation report</strong>.</li></ol></li><li>Manage your references<ol><li>EndNote - for Word</li><li>BibTex - for Overleaf</li><li><strong>Citation and reference styles</strong><ol><li>Numbering system (IEEE style)</li><li>Author and Date system (Harvard style)</li></ol></li></ol></li></ol><h2 id="Critical-tasks-in-literature-review">5. Critical tasks in literature review</h2><p>When reading each reference, you need to systematically perform the following tasks:</p><ul><li>Data extraction æ•°æ®æå–: Extract useful information (data) from each reference</li><li>Data synthesis æ•°æ®ç»¼åˆ: Organize the extracted data into categories and subcategories</li><li>Data analysis æ•°æ®åˆ†æ: Interpret the data to make sense of them through:<ul><li>Quantitative analysis å®šé‡åˆ†æ: use statistics and frequency counts to analyse the data</li><li>Qualitative analysis å®šæ€§åˆ†æ: use descriptions to interpret the data</li><li>Visualisation å¯è§†åŒ–: use tables, charts, graphs to represent the data</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;What-is-literature&quot;&gt;1. What is literature&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Published written works (publications)&lt;/li&gt;
&lt;li&gt;Unpublished written works&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Why-literature-review&quot;&gt;2. Why literature review&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;First step of research&lt;/li&gt;
&lt;li&gt;Help you obtain background knowledge&lt;/li&gt;
&lt;li&gt;Identify related work to yours&lt;/li&gt;
&lt;li&gt;Understand &lt;strong&gt;the state of the art&lt;/strong&gt;å°–ç«¯æŠ€æœ¯ in your project area&lt;/li&gt;
&lt;li&gt;To frame your arguments and research questions based on the state-of-the-art&lt;/li&gt;
&lt;li&gt;Identify knowledge gaps or limitations in your project area&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Where-to-find-publications&quot;&gt;3. Where to find publications&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ACM Digital Library (&lt;a href=&quot;https://dl.acm.org/&quot;&gt;https://dl.acm.org/&lt;/a&gt;) hosts ACM Journals and ACM Conference Proceedings&lt;/li&gt;
&lt;li&gt;IEEE Xplore (&lt;a href=&quot;https://ieeexplore.ieee.org/&quot;&gt;https://ieeexplore.ieee.org/&lt;/a&gt;) hosts IEEE Journals and IEEE Conference Proceedings&lt;/li&gt;
&lt;li&gt;SpringerLink (&lt;a href=&quot;https://link.springer.com/&quot;&gt;https://link.springer.com/&lt;/a&gt;) hosts Springer Journals (including Nature) and Springer Conference Proceedings&lt;/li&gt;
&lt;li&gt;ScienceDirect (&lt;a href=&quot;https://www.sciencedirect.com/&quot;&gt;https://www.sciencedirect.com/&lt;/a&gt;) hosts Elsevier Journals and e-books&lt;/li&gt;
&lt;li&gt;Wiley Online Library (&lt;a href=&quot;https://onlinelibrary.wiley.com/&quot;&gt;https://onlinelibrary.wiley.com/&lt;/a&gt;) hosts Wiley Journals and e-books&lt;/li&gt;
&lt;li&gt;Google Scholar (&lt;a href=&quot;https://scholar.google.com/&quot;&gt;https://scholar.google.com/&lt;/a&gt;) â€“ Web search engine for scholarly literature&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;How-to-do-literature-review&quot;&gt;4. How to do literature review&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Systematic literature review (SLR) methods&lt;ul&gt;
&lt;li&gt;Traditional SLR&lt;/li&gt;
&lt;li&gt;Snowballing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Traditional-SLR&quot;&gt;4.1. Traditional SLR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ä½¿ç”¨ç”±ä¸€ç»„å…³é”®è¯ç»„æˆçš„æœç´¢å­—ç¬¦ä¸²&lt;/li&gt;
&lt;li&gt;å¯¹æ¯ä¸€ä¸ªå·²çŸ¥çš„æ•°å­—å›¾ä¹¦é¦†è¿›è¡Œè¯¦å°½çš„æœç´¢&lt;/li&gt;
&lt;li&gt;æ—¨åœ¨é€‰æ‹©æ‰€æœ‰ç›¸å…³çš„è®ºæ–‡&lt;/li&gt;
&lt;li&gt;è€—è´¹æ—¶é—´ï¼Œè€Œä¸”ä½œä¸ºä¸ªäººå¾ˆéš¾åšåˆ°è¿™ä¸€ç‚¹&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Note" scheme="https://hejueyun.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-é¡¹ä¸èŒƒå¼</title>
    <link href="https://hejueyun.github.io/posts/bb11e25b/"/>
    <id>https://hejueyun.github.io/posts/bb11e25b/</id>
    <published>2022-02-18T15:27:40.000Z</published>
    <updated>2022-03-13T20:41:55.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Terms-é¡¹">1. Terms é¡¹</h2><ul><li>Variables. <ul><li>Any <strong>variable</strong>, <strong>constant</strong> or <strong>0-ary function symbol</strong> is a term.</li></ul></li><li>Functions. <ul><li>Any <strong>expression</strong> $f(t_1,â€¦,t_n)$ of n arguments (where each argument $t_i$ is a term and $f$ is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.</li></ul></li></ul><p>Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms</p><h2 id="prenex-conjunctive-normal-form-PCNF-å‰æŸèŒƒå¼">2. prenex conjunctive normal form(PCNF) å‰æŸèŒƒå¼</h2><ul><li>A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:<ul><li>$Q_1x_1â€¦Q_nx_nM$</li></ul></li><li>where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1â‹¯Q_nx_n$ is the prefix and $M$ is the matrix</li></ul><blockquote><p>å¦‚æœä¸€ä¸ªå…¬ç¤ºå¯ä»¥è¢«å†™ä¸ºé‡è¯åœ¨å‰ï¼Œéšåæ˜¯è¢«ç§°ä¸ºæ¯ä½“çš„æ— é‡è¯éƒ¨åˆ†ï¼Œåˆ™ç§°å…¶ä¸ºå‰æŸèŒƒå¼çš„ï¼Œæ‰€æœ‰ç»å…¸é€»è¾‘å…¬å¼éƒ½é€»è¾‘ç­‰ä»·äºæŸä¸ªå‰æŸèŒƒå¼å…¬å¼</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/7.gif" width="550"></center><ul><li>Let A be a closed formula in PCNF whose prefix consists only of universal quantifiers. The clausal form of A consists of the matrix of A written as a set of clauses</li><li>æ‰€ä»¥ä¸Šä¸ªä¾‹å­å¯ä»¥å†™ä¸ºï¼š</li></ul><center><img loading="lazy" src="/posts/bb11e25b/7.gif" width="550"></center><h3 id="Skolemâ€™s-Theorem-æ–¯ç§‘ä¼¦å®šç†">2.1. Skolemâ€™s Theorem æ–¯ç§‘ä¼¦å®šç†</h3><ul><li>In propositional logic, every formula is equivalent to one in CNF, but this is not true in first-order logic. However, a formula in first-order logic can be transformed into <strong>one in clausal form</strong> <strong>without modifying its satisfiability</strong>. åœ¨ä¸æ”¹å˜åŠå¯æ»¡è¶³æ€§çš„æƒ…å†µä¸‹</li><li><strong>Skolem</strong>: Let $A$ be a closed formula. Then there exists a formula $A^â€²$ in clausal form such that $Aâ‰ˆA^â€²$</li></ul><h4 id="â‰ˆ-vs-â‰¡">2.1.1. â‰ˆ vs â‰¡</h4><blockquote><p>Aâ‰ˆAâ€² means that A is satisfiable if and only if Aâ€² is satisfiable; that is, there exists a model for A if and only if there exists a model for Aâ€². (may not be the same)</p><p>This is not the same as logically equivalence Aâ‰¡Aâ€², which means that for all models $I$, $I$  is a model for A if and only if it is a model for Aâ€².</p></blockquote><hr><ul><li>In A&#x3D;âˆ€xâˆƒyp(x,y), the quantifiers can be read: **for all x, produce a value y associated with that x such that the predicate p is true. **</li><li>But our intuitive concept of a function is the same: y&#x3D;f(x) means that given x, f produces a value y associated with x. The existential quantifier can be removed giving Aâ€²&#x3D;âˆ€xp(x,f(x)).<ul><li>y&#x3D;f(x)æ„å‘³ç€ç»™å®šxï¼Œfäº§ç”Ÿä¸€ä¸ªä¸xç›¸å…³çš„å€¼yã€‚å¯ä»¥åˆ é™¤å­˜åœ¨é‡è¯ï¼Œç»™å‡º $A^â€²&#x3D;âˆ€xp(x,f(x))$</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/9.jpg" width="550"></center><h3 id="Skolemâ€™s-Algorithm-æ–¯ç§‘ä¼¦ç®—æ³•">2.2. Skolemâ€™s Algorithm æ–¯ç§‘ä¼¦ç®—æ³•</h3><ul><li>ç›®çš„ï¼šå°†ä»»æ„(?)ä¸€é˜¶é€»è¾‘å…¬å¼è½¬åŒ–ä¸ºclause form</li></ul><center><img loading="lazy" src="/posts/bb11e25b/13.png" width="550"></center><ul><li>ä¾‹å­ï¼š$âˆ€x(p(x)\rightarrow{q(x)})\rightarrow{}(âˆ€xp(x)\rightarrow{}âˆ€xq(x))$</li></ul><ol><li>Eliminate all binary Boolean operators other than âˆ¨ and âˆ§<ol><li>æ¶ˆå»é™¤ âˆ¨ å’Œ âˆ§ å¤–çš„æ‰€æœ‰äºŒå…ƒæ“ä½œç¬¦</li></ol></li><li>Push negation operators inward, collapsing double negation, until they apply to atomic formulas only<ol><li>å°†å¦å®šè¿ç®—ç¬¦å‘å†…æ¨ï¼ŒæŠ˜å åŒé‡å¦å®šï¼Œç›´åˆ°å¦å®šè¿ç®—ç¬¦åªä½œç”¨äºåŸå­å¼</li></ol></li><li>Extract quantifiers from the matrix. Repeat until all quantifiers appear in the prefix and the matrix is quantifier-free.  <ol><li>ä»çŸ©é˜µä¸­æå–é‡è¯</li><li>é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°æ‰€æœ‰çš„é‡è¯éƒ½å‡ºç°åœ¨å‰ç¼€ä¸­ï¼Œå¹¶ä¸”çŸ©é˜µæ— é‡è¯</li></ol></li><li>Use the distributive laws to transform the matrix into CNF. The formula is now in PCNF.<ol><li>ä½¿ç”¨åˆ†é…å¾‹å°†çŸ©é˜µè½¬æ¢ä¸ºCNFã€‚è¯¥å…¬å¼ç°åœ¨æ˜¯PCNF</li></ol></li><li>For every existential quantifier $âˆƒx$ in A, let $y_1,â€¦,y_n$ be the universally quantified variables preceding $âˆƒx$ and let f be a new n-ary function symbol. <ol><li>Delete $âˆƒx$ and replace every occurrence of x by $f(y_1,â€¦,y_n)$. </li><li>If there are no universal quantifiers preceding âˆƒx, replace x by a new constant (0-ary function). </li><li>These new function symbols are <strong>Skolem functions</strong> and the process of replacing existential quantifiers by functions is <strong>Skolemization</strong>.</li></ol></li><li>The formula can be written in clausal form by dropping the (universal) quantifiers and writing the matrix as sets of clauses</li></ol><center><img loading="lazy" src="/posts/bb11e25b/10.jpg" width="550"></center><center><img loading="lazy" src="/posts/bb11e25b/11.jpg" width="550"></center><ul><li>æ³¨æ„æœ€åä¸€æ­¥å¤§æ‹¬å·ä»¥åŠé€—å·åˆ†åˆ«å–ä»£çš„äºŒå…ƒç¬¦å·<ul><li>clause: {L,L,L}ä»£è¡¨çš„æ˜¯or</li><li>set of clauses:{C,C,C}ä»£è¡¨çš„æ˜¯and</li></ul></li><li>åŒæ—¶æ³¨æ„æœ‰ä¸€æ­¥æ˜¯<strong>rename</strong></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/12.jpg" width="550"></center><h3 id="Skolemised-form-æ–¯ç§‘ä¼¦èŒƒå¼">2.3. Skolemised form æ–¯ç§‘ä¼¦èŒƒå¼</h3><ul><li>å¦‚æœä¸€é˜¶é€»è¾‘å¼çš„å‰æŸèŒƒå¼åªæœ‰å…¨ç§°é‡è¯ï¼Œåˆ™ç§°å…¶ä¸ºæ˜¯ç¬¦åˆSkolem èŒƒå¼çš„</li></ul><h3 id="Properties-of-CNFs-and-clausal-forms">2.4. Properties of CNFs and clausal forms</h3><ul><li>For F be any formula and suppose $Fâ‡’^{âˆ—}_{CNF} F^{â€˜}$<ul><li>Then $F â‰¡ F^{â€˜}$</li></ul></li></ul><h3 id="ä¸ºä»€ä¹ˆéœ€è¦æ–¯ç§‘ä¼¦èŒƒå¼">2.5. ä¸ºä»€ä¹ˆéœ€è¦æ–¯ç§‘ä¼¦èŒƒå¼</h3><center><img loading="lazy" src="/posts/bb11e25b/14.png" width="550"></center><h2 id="Herbrand-Models-åŸƒå°”å¸ƒæœ—æ¨¡å‹">3. Herbrand Models åŸƒå°”å¸ƒæœ—æ¨¡å‹</h2><blockquote><p><strong>When function symbols are used to form terms</strong>, there is no easy way to describe the set of possible <strong>interpretations</strong>. The domain could be a numerical domain or a domain of data structures or almost anything else. The definition of even one function can choose to assign an arbitrary element of the domain to an arbitrary subset of arguments.</p></blockquote><blockquote><p><strong>Herbrand models</strong>, which are a relatively limited set of interpretations that have the following property: If a set of clauses has a model then it has an Herbrand model.</p></blockquote><ul><li>a formula is satisfiable if and only if its clausal form is satisfiable and A set of clauses S has a model iff it has an Herbrand model.<ul><li>åä¹‹äº¦æˆç«‹</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/22.png" width="550"></center><h3 id="Herbrand-Universes-for-domain">3.1. Herbrand Universes (for domain)</h3><p>Let Î£ &#x3D; (F, P) denote the <strong>signature</strong>æ ‡è¯† of a clause set N</p><ul><li><p>The Herbrand universe is $T_Î£$, i.e., the set of all <strong>ground terms</strong> over Î£</p><ul><li>Suppose N &#x3D; {P(a), Â¬P(x) âˆ¨ P(f (x, b))}</li><li>Then F consists of one binary function symbol f and two constants a and b Herbrand universe over Î£:<ul><li>$T_Î£ &#x3D; {a, b, f (a, a), f (a, b), f (b, a), f (b, b), f (a, f (a, a)), . . .}$</li></ul></li></ul></li><li><p>If Î£ contains non-constant function symbols then TÎ£ is infinite</p></li><li><p>Important assumption: There is at least one constant in the signature Î£</p><ul><li>Suppose N &#x3D; {P(x), Â¬P(x) âˆ¨ P(f (x, y))}. Then include a (fresh) in Î£<ul><li>$T_Î£ &#x3D; {a, f (a, a), f (a, f (a, a)), f (f (a, a), f (a, a)), . . .}$</li></ul></li></ul></li><li><p>If there are no constant symbols or 0-ary function symbols in S, i<strong>nitialize the inductive definition</strong> of $H_S$ with an arbitrary constant symbol a.â€ƒ</p></li><li><p>The Herbrand universe is just the set of ground terms that can be formed from symbols in S. Obviously, if S contains a function symbol, the Herbrand universe is infinite since $f(f(â€¦(a)â€¦))âˆˆH_S$</p></li></ul><center><img loading="lazy" src="/posts/bb11e25b/20.gif" width="550"></center><h3 id="Herbrand-Interpretations">3.2. Herbrand Interpretations</h3><p>A Herbrand interpretation, denoted I, is a set of ground atoms over Î£</p><ul><li>$I &#x3D; {A_1, . . . , A_n, . . .}$</li><li>Note: $I |&#x3D; A$ iff $A âˆˆ I$<ul><li>is equivalent to $I |\neq{} A$ iff $A \notin{} I$</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/15.png" width="550"></center><ul><li><p>æ³¨æ„æ­¤å¤„å°†å¯¹æŸä¸€å…¬å¼çš„è§£çš„éªŒè¯è½¬åŒ–ä¸ºå¯¹è¯¥å…¬å¼çš„åŸƒå°”å¸ƒæœ—è§£çš„éªŒè¯</p><ul><li>åŒæ—¶æ³¨æ„Iä¸æ˜¯P(x)çš„è§£ï¼Œå¹¶ä¸æ„å‘³ç€Iå°±æ˜¯éP(x)çš„è§£ï¼</li></ul></li><li><p>Truth in I of any set N of clauses&#x2F;quantifier-free formulae:</p><center><img loading="lazy" src="/posts/bb11e25b/16.png" width="550"></center></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/17.png" width="550"></center><h3 id="all-ground-instances">3.3. all ground instances</h3><center><img loading="lazy" src="/posts/bb11e25b/18.png" width="550"></center><p>Let N be a set of Î£-clauses. Then</p><ul><li><p>N is true in a standard interpretation</p><ul><li>iff N has a Herbrand model (over Î£)</li><li>iff $G_Î£(N)$ has a Herbrand model (over Î£)</li></ul></li><li><p>We use it for model construction required for the completeness proof of the resolution system</p><ul><li>æˆ‘ä»¬ç”¨å®ƒæ¥æ„å»ºå½’ç»“ç³»ç»Ÿçš„å®Œæ•´æ€§è¯æ˜æ‰€éœ€çš„è§£é‡Š</li></ul></li></ul><p>Using Herbrandâ€™s theorem to find a model</p><center><img loading="lazy" src="/posts/bb11e25b/19.png" width="550"></center><center><img loading="lazy" src="/posts/bb11e25b/21.png" width="550"></center><hr><h2 id="Formulas-in-number-theory-informal-meaning-in-N">4. Formulas in number theory, informal meaning in $N$</h2><center><img loading="lazy" src="/posts/bb11e25b/1.png" width="550"></center><ul><li>Evenï¼šå¶æ•°</li></ul><h2 id="Translating-English-into-first-order-logic-formulas">5. Translating English into first-order logic formulas</h2><center><img loading="lazy" src="/posts/bb11e25b/2.png" width="550"></center><h2 id="Substitution-æ›¿æ¢">6. Substitution æ›¿æ¢</h2><ul><li><strong>ä¸€ä¸ªfunction</strong></li><li>$Ïƒ : X â†’ TÎ£(X)$</li><li>such that the set $Dom(Ïƒ) &#x3D;^{def}{x âˆˆ X | Ïƒ(x) \neq{x}}$ is <strong>finite</strong><ul><li>Dom(Ïƒ) is the <strong>domain</strong> of Ïƒ</li><li>$Cod(Ïƒ) &#x3D;^{def} {Ïƒ(x) | x âˆˆ Dom(Ïƒ)}$ is the <strong>codomain</strong> of Ïƒ</li></ul></li></ul><p>Example</p><ul><li>F &#x3D; P(g(x), y, x)</li><li>F{x&#x2F;a, y&#x2F;f (z)} &#x3D; P(g(a), f (z), a)</li></ul><center><img loading="lazy" src="/posts/bb11e25b/3.png" width="550"></center><p><strong>ä¸€èˆ¬å¼</strong></p><center><img loading="lazy" src="/posts/bb11e25b/4.png" width="550"></center><h3 id="Modification-of-a-substitution">6.1. Modification of a substitution</h3><center><img loading="lazy" src="/posts/bb11e25b/5.png" width="550"></center><h3 id="Restriction">6.2. Restriction</h3><ol><li>only for a free variable</li><li>The captured variable must be renamed into a â€œfreshâ€ variable, say xâ€™, F{y&#x2F;x} &#x3D; âˆƒxâ€™(xâ€™ &gt; x)<ol><li>ä¹Ÿå°±æ˜¯ä¸èƒ½ç”¨xæ¢yï¼Œå¯¼è‡´æ­§ä¹‰</li></ol></li></ol><h3 id="substitution-instance">6.3. substitution instance</h3><p><strong>instanceå°±æ˜¯ç”±substitutionæ‰€äº§ç”Ÿçš„</strong></p><blockquote><p>n. We say that a formula Ï† is an instance of a formula Ïˆ if there exists a substitution <code>Ïƒ</code> for the free variables in Ïˆ such that ÏˆÏƒ is a renamed variant of Ï†</p></blockquote><ul><li>We say EÏƒ is formed by applying Ïƒ to E, where E is an expression (a term or formula)</li><li>Example Ïƒ &#x3D; {x&#x2F;a, y&#x2F;b}<ul><li>P(g(x), y, x)Ïƒ &#x3D; P(g(x)Ïƒ, yÏƒ, xÏƒ) &#x3D; P(g(xÏƒ), yÏƒ, xÏƒ) &#x3D; P(g(a), b, a)</li></ul></li></ul><h3 id="identity-substitution-ä¸€è‡´æ€§æ›¿æ¢">6.4. identity substitution ä¸€è‡´æ€§æ›¿æ¢</h3><blockquote><p>The identity substitution, which maps every variable to itself, is the neutral element of substitution composition</p><p>ä¸€è‡´æ€§æ›¿æ¢ï¼Œå°†æ¯ä¸ªå˜é‡éƒ½æ˜ å°„åˆ°è‡ªèº«ï¼Œæ˜¯æ›¿æ¢ç»„åˆçš„ä¸­æ€§å…ƒç´ ã€‚</p></blockquote><h3 id="Codomain-åˆ°è¾¾åŸŸ">6.5. Codomain åˆ°è¾¾åŸŸ</h3><ul><li>åˆ°è¾¾åŸŸï¼ˆè‹±è¯­ï¼šCodomainï¼‰ï¼Œæˆ–ç§°ä¸ºé™ªåŸŸã€ä½™å®šä¹‰åŸŸã€ä¸ŠåŸŸã€ç»ˆåŸŸã€å…±å˜åŸŸã€ç›®æ ‡é›†</li><li>ä¸€ä¸ªå‡½æ•°çš„åˆ°è¾¾åŸŸæŒ‡çš„æ˜¯<strong>è‡³å°‘åŒ…å«æ‰€æœ‰</strong>æ­¤å‡½æ•°çš„è¾“å‡ºå€¼çš„ä¸€ä¸ªé›†åˆã€‚åœ¨å‡½æ•°ç¬¦å· ${\displaystyle f\colon X\rightarrow Y}$ ä¸­ï¼Œ ${\displaystyle Y}$ æ˜¯å‡½æ•° ${\displaystyle f}$ çš„åˆ°è¾¾åŸŸ</li><li><strong>ä¸æ˜¯å€¼åŸŸ</strong><ul><li>${\displaystyle f}$ çš„å€¼åŸŸæ˜¯ ${\displaystyle Y}$ çš„ä¸€ä¸ªå­é›†ï¼Œè‹¥ ${\displaystyle f}$ æ˜¯ä¸€ä¸ªæ»¡å°„å‡½æ•°ï¼Œåˆ™ ${\displaystyle f}$ çš„åˆ°è¾¾åŸŸå’Œå€¼åŸŸç›¸ç­‰</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Terms-é¡¹&quot;&gt;1. Terms é¡¹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Variables. &lt;ul&gt;
&lt;li&gt;Any &lt;strong&gt;variable&lt;/strong&gt;, &lt;strong&gt;constant&lt;/strong&gt; or &lt;strong&gt;0-ary function symbol&lt;/strong&gt; is a term.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions. &lt;ul&gt;
&lt;li&gt;Any &lt;strong&gt;expression&lt;/strong&gt; $f(t_1,â€¦,t_n)$ of n arguments (where each argument $t_i$ is a term and $f$ is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms&lt;/p&gt;
&lt;h2 id=&quot;prenex-conjunctive-normal-form-PCNF-å‰æŸèŒƒå¼&quot;&gt;2. prenex conjunctive normal form(PCNF) å‰æŸèŒƒå¼&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:&lt;ul&gt;
&lt;li&gt;$Q_1x_1â€¦Q_nx_nM$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1â‹¯Q_nx_n$ is the prefix and $M$ is the matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;å¦‚æœä¸€ä¸ªå…¬ç¤ºå¯ä»¥è¢«å†™ä¸ºé‡è¯åœ¨å‰ï¼Œéšåæ˜¯è¢«ç§°ä¸ºæ¯ä½“çš„æ— é‡è¯éƒ¨åˆ†ï¼Œåˆ™ç§°å…¶ä¸ºå‰æŸèŒƒå¼çš„ï¼Œæ‰€æœ‰ç»å…¸é€»è¾‘å…¬å¼éƒ½é€»è¾‘ç­‰ä»·äºæŸä¸ªå‰æŸèŒƒå¼å…¬å¼&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/bb11e25b/7.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;Let A be a closed formula in PCNF whose prefix consists only of universal quantifiers. The clausal form of A consists of the matrix of A written as a set of clauses&lt;/li&gt;
&lt;li&gt;æ‰€ä»¥ä¸Šä¸ªä¾‹å­å¯ä»¥å†™ä¸ºï¼š&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/bb11e25b/7.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-æ¼”ç»</title>
    <link href="https://hejueyun.github.io/posts/f450749c/"/>
    <id>https://hejueyun.github.io/posts/f450749c/</id>
    <published>2022-02-18T15:11:01.000Z</published>
    <updated>2022-02-20T15:09:47.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Deductive-system">1. Deductive system</h2><h3 id="G">1.1. G</h3><ul><li>We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference <strong>for the universal quantifier</strong>å…¨ç§°é‡è¯.</li></ul><center><img loading="lazy" src="/posts/f450749c/1.gif" width="550"></center><h3 id="H">1.2. H</h3><ul><li>The rules of inference are modus ponens and generalization</li></ul><center><img loading="lazy" src="/posts/f450749c/2.gif" width="550"></center><ul><li>The Deduction Ruleï¼š</li></ul><center><img loading="lazy" src="/posts/f450749c/3.gif" width="550"></center>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Deductive-system&quot;&gt;1. Deductive system&lt;/h2&gt;&lt;h3 id=&quot;G&quot;&gt;1.1. G&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference &lt;strong&gt;for the universal quantifier&lt;/strong&gt;å…¨ç§°é‡è¯.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/1.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;H&quot;&gt;1.2. H&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The rules of inference are modus ponens and generalization&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/2.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;The Deduction Ruleï¼š&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/3.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-è¯­æ³•ä¸è¯­ä¹‰</title>
    <link href="https://hejueyun.github.io/posts/ed4b45dd/"/>
    <id>https://hejueyun.github.io/posts/ed4b45dd/</id>
    <published>2022-02-15T23:57:35.000Z</published>
    <updated>2022-03-11T13:25:00.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="å¼•å…¥">1. å¼•å…¥</h2><p>å‘½é¢˜é€»è¾‘å¯¹äºç®—æœ¯ç­‰æ•°å­¦ç†è®ºçš„å½¢å¼åŒ–æ¥è¯´ï¼Œè¡¨ç°åŠ›å¹¶ä¸å……åˆ†ã€‚ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼ï¼Œå¦‚$x+2&gt;y-1$ï¼Œæ—¢ä¸æ˜¯çœŸçš„ï¼Œä¹Ÿä¸æ˜¯å‡çš„ã€‚</p><ol><li>å®ƒçš„çœŸå‡å–å†³äºå˜é‡xå’Œyçš„å€¼</li><li>æˆ‘ä»¬éœ€è¦å°†è¿ç®—ç¬¦+å’Œ-çš„å«ä¹‰å½¢å¼åŒ–ï¼Œä½œä¸ºå°†ä¸€å¯¹æ•°å­—æ˜ å°„ä¸ºä¸€ä¸ªæ•°å­—çš„å‡½æ•°</li><li>åƒ&gt;è¿™æ ·çš„å…³ç³»è¿ç®—ç¬¦å¿…é¡»è¢«å½¢å¼åŒ–ä¸ºå°†ä¸€å¯¹æ•°å­—æ˜ å°„ä¸ºçœŸå€¼</li></ol><h2 id="å‘½é¢˜é€»è¾‘vsä¸€é˜¶é€»è¾‘">2. å‘½é¢˜é€»è¾‘vsä¸€é˜¶é€»è¾‘</h2><ol><li><p>å‘½é¢˜é€»è¾‘ï¼ˆPropositional Logicï¼‰ </p><ol><li>å½¢å¦‚ Â¬Pï¼ŒPâˆ§Qï¼ŒPâˆ¨Qï¼ŒP â†’ Q ï¼ŒPâ†”Qçš„è¯­å¥ï¼Œå€¼ä¸ºTrueæˆ–è€…False</li><li>æ¨ç†è§„åˆ™è¾ƒç®€å•ï¼Œå¾€å¾€é€šè¿‡ï¼ˆ1.çœŸå€¼è¡¨  2.ä¸ºæ•°ä¸å¤šçš„æ¨ç†è§„åˆ™ï¼Œä¾‹å¦‚Modus ponesnç­‰å‡ ä¸ªï¼‰</li><li>ç¼ºç‚¹ï¼šä¸èƒ½æˆ–è€…å¾ˆéš¾è¡¨ç¤ºå¤æ‚çš„è¯­å¥ï¼Œä¸èƒ½è®°å½•æ¨ç†è¿‡ç¨‹ä¸­çš„å˜åŒ–</li></ol></li><li><p>ä¸€é˜¶é€»è¾‘ï¼ˆFirst Order Logicï¼‰ï¼Œç®€ç§°FOL</p><ol><li>åŒ…å«çš„ä¸œè¥¿æœ‰å¸¸é‡ï¼ˆConstant symbolï¼‰ï¼Œè°“è¯ç¬¦å·ï¼ˆPredicate symbolï¼‰ï¼Œå‡½æ•°ç¬¦å·ï¼ˆFunction symbolï¼‰ï¼Œå˜é‡ï¼ˆVariableï¼‰ï¼Œè¿è¯ï¼ˆ âˆ§âˆ¨â†’â†”ï¼‰ï¼Œé‡è¯ï¼ˆQuantifiers, âˆƒâˆ€ï¼‰</li></ol></li><li><p>å‘½é¢˜é€»è¾‘(å¾ˆå°‘éƒ¨åˆ†äººå«å®ƒä½œé›¶é˜¶é€»è¾‘). åœ¨å‘½é¢˜é€»è¾‘é‡Œ, æ¯ä¸€ä¸ªå­—æ¯å°±ä»£è¡¨ä¸€ä¸ªå‘½é¢˜, æ‰€ä»¥å‘½é¢˜é€»è¾‘åªèƒ½è¡¨è¾¾å¥å­ä¹‹é—´çš„å…³ç³», æ¯”å¦‚â€œp&amp;qâ€, â€œif p then qâ€ç­‰ç­‰çš„çœŸå€¼å¦‚ä½•ä»på’Œqçš„çœŸå€¼ä¸­è®¡ç®—å‡ºæ¥.</p></li><li><p>ä¸€é˜¶é€»è¾‘åˆ™å¼•å…¥äº†ä¸¤ä¸ªé‡è¯, å³universal quantifier(å€’A)å’Œexistential quantifier(å€’E), å¹¶ä¸”åŠ å…¥äº†ä¸€é˜¶è°“è¯å’Œindividual variableså’Œindividual constants. è¿™äº›å¯¼è‡´ä¸€é˜¶é€»è¾‘å¯ä»¥é‡åŒ–individuals in the domain.</p><ol><li>æ¯”å¦‚ç»å…¸çš„ä¸‰æ®µè®ºå°±å¯ä»¥è¢«ä¸€é˜¶é€»è¾‘è¡¨è¾¾ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For all x, Hx-&gt;Mx</span><br><span class="line"></span><br><span class="line">Hs</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">Ms</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory">2.1. vs Propositional Logic vs Set Theory vs Elementary Number Theory</h3><p><strong>Propositional Logic</strong></p><ul><li><strong>Equality: no</strong></li><li>Predicate symbols: A1, A2, . . .</li><li><strong>Constant symbols: none</strong></li><li><strong>Function symbols: none</strong></li></ul><p><strong>Set Theory</strong></p><ul><li>Equality: yes</li><li>Predicate symbols: âˆˆ</li><li>Constant symbols: âˆ…</li><li>Function symbols: none</li></ul><p><strong>Elementary Number Theory</strong>åˆç­‰æ•°è®º</p><ul><li>Equality: yes</li><li>Predicate symbols: &lt;</li><li>Constant symbols: 0</li><li>Function symbols: S (successor), +, Ã—, exp</li></ul><h2 id="é›†åˆè®ºvsä¸€é˜¶é€»è¾‘">3. é›†åˆè®ºvsä¸€é˜¶é€»è¾‘</h2><ul><li>é›†åˆè®ºä½œä¸ºå…¬ç†ç³»ç»Ÿï¼Œä¸€é˜¶é€»è¾‘ä½œä¸º<strong>æ¨ç†ç³»ç»Ÿ</strong>ï¼Œå…±åŒä¸ºæ•°å­¦æ‰“ä¸‹åŸºçŸ³</li><li>è°ˆè®ºæŸä¸€ç†è®ºæ—¶ï¼Œéƒ½éœ€è¦æœ‰<strong>ä¸Šå±‚è¯­è¨€</strong>ï¼ˆmeta-languageï¼‰ä½œä¸ºåŸºç¡€ã€‚å¯¹äºæœ€ä¸Šå±‚çš„è¯­è¨€ç ”ç©¶ä¸€èˆ¬å½’äºå“²å­¦çš„èŒƒç•´<ul><li>åŸºäºä¸Šå±‚è¯­è¨€ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰<strong>ä¸€é˜¶è¯­è¨€</strong>ï¼ˆä¸€é˜¶é€»è¾‘çš„è¯­è¨€ï¼‰ï¼Œè¯­è¨€ä¸­å­—æ¯è¡¨ã€é¡¹ã€å…¬å¼çš„ä¸åŒå¯ä»¥äº§ç”Ÿä¸åŒçš„â€œå­è¯­è¨€â€ã€‚å¦‚ï¼šåˆç­‰ç®—æœ¯è¯­è¨€ï¼Œç¾¤è®ºè¯­è¨€ï¼Œ<strong>é›†åˆè®ºè¯­è¨€</strong></li><li>å®šä¹‰ä¸€é˜¶è¯­è¨€çš„æ¨¡å‹ï¼Œæ¨¡å‹å¯¹è¯­è¨€åšå‡ºè§£é‡Šï¼ˆå¯ä»¥çœ‹æˆæ˜¯<strong>è¯­ä¹‰</strong>éƒ¨åˆ†ï¼‰ã€‚è­¬å¦‚å¯¹äºåˆç­‰ç®—æœ¯è¯­è¨€ï¼Œæœ‰åˆç­‰ç®—æœ¯çš„æ ‡å‡†æ¨¡å‹</li><li>ä¸€é˜¶è¯­è¨€çš„æ¨ç†ç³»ç»Ÿç»™å‡ºäº†ä¸€é˜¶é€»è¾‘çš„è¯­æ³•ã€‚ä¸åŒçš„æ¨ç†ç³»ç»Ÿå¦‚è‡ªç„¶æ¨ç†ç³»ç»Ÿå’Œ PK æ¨ç†ç³»ç»Ÿå¯ä»¥è¯æ˜æ˜¯ç­‰ä»·çš„ã€‚åŒæ—¶æ³¨æ„åˆ°ï¼Œæ¨ç†ç³»ç»Ÿå¯ä»¥ç‹¬ç«‹äºæ¨¡å‹ï¼ˆ<strong>è¯­ä¹‰</strong>ï¼‰è€Œå­˜åœ¨ã€‚è€Œæ¨ç†ç³»ç»Ÿçš„ soundness å’Œ completeness ä¿è¯äº†è¯­ä¹‰ä¸è¯­æ³•çš„ä¸€è‡´æ€§</li></ul></li><li>åŒé˜¶ä¸‹ï¼Œä¸€é˜¶è¯­è¨€çš„é›†åˆè®ºæ˜¯ä¸€é˜¶é€»è¾‘çš„ä¸€éƒ¨åˆ†ï¼ˆä¸€é˜¶è¯­è¨€+å…¬å¼é›†ï¼‰ï¼Œä½†ä¸€é˜¶é€»è¾‘åˆä¸èƒ½è¡¨è¾¾æ‰€æœ‰çš„é›†åˆè®ºï¼ˆé«˜é˜¶ï¼‰</li></ul><h2 id="Syntax">4. Syntax</h2><p><strong>Logical Symbols</strong></p><ul><li>Parentheses: (, )</li><li>Propositional connectives: Â¬, âˆ¨, âˆ§, â†’, â†”</li><li>Variables: v1, v2, . . .</li><li>Quantifiers: âˆ€, âˆƒ<ul><li>Quantifiers allow a purely syntactical expression of the statement that the relation represented by a predicate is true for some or all elements of the domain</li><li>é‡è¯å…è®¸ä»¥çº¯è¯­æ³•çš„æ–¹å¼æ¥è¡¨è¾¾è°“è¯æ‰€ä»£è¡¨çš„å…³ç³»å¯¹åŸŸä¸­çš„æŸäº›æˆ–æ‰€æœ‰å…ƒç´ æ¥è¯´æ˜¯çœŸçš„</li></ul></li></ul><p><strong>Parameters</strong></p><ul><li>Equality symbol (optional): &#x3D;</li><li>Predicateè°“è¯ symbols: e.g. p(x), x &gt; y</li><li>Constant symbols: e.g. 0, John, Ï€</li><li>Function symbols: e.g. f(x), x + y, x +[2] y</li></ul><p><strong>æ³¨æ„</strong></p><ul><li>å¤§å†™Pã€Qã€Rç­‰é»˜è®¤ä½predicate</li><li>å°å†™pã€qã€ræ‰æ˜¯å‡½æ•°</li><li>é+predicateæœ‰æ„ä¹‰ï¼Œä½†é+å‡½æ•°æ²¡æœ‰æ„ä¹‰</li></ul><h3 id="Predicate-è°“è¯">4.1. Predicate è°“è¯</h3><ul><li>Predicates are used to represent <strong>functions</strong> from a domain to truth values<ul><li><strong>è°“è¯</strong>è¢«ç”¨æ¥è¡¨ç¤ºä»åŸŸåˆ°çœŸå€¼çš„<strong>å‡½æ•°</strong></li><li>$p^n$ is called an n-ary predicate</li></ul></li></ul><h3 id="Quantifier-é‡è¯">4.2. Quantifier é‡è¯</h3><ul><li>âˆ€ is the universal quantifier and is read <strong>for all</strong>.</li><li>âˆƒ is the existential quantifier and is read <strong>there exists</strong></li><li>A universal or existential formula âˆ€xA or âˆƒxA is a <strong>quantified formula</strong></li><li>In many presentations of first-order logic, âˆ€ is defined in the logic and âˆƒ is considered to be an abbreviation of Â¬â€‰âˆ€Â¬</li></ul><h3 id="æ–­è¨€ç¬¦å·ï¼Ÿ">4.3. æ–­è¨€ç¬¦å·ï¼Ÿ</h3><p>æ–­è¨€æ˜¯å®¹è®¸ä¸€ä¸ªã€ç”šè‡³å¤šä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥å¯¹äºè‡ªç„¶æ•° $n,j$ æˆ‘ä»¬çº¦å®š $A_{j}^{n}(x_1,x_2,â€¦,x_n)$ ä¸ºä¸€é˜¶é€»è¾‘çš„<strong>åˆæ³•è¯æ±‡</strong>ï¼Œå®ƒåœ¨ç›´è§‚ä¸Šè¡¨ç¤ºä¸€ä¸ªæœ‰ ${\displaystyle{} n}$ ä¸ªâ€å¯¹è±¡â€çš„æ–­è¨€ï¼Œæˆ‘ä»¬ç§°å®ƒä¸º ${\displaystyle{} n}$ å…ƒæ–­è¨€ç¬¦å·ã€‚ä¸‹æ ‡çš„è‡ªç„¶æ•° ${\displaystyle{} j}$ åªæ˜¯æ‹¿æ¥å’Œå…¶ä»–åŒä¸º ${\displaystyle{} n}$ å…ƒçš„æ–­è¨€ç¬¦å·ä½œåŒºåˆ«</p><h3 id="signature-æ ‡è¯†">4.4. signature æ ‡è¯†</h3><ul><li><p>åœ¨ä¸€é˜¶é€»è¾‘ä¸­çš„æ ‡è¯†(signature)ä¸ºåŒ…å«å‡½æ•°å¸¸æ•°(function constants)å’Œè°“è¯å¸¸æ•°(predicate constants)ä¿©ç§å…ƒç´ çš„ä¸€ä¸ªé›†åˆ</p></li><li><p>ä¾‹å¦‚ï¼š$Î£ &#x3D; (F, P) &#x3D; ({ a_1,â€¦,a_n, f_1,â€¦, f_k } , { \simeq{}&#x2F;2, P_1,â€¦, P_m } )$</p></li></ul><h3 id="arity-å…ƒæ•°">4.5. arity å…ƒæ•°</h3><blockquote><p>å‡½æ•°æˆ–è¿ç®—çš„å…ƒæ•°æ˜¯æŒ‡æ‰€éœ€çš„å‚æ•°æˆ–ç®—å­çš„æ•°é‡ã€‚å…³ç³»çš„å…ƒæ•°åˆ™æ˜¯æŒ‡å…¶å¯¹åº”ä¹‹ç¬›å¡å„¿ç§¯çš„ç»´åº¦</p></blockquote><ul><li>ä¸€å…ƒunaryå‡½æ•°ã€äºŒå…ƒâ€¦</li><li>Equality is a special predicate symbol of arity 2.</li><li>Constant symbols can also be thought of as functions whose arity is 0.</li></ul><h2 id="Formula">5. Formula</h2><ul><li><del>æœ¬è´¨ä¸Šæ˜¯nå…ƒå…³ç³»</del></li><li>å‡½æ•°ä¸æ˜¯</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/3.gif" width="550"></center><h3 id="Atomic-Formulas-åŸå­å…¬å¼">5.1. Atomic Formulas åŸå­å…¬å¼</h3><ul><li>An atomic formula is an expression of the form: $P(t_1, . . . , t_n)$ here P is a predicate symbol of arity n and $t_1,. . . ,t_n$ are terms.</li><li>If the language includes the equality symbol, we consider the equality symbol to be a special predicate of arity 2</li></ul><h3 id="Well-formed-Formulas-åˆå¼å…¬å¼">5.2. Well-formed Formulas åˆå¼å…¬å¼</h3><ul><li>The set of well-formed formulas is the set of expressions generated from the <strong>atomic</strong> formulas by the operations EÂ¬, Eâ†’, and $Q_{i}i$ &#x3D; 1, 2, . . .</li></ul><ol><li>åŸå­å…¬å¼ä¸ºå…¬å¼ã€‚(ç¾è§‚èµ·è§ï¼Œåœ¨åŸå­å…¬å¼å¤–é¢åŒ…ä¸€å±‚æ‹¬å¼§ä¹Ÿæ˜¯å…¬å¼)</li><li>è‹¥ ${\displaystyle {\mathcal {A}}}$ ä¸ºå…¬å¼ï¼Œåˆ™ (${\displaystyle (\neg {\mathcal {A}})}$ ä¸ºå…¬å¼ã€‚</li><li>è‹¥ ${\displaystyle {\mathcal {A}}}$ ä¸ ${\displaystyle {\mathcal {B}}}$ ä¸ºå…¬å¼ï¼Œåˆ™ ${\displaystyle ({\mathcal {A}}\Rightarrow {\mathcal {B}})}$ ä¸ºå…¬å¼ã€‚</li><li>è‹¥ ${\displaystyle {\mathcal {A}}}$ ä¸ºå…¬å¼ï¼Œ ${\displaystyle x}$ ä¸ºä»»æ„å˜é‡ï¼Œåˆ™ ${\displaystyle (\forall x{\mathcal {A}})}$ ä¸ºå…¬å¼ã€‚ (ç¾è§‚èµ·è§ ${\displaystyle (\forall x){\mathcal {A}}:&#x3D;\forall x{\mathcal {A}}}$ ï¼Œä¹Ÿå°±æ˜¯é‡Œé¢çš„é‡è¯æœ‰æ— å¤–åŒ…æ‹¬å¼§éƒ½æ˜¯å…¬å¼)<br>åˆå¼å…¬å¼åªèƒ½é€è¿‡ä»¥ä¸Šå››ç‚¹ï¼Œäºæœ‰é™æ­¥éª¤å†…ç½®æ„å‡ºæ¥</li></ol><h3 id="quantified-formula-é‡åŒ–å…¬å¼">5.3. quantified formula é‡åŒ–å…¬å¼</h3><ul><li>A universal or existential formula âˆ€xA or âˆƒxA is a quantified formula. </li><li>x is the quantified variable and its scope is the formula A. </li><li>It is not required that x actually appear in the scope of its quantification.</li></ul><hr><ul><li>If a formula has no free variables, it is <strong>closed</strong>. If ${x_1,â€¦,x_n}$ are all the free variables of A, the universal closure of A is $âˆ€x_1 â€¦âˆ€x_n$ A and the existential closure is $âˆƒx_1â€¦âˆƒx_n$ A.</li></ul><p><strong>Example</strong></p><ol><li>p(x,y) has two free variables x and y, âˆƒyp(x,y) has one free variable x and âˆ€xâˆƒyp(x,y) is closed. The universal closure of p(x,y) is âˆ€xâˆ€yp(x,y) and its existential closure is âˆƒxâˆƒyp(x,y).</li><li>In $âˆ€xp(x)âˆ§q(x)$, the occurrence of x in $p(x)$ is bound and <strong>the occurrence in $q(x)$ is free</strong>. The universal closure is $âˆ€x(âˆ€xp(x)âˆ§q(x))$. <ol><li>Obviously, it would have been better to write the formula as $âˆ€xp(x)âˆ§q(y)$ with y as the free variable; its universal closure is âˆ€y(âˆ€xp(x)âˆ§q(y)) </li><li>è¿™ä¸ªå…¶å®å°±æ˜¯æŠŠ$âˆ€xp(x)$ç®€å†™äº†ï¼Œå®é™…åº”è¯¥å°±æ˜¯$âˆ€x(p(x))$ï¼Œé‡è¯åç´§è·Ÿçš„å°±æ˜¯ä½œç”¨åŸŸ(<strong>scope</strong>)</li></ol></li></ol><h4 id="Free-and-Bound-Variables-è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡">5.3.1. Free and Bound Variables è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡</h4><p>é‡è¯æ‰€æ–½ç”¨çš„<strong>å…¬å¼</strong>è¢«ç§°ä¸º**é‡è¯çš„èŒƒå›´(scope)**ã€‚è‹¥å˜é‡ ${\displaystyle x}$ æŸæ¬¡å‡ºç°åœ¨ ${\displaystyle \forall x}$ çš„èŒƒå›´å†…ï¼Œç§°è¿™æ ·å‡ºç°çš„ ${\displaystyle x}$ ä¸ºä¸è‡ªç”±&#x2F;è¢«çº¦æŸçš„ ${\displaystyle x}$ (not free&#x2F;bounded)ï¼›åè¿‡æ¥è¯´ï¼Œä¸å‡ºç°åœ¨ ${\displaystyle \forall x}$ çš„èŒƒå›´å†…çš„æŸä¸ª ${\displaystyle x}$ è¢«ç§°ä¸ºè‡ªç”±çš„ ${\displaystyle x}$ï¼Œï¼ˆ<code>âˆƒ</code>åŒç†ï¼‰</p><center><img loading="lazy" src="/posts/ed4b45dd/2.png" width="550"></center><ul><li>ï¼ˆå°é—­å…¬å¼ã€å¥å­ï¼‰If no variable occurs free in a $wff x$, then $x$ is a sentence</li></ul><hr><ul><li>If Î± is an <strong>atomic formula</strong>, then <ul><li>x occurs free in Î± iff x occurs in Î±.</li><li>x occurs free in (Â¬Î±) iff x occurs free in Î±.</li><li>x occurs free in (Î± â†’ Î²) iff x occurs free in Î± or in Î².</li><li>x occurs free in âˆ€ $v_i$ Î± iff x occurs free in Î± and $x\neq{v_i}$</li></ul></li></ul><h3 id="ground-formula-åŸºæ€å…¬å¼">5.4. ground formula åŸºæ€å…¬å¼</h3><ul><li>A <strong>ground term</strong> is a term which <strong>does not contain any variables</strong>.</li><li>A <strong>ground atomic formula</strong> is an atomic formula, all of whose terms are ground.</li><li>A <strong>ground literal</strong> is a ground atomic formula or the negation of one.</li><li>A <strong>ground formula</strong> is a <strong>quantifier-free</strong> formula, all of whose <strong>atomic formula are ground</strong>.</li><li>A is a ground instance of a quantifier-free formula Aâ€² iff it can be obtained from Aâ€² by substituting ground terms for the (free) variables in Aâ€²</li></ul><blockquote><p>The terms a, f(a,b), g(b,f(a,b)) are ground. p(f(a,b),a) is a ground atomic formula and Â¬â€‰p(f(a,b),a) is a ground literal. p(f(x,y),a) is not a ground atomic formula because of the variables x,y</p></blockquote><h2 id="Semantic-Interpretation">6. Semantic: Interpretation</h2><ul><li>In propositional logic, the truth of a formula was determined by a truth assignment over the propositional symbols.</li><li>In first-order logic, we use a <strong>model</strong> (also called a <strong>structure</strong>) to determine the truth of a formula</li></ul><hr><ul><li>In propositional logic, an interpretation is a mapping from atomic propositions to truth values. </li><li>In first-order logic, the analogous concept is a mapping from atomic formulas to truth values.<ul><li>However, atomic formulas contain variables and constants that must be assigned elements of some domain; once that is done, the <strong>predicates</strong> are interpreted as <strong>relations</strong> over the domain.ï¼ˆæ¯”å¦‚å¤§äºå°äºå…³ç³»ï¼‰</li></ul></li></ul><center><img loading="lazy" src="/posts/ed4b45dd/4.png" width="550"></center><h3 id="assignment">6.1. assignment</h3><center><img loading="lazy" src="/posts/ed4b45dd/5.jpg" width="550"></center><h3 id="Closed-Formula-é—­å…¬å¼">6.2. Closed Formula é—­å…¬å¼</h3><p>Validity and Satisfiability</p><ul><li>Let A be a closed formula of first-order logic<ul><li>A is true in I or I is a <strong>model</strong> for A iff $v_I(A)&#x3D;T$ . Notation: IâŠ§A.</li><li>A is valid if for all interpretations I, IâŠ§A. Notation: âŠ¨A</li><li>A is satisfiable if for some interpretation I, IâŠ§A.</li><li>A is unsatisfiable if it is not satisfiable.</li><li>A is falsifiable if it is not valid</li></ul></li></ul><p>$âˆ€xâˆ€y(p(x,y)â†’p(y,x))$</p><ul><li>The formula is satisfiable in an interpretation where p is assigned a symmetric relation like &#x3D;. It is not valid because the formula is falsified in an interpretation that assigns to p a non-symmetric relation like &lt;</li></ul><h3 id="An-Interpretation-for-a-Set-of-Formulas">6.3. An Interpretation for a Set of Formulas</h3><blockquote><p>In propositional logic, the concept of interpretation and the definition of properties such as satisfiability can be extended to sets of formulas. The same holds for first-order logic</p></blockquote><ul><li>Let U&#x3D;{A 1,â€¦} be a set of formulas where {p 1,â€¦,p m } are all the predicates appearing in all A i âˆˆS and {a 1,â€¦,a k } are all the constants appearing in all A i âˆˆS. An interpretation $I_v$ for S is as triple:<ul><li>${D,{R_1,â€¦R_n},{d_1,â€¦d_n}}$</li></ul></li><li>where D is a non-empty set called the domain, R i is an $n_i$-ary relation on D that is assigned to the $n_i$-ary predicate p i and d i âˆˆD is an element of D that is assigned to the constant a i</li></ul><h2 id="Logical-Equivalence">7. Logical Equivalence</h2><ul><li>Let U&#x3D;{A 1,A 2} be a pair of <strong>closed formulas</strong>. A 1 is logically equivalent to A 2 iff $v_{I_{U}}(A_1)&#x3D;v_{I_{U}}(A_2)$ for all interpretations . Notation: $A_1â‰¡A_2$</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/6.jpg" width="550"></center><p>å¯¹ç­‰dualityå…¬å¼</p><ul><li><p>ç”¨äºå…¬å¼åŒ–ç®€å’Œè½¬åŒ–ä¸ºèŒƒå¼</p></li><li><p>Â¬âˆ€x.A â‰¡ âˆƒx.Â¬A</p></li><li><p>Â¬âˆƒx.A â‰¡ âˆ€x.Â¬A</p></li></ul><center><img loading="lazy" src="/posts/ed4b45dd/7.jpg" width="550"></center><center><img loading="lazy" src="/posts/ed4b45dd/8.jpg" width="550"></center><ul><li>Theorem (Equivalent Replacement Theorem)<ul><li>Suppose A, B, C are first-order formulas and A is a subformula of C</li><li>If A â‰¡ B, then C(. . . A . . .) â‰¡ C(. . . B . . .)</li></ul></li></ul><h2 id="è¯­ä¹‰è¡¨">8. è¯­ä¹‰è¡¨</h2><blockquote><p>è¯­ä¹‰è¡¨çš„æ–¹æ³•å¯¹äºæ˜¾ç¤ºä¸€ä¸ªå…¬å¼æ˜¯ä¸å¯æ»¡è¶³çš„æ¥è¯´æ˜¯åˆç†å’Œå®Œæ•´çš„ï¼Œä½†æ˜¯å®ƒä¸æ˜¯ä¸€ä¸ªå¯æ»¡è¶³æ€§çš„å†³å®šç¨‹åºï¼Œå› ä¸ºè¡¨çš„åˆ†æ”¯å¯èƒ½æ˜¯æ— é™çš„ã€‚å½“ä¸€ä¸ªtableauè¢«æ„é€ å‡ºæ¥æ—¶ï¼Œä¸€ä¸ªæ™®éé‡è¯åé¢è·Ÿç€ä¸€ä¸ªå­˜åœ¨é‡è¯å¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªæ— é™çš„åˆ†æ”¯ï¼šå­˜åœ¨å…¬å¼è¢«ç”¨ä¸€ä¸ªæ–°çš„å¸¸æ•°å®ä¾‹åŒ–ï¼Œç„¶åæ™®éå…¬å¼çš„å®ä¾‹åŒ–ä¼šå¯¼è‡´ä¸€ä¸ªæ–°çš„å­˜åœ¨é‡è¯å…¬å¼çš„å‡ºç°ï¼Œå¦‚æ­¤æ— é™åœ°ä¸‹å»ã€‚æœ‰ä¸€äº›å…¬å¼åªåœ¨æ— é™åŸŸä¸­æ˜¯å¯æ»¡è¶³çš„ã€‚</p></blockquote><h2 id="å‚è€ƒ">9. å‚è€ƒ</h2><ul><li><a href="https://www.zhihu.com/question/40419871/answer/127792613">å‘½é¢˜é€»è¾‘å’Œä¸€é˜¶é€»è¾‘åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ - å˜‰å˜‰æ¨çš„å›ç­” - çŸ¥ä¹</a></li><li><a href="https://www.zhihu.com/question/22915503/answer/151477106">ä¸€é˜¶é€»è¾‘å’Œé«˜é˜¶é€»è¾‘çš„åŒºåˆ«ï¼Œèƒ½ä¸èƒ½å…·è±¡ä¸€ç‚¹è¯´æ˜ï¼Ÿ - ZS Chençš„å›ç­” - çŸ¥ä¹</a></li><li><a href="https://www.zhihu.com/question/28776730/answer/702538400">é›†åˆè®ºå’Œä¸€é˜¶é€»è¾‘çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ - Zangwei Zhengçš„å›ç­” - çŸ¥ä¹</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;å¼•å…¥&quot;&gt;1. å¼•å…¥&lt;/h2&gt;&lt;p&gt;å‘½é¢˜é€»è¾‘å¯¹äºç®—æœ¯ç­‰æ•°å­¦ç†è®ºçš„å½¢å¼åŒ–æ¥è¯´ï¼Œè¡¨ç°åŠ›å¹¶ä¸å……åˆ†ã€‚ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼ï¼Œå¦‚$x+2&amp;gt;y-1$ï¼Œæ—¢ä¸æ˜¯çœŸçš„ï¼Œä¹Ÿä¸æ˜¯å‡çš„ã€‚&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;å®ƒçš„çœŸå‡å–å†³äºå˜é‡xå’Œyçš„å€¼&lt;/li&gt;
&lt;li&gt;æˆ‘ä»¬éœ€è¦å°†è¿ç®—ç¬¦+å’Œ-çš„å«ä¹‰å½¢å¼åŒ–ï¼Œä½œä¸ºå°†ä¸€å¯¹æ•°å­—æ˜ å°„ä¸ºä¸€ä¸ªæ•°å­—çš„å‡½æ•°&lt;/li&gt;
&lt;li&gt;åƒ&amp;gt;è¿™æ ·çš„å…³ç³»è¿ç®—ç¬¦å¿…é¡»è¢«å½¢å¼åŒ–ä¸ºå°†ä¸€å¯¹æ•°å­—æ˜ å°„ä¸ºçœŸå€¼&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;å‘½é¢˜é€»è¾‘vsä¸€é˜¶é€»è¾‘&quot;&gt;2. å‘½é¢˜é€»è¾‘vsä¸€é˜¶é€»è¾‘&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;å‘½é¢˜é€»è¾‘ï¼ˆPropositional Logicï¼‰ &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;å½¢å¦‚ Â¬Pï¼ŒPâˆ§Qï¼ŒPâˆ¨Qï¼ŒP â†’ Q ï¼ŒPâ†”Qçš„è¯­å¥ï¼Œå€¼ä¸ºTrueæˆ–è€…False&lt;/li&gt;
&lt;li&gt;æ¨ç†è§„åˆ™è¾ƒç®€å•ï¼Œå¾€å¾€é€šè¿‡ï¼ˆ1.çœŸå€¼è¡¨  2.ä¸ºæ•°ä¸å¤šçš„æ¨ç†è§„åˆ™ï¼Œä¾‹å¦‚Modus ponesnç­‰å‡ ä¸ªï¼‰&lt;/li&gt;
&lt;li&gt;ç¼ºç‚¹ï¼šä¸èƒ½æˆ–è€…å¾ˆéš¾è¡¨ç¤ºå¤æ‚çš„è¯­å¥ï¼Œä¸èƒ½è®°å½•æ¨ç†è¿‡ç¨‹ä¸­çš„å˜åŒ–&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ä¸€é˜¶é€»è¾‘ï¼ˆFirst Order Logicï¼‰ï¼Œç®€ç§°FOL&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;åŒ…å«çš„ä¸œè¥¿æœ‰å¸¸é‡ï¼ˆConstant symbolï¼‰ï¼Œè°“è¯ç¬¦å·ï¼ˆPredicate symbolï¼‰ï¼Œå‡½æ•°ç¬¦å·ï¼ˆFunction symbolï¼‰ï¼Œå˜é‡ï¼ˆVariableï¼‰ï¼Œè¿è¯ï¼ˆ âˆ§âˆ¨â†’â†”ï¼‰ï¼Œé‡è¯ï¼ˆQuantifiers, âˆƒâˆ€ï¼‰&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;å‘½é¢˜é€»è¾‘(å¾ˆå°‘éƒ¨åˆ†äººå«å®ƒä½œé›¶é˜¶é€»è¾‘). åœ¨å‘½é¢˜é€»è¾‘é‡Œ, æ¯ä¸€ä¸ªå­—æ¯å°±ä»£è¡¨ä¸€ä¸ªå‘½é¢˜, æ‰€ä»¥å‘½é¢˜é€»è¾‘åªèƒ½è¡¨è¾¾å¥å­ä¹‹é—´çš„å…³ç³», æ¯”å¦‚â€œp&amp;amp;qâ€, â€œif p then qâ€ç­‰ç­‰çš„çœŸå€¼å¦‚ä½•ä»på’Œqçš„çœŸå€¼ä¸­è®¡ç®—å‡ºæ¥.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ä¸€é˜¶é€»è¾‘åˆ™å¼•å…¥äº†ä¸¤ä¸ªé‡è¯, å³universal quantifier(å€’A)å’Œexistential quantifier(å€’E), å¹¶ä¸”åŠ å…¥äº†ä¸€é˜¶è°“è¯å’Œindividual variableså’Œindividual constants. è¿™äº›å¯¼è‡´ä¸€é˜¶é€»è¾‘å¯ä»¥é‡åŒ–individuals in the domain.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;æ¯”å¦‚ç»å…¸çš„ä¸‰æ®µè®ºå°±å¯ä»¥è¢«ä¸€é˜¶é€»è¾‘è¡¨è¾¾ &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For all x, Hx-&amp;gt;Mx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ms&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory&quot;&gt;2.1. vs Propositional Logic vs Set Theory vs Elementary Number Theory&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Propositional Logic&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Equality: no&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Predicate symbols: A1, A2, . . .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constant symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Set Theory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Equality: yes&lt;/li&gt;
&lt;li&gt;Predicate symbols: âˆˆ&lt;/li&gt;
&lt;li&gt;Constant symbols: âˆ…&lt;/li&gt;
&lt;li&gt;Function symbols: none&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-å‘½é¢˜é€»è¾‘-SAT</title>
    <link href="https://hejueyun.github.io/posts/f363d9fd/"/>
    <id>https://hejueyun.github.io/posts/f363d9fd/</id>
    <published>2022-02-15T17:31:21.000Z</published>
    <updated>2022-02-21T16:22:07.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SAT-å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜">1. SAT å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜</h2><blockquote><p>å¯æ»¡è¶³æ€§ï¼ˆè‹±è¯­ï¼šSatisfiabilityï¼‰æ˜¯ç”¨æ¥è§£å†³ç»™å®šçš„çœŸå€¼æ–¹ç¨‹å¼ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ç»„å˜é‡èµ‹å€¼ï¼Œä½¿é—®é¢˜ä¸ºå¯æ»¡è¶³ã€‚å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ï¼ˆBoolean satisfiability problemï¼›SAT ï¼‰å±äº<strong>å†³å®šæ€§é—®é¢˜</strong>ï¼Œä¹Ÿæ˜¯ç¬¬ä¸€ä¸ªè¢«è¯æ˜å±äº<strong>NPå®Œå…¨</strong>çš„é—®é¢˜</p><p>å†³å®šæ€§é—®é¢˜ï¼Œäº¦ç§°åˆ¤å®šé—®é¢˜ï¼Œï¼ˆè‹±è¯­ï¼šDecision problemï¼‰æ˜¯ä¸€ä¸ªåœ¨æŸäº›å½¢å¼ç³»ç»Ÿå›ç­”â€œæ˜¯â€æˆ–â€œå¦â€çš„é—®é¢˜</p></blockquote><h2 id="Properties-of-Clausal-Form">2. Properties of Clausal Form</h2><blockquote><p>A computer program that searches for a model for a propositional formula is called a SAT Solver. </p></blockquote><blockquote><p>Let S, Sâ€² be sets of clauses. </p><ul><li>Sâ‰ˆSâ€² denotes that S is satisfiable if and only if Sâ€² is satisfiable.â€ƒ</li><li>It is important to understand that Sâ‰ˆSâ€² does not imply that Sâ‰¡Sâ€² (S is <strong>logically equivalent</strong> to Sâ€²)</li></ul></blockquote><center><img loading="lazy" src="/posts/f363d9fd/1.jpg" width="550"></center><h3 id="Pure-Literals">2.1. Pure Literals</h3><blockquote><p>Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S</p><p>Let S be a set of clauses and let l be a pure literal in S. Let Sâ€² be obtained from S by deleting every clause containing l. Then Sâ‰ˆSâ€²</p><ul><li>ä¹Ÿå°±æ˜¯åˆ é™¤çº¯æ–‡å­—ä¸å½±å“åŠå¥å…¨æ€§çš„ä¼ é€’</li></ul></blockquote><h3 id="Unit-Clauses">2.2. Unit Clauses</h3><blockquote><p>Let {l}âˆˆS be a unit clause and let Sâ€² be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then Sâ‰ˆSâ€².</p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/2.jpg" width="550"></center><h3 id="Empte-Clauses">2.3. Empte Clauses</h3><ul><li>â–¡ is unsatisfiable<ul><li>æ ¹æ®Unit Clausesçš„å®šç†æ˜¾ç„¶</li></ul></li></ul><h3 id="Renaming">2.4. Renaming</h3><blockquote><p>Let $S$ be a set of clauses and $U$ a set of atomic propositions. $R_U(S)$, the renaming of S by U, is obtained from S by replacing each literal l on an atomic proposition in U by $l^c$ </p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/3.jpg" width="550"></center><h2 id="Davis-Putnam-Algorithm-æˆ´ç»´æ–¯â€“æ™®ç‰¹å—ç®—æ³•">3. Davis-Putnam Algorithm æˆ´ç»´æ–¯â€“æ™®ç‰¹å—ç®—æ³•</h2><blockquote><p>The Davis-Putnam (DP) algorithm was one of the first algorithms proposed for deciding satisfiability</p><p>æˆ´ç»´æ–¯-æ™®ç‰¹å—ï¼ˆDPï¼‰ç®—æ³•æ˜¯æœ€æ—©æå‡ºçš„ç”¨äº<strong>å†³å®šå¯æ»¡è¶³æ€§</strong>çš„ç®—æ³•ä¹‹ä¸€</p></blockquote><ul><li><p>Input: A formula A in clausal form.</p></li><li><p>Output: Report that A is satisfiable or unsatisfiable.</p></li><li><p>Perform the following rules <strong>repeatedly</strong>, but the third rule is used only if the first two do not apply</p><ul><li>Unit-literal rule <blockquote><p>If there is a unit clause {l}, delete <strong>all clauses</strong> containing l and delete <strong>all occurrences</strong> of $l^c$ from <strong>all other clauses</strong></p></blockquote></li><li>Pure-literal rule<blockquote><p>If there is a pure literal l, delete all clauses containing l</p></blockquote></li><li>Eliminate a variable by resolution:<blockquote><p>Choose an atom p and perform all possible resolutions on clauses that clash on $p$ and $\bar{p}$. Add these <strong>resolvents</strong>è§£æå™¨ to the set of clauses and then delete all clauses containing $p$ or $\bar{p}$</p></blockquote></li></ul></li><li><p>Terminate the algorithm under the following conditions:</p><ul><li>If empty clause <code>â–¡</code> is produced, report that the formula is unsatisfiable.</li><li>If no more rules are applicableé€‚ç”¨, report that the formula is satisfiable.</li></ul></li></ul><p><strong>Example</strong></p><ul><li>${p, \bar{p}q, \bar{q}r, \bar{r}st}$<blockquote><p>Performing the unit-literal rule on p leads to the creation of a new unit clause q upon which the rule can be applied again. This leads to a new unit clause r and applying the rule results in the singleton set of clauses {st}. Since no more rules are applicable, the set of clauses is satisfiable.</p></blockquote></li></ul><hr><blockquote><p>Repeatedly applying the unit-literal rule until it is no longer applicable is called <strong>unit propagation</strong> or <strong>Boolean constraint propagationï¼ˆBCPï¼‰</strong>. å•ä½ä¼ æ’­æˆ–å¸ƒå°”çº¦æŸä¼ æ’­</p></blockquote><h2 id="Davis-Putnam-Logemann-Loveland-DPLL">4. Davis-Putnam-Logemann-Loveland(DPLL)</h2><ul><li>DPLL is a <strong>decision procedure</strong> for propositional clausal logic</li></ul><p>è§£å†³ CNF-SAT é—®é¢˜</p><blockquote><p>ä¸€ä¸ªæœ´ç´ çš„å›æº¯ç®—æ³•ä¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„èµ‹å€¼ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªè§£ï¼›è€Œ DPLL ç®—æ³• åˆ™ä¼šåˆ©ç”¨ BCP æ¥åˆ æ‰ä¸€äº›ä¸å¯èƒ½æ»¡è¶³å…¬å¼çš„èµ‹å€¼ï¼Œç¼©å°æœç´¢æ ‘ã€‚å½“é‡åˆ°å†²çªæ—¶ï¼Œå®ƒä¼šå›æº¯åˆ°ä¸Šä¸€ä¸ªå¹¶éç”± BCP ä½œå‡ºçš„å†³å®šï¼Œé€‰æ‹©å¦ä¸€ç§å¯èƒ½çš„å€¼</p><hr><p>Creating all possible resolvents on an atom is very inefficient. The DPLL algorithm improves on the DP algorithm by replacing the variable elimination step with a search for a model of the formula</p><p>The DPLL algorithm recursively <strong>extends a partial interpretation</strong> by <strong>adding an assignment to some atom</strong> that has not yet been assigned a truth value. The current set of clauses is evaluated using the new partial interpretation and simplified by <strong>unit propagation</strong>. If the set of clauses contains a conflict clause, there is no need to continue extending this partial interpretation and the search <strong>backtracks</strong>é€’å½’å›æº¯ to try another one</p></blockquote><p>The DPLL algorithm can be summarized in the following pseudocode, where $Î¦$ is the <strong>CNF</strong> formula: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Algorithm DPLL</span><br><span class="line">    Input: A set of clauses Î¦.</span><br><span class="line">    Output: A truth value indicating whether Î¦ is satisfiable.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function DPLL(Î¦)</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a unit clause &#123;l&#125; <span class="keyword">in</span> Î¦ do</span><br><span class="line">        Î¦ â† unit-propagate(l, Î¦);</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a literal l that occurs pure <span class="keyword">in</span> Î¦ do</span><br><span class="line">        Î¦ â† pure-literal-assign(l, Î¦);</span><br><span class="line">    <span class="keyword">if</span> Î¦ <span class="keyword">is</span> empty then</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">if</span> Î¦ contains an empty clause then</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    l â† choose-literal(Î¦);</span><br><span class="line">    <span class="keyword">return</span> DPLL(Î¦ âˆ§ &#123;l&#125;) <span class="keyword">or</span> DPLL(Î¦ âˆ§ &#123;<span class="keyword">not</span>(l)&#125;);</span><br></pre></td></tr></table></figure><ul><li>â€œâ†â€ denotes assignment. For instance, â€œlargest â† itemâ€ means that the value of largest changes to the value of item.</li><li>When the formula contains an empty clause, the clause is vacuously false because a disjunction requires at least one member that is true for the overall set to be true</li></ul><hr><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/f363d9fd/4.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/6.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/5.jpg" width="650"></center><p><strong>ç®€åŒ–ç‰ˆè¡¨è¾¾</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DPLL:</span><br><span class="line">  Run BCP on the formula.</span><br><span class="line">  If the formula evaluates to <span class="literal">True</span>, <span class="keyword">return</span> <span class="literal">True</span>.</span><br><span class="line">  If the formula evaluates to <span class="literal">False</span>, <span class="keyword">return</span> <span class="literal">False</span>.</span><br><span class="line">  If the formula <span class="keyword">is</span> still Undecided:</span><br><span class="line">    Choose the <span class="built_in">next</span> unassigned variable.</span><br><span class="line">    Return (DPLL <span class="keyword">with</span> that variable <span class="literal">True</span>) || (DPLL <span class="keyword">with</span> that variable <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">DPLL:</span><br><span class="line">  åœ¨å…¬å¼ä¸Šæ‰§è¡Œ BCPã€‚</span><br><span class="line">  å¦‚æœå…¬å¼çš„å€¼ä¸€å®šä¸ºçœŸï¼Œè¿”å›çœŸã€‚</span><br><span class="line">  å¦‚æœå…¬å¼çš„å€¼ä¸€å®šä¸ºå‡ï¼Œè¿”å›å‡ã€‚</span><br><span class="line">  å¦‚æœå…¬å¼çš„å€¼ä»ä¸ç¡®å®š:</span><br><span class="line">    é€‰æ‹©ä¸‹ä¸€ä¸ªæœªå†³å®šçš„å­—é¢é‡</span><br><span class="line">    çŒœæµ‹è¯¥å­—é¢é‡ä¸ºçœŸï¼Œç„¶åæ‰§è¡Œ DPLL</span><br><span class="line">    å¦‚æœ DPLL çš„ç»“æœä¸ºçœŸï¼Œè¿”å›çœŸ</span><br><span class="line">    å¦åˆ™çŒœæµ‹è¯¥å­—é¢é‡ä¸ºå‡ï¼Œç„¶åæ‰§è¡Œ DPLL å¹¶è¿”å›ç»“æœ</span><br></pre></td></tr></table></figure><ul><li>æŸç§ç¨‹åº¦ä¸Šçœ‹ï¼ŒDDLP &#x3D; Unit Propagation + Decision</li></ul><hr><p><strong>ä¹¦é¢å†™æ³•</strong></p><center><img loading="lazy" src="/posts/f363d9fd/10.jpg" width="650"></center><blockquote><p>Unit Propagation is a <strong>polynomial-time</strong>å¤šé¡¹å¼æ—¶é—´ decision procedure for the <strong>fragment of Horn clauses</strong>.</p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/11.jpg" width="650"></center><ul><li>è¿™ä¹Ÿæ„å‘³ç€ddlpè¿˜è¦åŠ å…¥<strong>decide</strong>ï¼ˆä»¥åŠ<strong>backtrack</strong>é€’å½’å›æº¯ï¼‰ç¯èŠ‚ä½¿å¾—å…¶å¯ä»¥å…¨é¢è¦†ç›–æ‰€æœ‰ç±»å‹çš„å­å¥</li></ul><center><img loading="lazy" src="/posts/f363d9fd/12.jpg" width="650"></center><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/f363d9fd/13.png" width="650"></center><h2 id="Conflict-Driven-Clause-Learning-CDCL">5. Conflict Driven Clause Learning(CDCL)</h2><ul><li>CDCL&#x3D;DPLL + <strong>Backjumping</strong>åè·³ + <strong>Lemma Learning</strong>æ¨ç†å­¦ä¹ </li></ul><blockquote><p>DPLL æœ‰ä¸‰ä¸ªç¼ºç‚¹ã€‚é¦–å…ˆï¼Œå®ƒçš„å†³ç­–æ˜¯æœ´ç´ ï¼ˆnaiveï¼‰çš„ã€‚å…¶æ¬¡ï¼Œå®ƒé‡åˆ°å†²çªçš„æ—¶å€™ï¼ŒåªçŸ¥é“å½“å‰çš„éƒ¨åˆ†èµ‹å€¼ä¼šå¯¼è‡´å†²çªï¼Œé™¤æ­¤ä¹‹å¤–å­¦ä¸åˆ°ä»»ä½•ä¸œè¥¿ã€‚ç¬¬ä¸‰ï¼Œå®ƒæ¯æ¬¡åªä¼šå›æº¯ä¸€å±‚ï¼Œå› æ­¤ä¼šæŠŠå¤§é‡æ—¶é—´æµªè´¹åœ¨ä¸€ç‰‡å¿…å®šä¼šå¤±è´¥çš„æœç´¢ç©ºé—´ä¸­</p></blockquote><p><strong>å†²çªé©±åŠ¨å­å¥å­¦ä¹ </strong>çš„æ”¹è¿›ï¼š</p><ul><li>å†²çªæ¥æºçš„å­å¥å­¦ä¹ ï¼ˆclause learning from conflictsï¼‰</li><li>éæ—¶åºå›æº¯ï¼ˆnon-chronological<code>[ ËŒ krÉ”nÉ™&#39;lÉ”dÊ’ikÉ™l ]</code> backtrackingï¼‰</li></ul><center><img loading="lazy" src="/posts/f363d9fd/7.jpg" width="650"></center><ul><li>å½“CDCLå­¦ä¹ ä¸€ä¸ªå­å¥æ—¶ï¼Œå®ƒä¼šå›æº¯åˆ°è¯¥å­å¥çš„æ–­è¨€å±‚ã€‚ä½ å¯ä»¥è®¤ä¸ºè¿™æ„å‘³ç€å®ƒå›æº¯åˆ°å½±å“æ‰€å­¦å­å¥ä¸­æŸä¸€å­—é¢é‡çš„æœ€æ–°çŒœæµ‹ã€‚ç”±äºè¿™ä¸ªå­å¥æœ‰$x_1$å’Œ$x_5$ï¼Œè€Œx1æ˜¯è¯¥å­å¥ä¸­æœ€æ–°è¢«çŒœåˆ°çš„ä¸€ä¸ªï¼Œæ‰€ä»¥æˆ‘ä»¬å›æº¯åˆ°æˆ‘ä»¬å°†$x_1$è®¾ç½®ä¸ºTrueçš„æ—¶å€™</li></ul><center><img loading="lazy" src="/posts/f363d9fd/8.jpg" width="650"></center><h3 id="è•´å«å›¾">5.1. è•´å«å›¾</h3><ul><li>å½“ CDCL é‡åˆ°å†²çªæ—¶ï¼Œå®ƒä¼šæŸ¥çœ‹å·²ä½œå‡ºçš„æ¨æµ‹ï¼Œä»¥åŠä» BCP å¾—åˆ°ä¸”æœ€ç»ˆå¯¼è‡´å†²çªçš„é‚£äº›èµ‹å€¼ã€‚æˆ‘ä»¬æŠŠè¿™äº›æ¨æµ‹å’Œç”±å®ƒä»¬æ¨å‡ºçš„ç»“è®ºç”»æˆä¸€ä¸ªå›¾ï¼ˆgraphï¼‰ï¼Œç§°ä¸ºè•´æ¶µå›¾ï¼ˆimplication graphï¼‰</li></ul><blockquote><p>è•´å«å›¾æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ã€‚å®ƒçš„æ¯ä¸ªé¡¶ç‚¹ä»£è¡¨å¯¹ä¸€ä¸ªå˜é‡çš„èµ‹å€¼ï¼Œæ­¤å¤–è¿˜æœ‰ä¸€ä¸ªä»£è¡¨å†²çªçš„ç‰¹æ®Šé¡¶ç‚¹ã€‚å›¾ä¸­çš„è¾¹åˆ™è¡¨ç¤ºèµ‹å€¼æˆ–å†²çªçš„ç†ç”±ï¼›å…·ä½“æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå•ä½å­å¥ï¼Œå¹¶ç”±æ­¤æ¨å‡ºå­å¥ä¸­å”¯ä¸€çš„é‚£ä¸ªæœªçŸ¥å˜é‡çš„å€¼ï¼Œå°±å¯ä»¥ä»å­å¥ä¸­æ¯ä¸€ä¸ªå·²çŸ¥çš„å˜é‡å¯¹åº”çš„é¡¶ç‚¹è¿ä¸€æ¡è¾¹åˆ°è¿™ä¸ªæ–°æ¨å¯¼å‡ºçš„å˜é‡å¯¹åº”çš„é¡¶ç‚¹ï¼›æ¨å‡ºå†²çªçš„æƒ…å½¢ä¹Ÿç±»ä¼¼</p></blockquote><ul><li>ä¸€æ—¦ CDCL å­¦åˆ°äº†ä¸€ä¸ªå­å¥ï¼Œå®ƒå°±èƒ½å¤Ÿå›æº¯è¶…è¿‡ä¸€å±‚ï¼Œå¹¶æŠŠ BCP ç«‹å³åº”ç”¨åˆ°å­¦åˆ°çš„æ–°å­å¥ä¸Šã€‚è¿™ç§åˆ©ç”¨å­¦åˆ°çš„å­å¥å›æº¯å¤šå±‚çš„èƒ½åŠ›å°±æ˜¯æˆ‘ä»¬å‰é¢è¯´çš„éæ—¶é—´é¡ºåºå›æº¯ï¼ˆnon-chronological backtrackingï¼‰</li></ul><center><img loading="lazy" src="/posts/f363d9fd/9.jpg" width="650"></center><p><strong>clause learning step</strong>:</p><ol><li>c4 is the clause directly responsible for the current conflict. Our partial learned clause is Â¬x1 âˆ¨ Â¬x6 âˆ¨ Â¬x7. </li><li>c3 is the clause responsible for the most recent BCP prior to the conflict, x7 &#x3D; T. Resolving c3 and c4 gives us the partial clause of Â¬x1 âˆ¨ Â¬x5 âˆ¨ Â¬x6. </li><li>c2 is the clause responsible for the next most recent BCP, x6 &#x3D; T. Resolving c2 with our current partial clause gives us Â¬x1 âˆ¨ Â¬x5.<ol><li>This is our complete learned clause, because there is only one literal at decision level two within it.</li><li>Since x1 has the highest decision level in our new learned clause, we backtrack to that level where we will be able to apply our newly learned clause, c9 &#x3D; Â¬x1 âˆ¨ Â¬x5</li></ol></li></ol><h3 id="A-note-about-Decision-Heuristics">5.2. A note about Decision Heuristics</h3><blockquote><p>The version of CDCL we implemented in this article does not have any smart <strong>decision heuristics</strong>å¯å‘å¼å†³ç­–. Better decision heuristics is often the source of breakthroughs SAT Solver performance increases and are very important to modern SAT solvers today. We only examined clause learning and non-chronological backtracking as improvements over DPLL to keep the scope of this project small.</p><p>æˆ‘ä»¬åœ¨è¿™ç¯‡æ–‡ç« ä¸­å®ç°çš„CDCLç‰ˆæœ¬æ²¡æœ‰ä»»ä½•æ™ºèƒ½å†³ç­–å¯å‘å¼æ–¹æ³•ã€‚æ›´å¥½çš„å†³ç­–å¯å‘å¼å¾€å¾€æ˜¯SATæ±‚è§£å™¨æ€§èƒ½æé«˜çš„çªç ´å£ï¼Œå¯¹ä»Šå¤©çš„ç°ä»£SATæ±‚è§£å™¨éå¸¸é‡è¦ã€‚æˆ‘ä»¬åªç ”ç©¶äº†å­å¥å­¦ä¹ å’ŒéåŒæ­¥å›æº¯ä½œä¸ºå¯¹DPLLçš„æ”¹è¿›ï¼Œä»¥ä¿æŒè¿™ä¸ªé¡¹ç›®çš„èŒƒå›´å¾ˆå°ã€‚</p></blockquote><h3 id="pseudocode">5.3. pseudocode</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CDCL</span>(<span class="params">Ï•</span>):     // Ï• <span class="keyword">is</span> a CNF formula</span><br><span class="line">   Ï„â†âˆ…</span><br><span class="line">   <span class="keyword">while</span> true:</span><br><span class="line">      Ï„â†unit-propagate(Ï•,Ï„) // Unit propagation</span><br><span class="line">      <span class="keyword">if</span> Ï„ falsifies a clause:</span><br><span class="line">         <span class="keyword">if</span> at decision level <span class="number">0</span>: <span class="keyword">return</span> unsat</span><br><span class="line">         Câ†analyze-conflict(Ï•,Ï„) // Build the learned clause</span><br><span class="line">         Ï•â†Ï•âˆ§C // Add it to the formula</span><br><span class="line">         backjump to an earlier decision level according to C</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">all</span> variables have values: <span class="keyword">return</span> sat</span><br><span class="line">         start a new decision level</span><br><span class="line">         choose a literal l such that Ï„(l) <span class="keyword">is</span> undefined</span><br><span class="line">         Ï„â†Ï„âˆª&#123;l&#125; // <span class="string">&quot;Decide&quot;</span> that l <span class="keyword">is</span> true</span><br></pre></td></tr></table></figure><h2 id="Complexity-å¤æ‚åº¦">6. Complexity å¤æ‚åº¦</h2><h3 id="P">6.1. P</h3><ul><li>å¤šé¡¹å¼æ—¶é—´å¤æ‚æ€§ç±»ï¼ˆPolynomial<code>[ËŒpÉ”li&#39;nÉ™umjÉ™l]</code> timeï¼‰</li><li>æ‰€æœ‰Pé—®é¢˜éƒ½èƒ½è¢«ç»å…¸è®¡ç®—æœºï¼ˆéé‡å­è®¡ç®—æœºï¼‰è½»æ¾è§£å†³</li><li>å¦‚æœä¸€ä¸ªé—®é¢˜æ˜¯Pé—®é¢˜ï¼Œé‚£ä¹ˆå®ƒå¿…é¡»æ»¡è¶³åœ¨å¤šé¡¹å¼æ—¶é—´ncå†…éªŒè¯ä¸€ä¸ªç®—æ³•é—®é¢˜çš„å®ä¾‹æ˜¯å¦<code>æœ‰è§£</code>ï¼Œ<ul><li>næ˜¯è¾“å…¥é•¿åº¦</li><li>cæ˜¯ä¸ªå¸¸æ•°</li></ul></li><li>å…¸å‹é—®é¢˜ï¼š<ul><li>è¿™ä¸ªæ•°æ˜¯å¦æ˜¯ä¸ªè´¨æ•°ï¼Ÿ</li><li>ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„æ˜¯ä»€ä¹ˆï¼Ÿ</li></ul></li></ul><h3 id="np">6.2. np</h3><ul><li>éå®šå¸¸å¤šé¡¹å¼æ—¶é—´å¤æ‚æ€§ç±»ï¼ˆNondeterministic Polynomial timeï¼‰</li><li>èƒ½åœ¨å¤šé¡¹å¼æ—¶é—´éªŒè¯ç­”æ¡ˆ<code>æ­£ç¡®ä¸å¦</code>çš„é—®é¢˜</li><li>ç®—èµ·æ¥ä¸ä¸€å®šå¿«ï¼Œä½†å¯¹äºä»»ä½•ç­”æ¡ˆæˆ‘ä»¬éƒ½å¯ä»¥å¿«é€Ÿçš„<strong>éªŒè¯</strong>è¿™ä¸ªç­”æ¡ˆå¯¹ä¸å¯¹</li></ul><blockquote><p>The method of <strong>truth tables</strong> is a <strong>deterministic</strong> algorithm for deciding both satisfiability and validity in propositional logic. The algorithm is <strong>exponential</strong>, because the size of a formula is polynomial in $n$, the number of variables, while the truth table has $2^n$ rows.</p><p>The method of <strong>semantic tableaux</strong> is a <strong>nondeterministic</strong> algorithm for both satisfiability and validity, because at any stage of the construction, we can choose a leaf to expand and choose a formula in the label of the leaf to which a rule will be applied. Nevertheless, it can be shown that there are families of formulas for which the method of semantic tableaux is <strong>exponential, as are the David-Putnam procedure and resolution</strong></p><p>The problems of deciding <strong>satisfiability</strong> and <strong>validity</strong> in propositional logic are almost certainly intractable: the former is in <strong>np</strong> and the latter in <strong>co-np</strong></p></blockquote><h2 id="Formalising-problems-in-propositional-logic">7. Formalising problems in propositional logic</h2><h3 id="Nçš‡å">7.1. Nçš‡å</h3><center><img loading="lazy" src="/posts/f363d9fd/14.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/15.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/16.png" width="550"></center><h3 id="Encoding-fixed-bit-width-arithmetic">7.2. Encoding fixed bit-width arithmetic</h3><center><img loading="lazy" src="/posts/f363d9fd/17.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/18.png" width="550"></center><h3 id="Linear-in-equalities">7.3. Linear (in)equalities</h3><ul><li>è€ƒè™‘$x + y &#x3D; z$</li></ul><center><img loading="lazy" src="/posts/f363d9fd/19.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/20.png" width="550"></center><ul><li>Linear inequalities</li></ul><center><img loading="lazy" src="/posts/f363d9fd/21.png" width="550"></center><ul><li>Non-linear (in)equalitiesï¼Ÿ</li></ul><h2 id="å‚è€ƒ">8. å‚è€ƒ</h2><ul><li><a href="https://cse442-17f.github.io/Conflict-Driven-Clause-Learning/">Conflict Driven Clause Learning</a></li><li><a href="https://zhuanlan.zhihu.com/p/92659252">ã€è¯•è¯‘ã€‘å†²çªé©±åŠ¨å­å¥å­¦ä¹ (Conflict Driven Clause Learning) - çŸ¥ä¹</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SAT-å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜&quot;&gt;1. SAT å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;å¯æ»¡è¶³æ€§ï¼ˆè‹±è¯­ï¼šSatisfiabilityï¼‰æ˜¯ç”¨æ¥è§£å†³ç»™å®šçš„çœŸå€¼æ–¹ç¨‹å¼ï¼Œæ˜¯å¦å­˜åœ¨ä¸€ç»„å˜é‡èµ‹å€¼ï¼Œä½¿é—®é¢˜ä¸ºå¯æ»¡è¶³ã€‚å¸ƒå°”å¯æ»¡è¶³æ€§é—®é¢˜ï¼ˆBoolean satisfiability problemï¼›SAT ï¼‰å±äº&lt;strong&gt;å†³å®šæ€§é—®é¢˜&lt;/strong&gt;ï¼Œä¹Ÿæ˜¯ç¬¬ä¸€ä¸ªè¢«è¯æ˜å±äº&lt;strong&gt;NPå®Œå…¨&lt;/strong&gt;çš„é—®é¢˜&lt;/p&gt;
&lt;p&gt;å†³å®šæ€§é—®é¢˜ï¼Œäº¦ç§°åˆ¤å®šé—®é¢˜ï¼Œï¼ˆè‹±è¯­ï¼šDecision problemï¼‰æ˜¯ä¸€ä¸ªåœ¨æŸäº›å½¢å¼ç³»ç»Ÿå›ç­”â€œæ˜¯â€æˆ–â€œå¦â€çš„é—®é¢˜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Properties-of-Clausal-Form&quot;&gt;2. Properties of Clausal Form&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A computer program that searches for a model for a propositional formula is called a SAT Solver. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Let S, Sâ€² be sets of clauses. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sâ‰ˆSâ€² denotes that S is satisfiable if and only if Sâ€² is satisfiable.â€ƒ&lt;/li&gt;
&lt;li&gt;It is important to understand that Sâ‰ˆSâ€² does not imply that Sâ‰¡Sâ€² (S is &lt;strong&gt;logically equivalent&lt;/strong&gt; to Sâ€²)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f363d9fd/1.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;


&lt;h3 id=&quot;Pure-Literals&quot;&gt;2.1. Pure Literals&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S&lt;/p&gt;
&lt;p&gt;Let S be a set of clauses and let l be a pure literal in S. Let Sâ€² be obtained from S by deleting every clause containing l. Then Sâ‰ˆSâ€²&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¹Ÿå°±æ˜¯åˆ é™¤çº¯æ–‡å­—ä¸å½±å“åŠå¥å…¨æ€§çš„ä¼ é€’&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Unit-Clauses&quot;&gt;2.2. Unit Clauses&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let {l}âˆˆS be a unit clause and let Sâ€² be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then Sâ‰ˆSâ€².&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-ä¸€é˜¶é€»è¾‘-åº</title>
    <link href="https://hejueyun.github.io/posts/c666161e/"/>
    <id>https://hejueyun.github.io/posts/c666161e/</id>
    <published>2022-02-13T21:39:34.000Z</published>
    <updated>2022-03-11T14:21:43.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Orderings-åº">1. Orderings åº</h2><p><strong>åºæ˜¯ä¸€ä¸ªå…³ç³»</strong></p><blockquote><p>A (<strong>strict</strong>) ordering on a set X is a transitive and irreflexive <strong>binary relation</strong> on X, here denoted by <code>â‰»</code>  ï¼ˆåªæœ‰ä¸¥æ ¼æœ‰åºé›†æ˜¯è¦æ±‚éè‡ªåï¼Œå³æ— ç›¸ç­‰å…ƒç´ çš„ï¼Ÿæ¯•ç«Ÿç›¸ç­‰çš„è¯å°±æ˜¯multi-setäº†ï¼Œå¹¶ä¸”è¿™ä¸ªç¬¦å·ä¹Ÿä¸æ˜¯$\geq$ï¼‰</p><ul><li>The pair<code> (X, â‰»)</code> is then called <strong>a (strictly) ordered set</strong>æœ‰åºé›† (æ„Ÿè§‰æœ‰ç‚¹ç±»ä¼¼ç¾¤ï¼Œåªä¸è¿‡ç¾¤æ˜¯åœ¨é›†åˆçš„åŸºç¡€ä¸Šå®šä¹‰åŠ ä¹˜æ³•ï¼Œè€Œæœ‰åºé›†æ˜¯åœ¨é›†åˆçš„åŸºç¡€ä¸Šå®šä¹‰äº†åº)</li></ul><p>An element x of X is <strong>minimal</strong> wrt.(with regard to) â‰», if there is no y in X such that <code>x â‰» y</code></p><ul><li>A <strong>minimal</strong> element x in X is called the <strong>smallest</strong> (or strictly minimal) element, if for all y âˆˆ X different from x, y â‰» x.</li><li>Maximal and largest (or strictly maximal) elements are defined analogously(ç±»ä¼¼çš„)</li></ul><hr><ul><li>$â‰º$ for the inverse relation $â‰»^{âˆ’1}$</li><li>x âª° y iff either x â‰» y or x &#x3D; y</li></ul></blockquote><ul><li>In a total ordering if an element is minimal then it is the smallest element.</li><li>In any ordering, the smallest element is unique, if exists</li></ul><h3 id="Strict-partial-order-ä¸¥æ ¼ååº">1.1. Strict partial order ä¸¥æ ¼ååº</h3><ol><li>Irreflexivity: </li><li>Transitivity</li><li>Asymmetry</li></ol><h4 id="Total-order-å…¨åºå…³ç³»">1.1.1. Total order å…¨åºå…³ç³»</h4><ul><li>ä¹Ÿç§°linear orderçº¿æ€§å…³ç³»</li></ul><center><img loading="lazy" src="/posts/c666161e/2.jpg" width="550"></center><ul><li>A <strong>strict</strong> total order åˆ™ä¼šå°†reflexiveå˜ä¸ºirreflexive.</li></ul><h3 id="Well-founded-relation-è‰¯åŸºå…³ç³»">1.2. Well-founded relation  è‰¯åŸºå…³ç³»</h3><blockquote><p>A (strict) ordering â‰» over X is called well-founded (or Noetherian or terminating), if there is no infinite decreasing chain x0 â‰» x1 â‰» x2 â‰» . . . of elements xi âˆˆ X.</p><p><strong><code>(X, â‰»)</code> is well-founded iff every non-empty subset Y of X has a minimal element</strong>.</p></blockquote><ul><li>åœ¨æ•°å­¦ä¸­ï¼Œç±» X ä¸Šçš„ä¸€ä¸ªäºŒå…ƒå…³ç³» R è¢«ç§°ä¸ºæ˜¯è‰¯åŸºçš„ï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰ X çš„éç©ºå­é›†éƒ½æœ‰ä¸€ä¸ª R-æå°ï¼ˆæ³¨æ„å‰ææ˜¯<strong>æœ‰é™</strong>æœ‰åºé›†ï¼‰</li></ul><h3 id="Noetherian-Induction-å½’çº³">1.3. Noetherian Induction å½’çº³</h3><p>Let (X, â‰») be a well-founded ordering, let Q be a property of elements of X.</p><ul><li><strong>If</strong><ul><li>for all x âˆˆ X the following implication is satisfied<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if Q(y) holds, for all y âˆˆ X such that x â‰» y,</span><br><span class="line">then Q(x) holds.</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>Then</strong><ul><li>the property Q(x) holds for all x âˆˆ X</li><li><em>ç›¸å½“äºsatisfyè¯validï¼Ÿ</em></li></ul></li></ul><p>Proofï¼šBy contradictionåè¯æ³•</p><blockquote><p>By contradiction.</p><p>Thus, suppose for all x âˆˆ X the implication above is satisfied, but Q(x) does not hold for all x âˆˆ X.</p><p>Let A &#x3D; {x âˆˆ X | Q(x) is false}. Suppose A Ì¸&#x3D; âˆ….</p><p>Since (X, â‰») is well-founded, A has a minimal element x1. Hence for all y âˆˆ X with x1 â‰» y the property Q(y) holds.</p><p>On the other hand, the implication which is presupposed for this theorem holds in particular also for x1, hence Q(x1) must be true so that x1 cannot belong to A. Contradiction.</p></blockquote><h3 id="Multi-Set-Orderings">1.4. Multi-Set Orderings</h3><p>Let (X, â‰») be an ordering. The multi-set extension $â‰»_{mul}$ of â‰» to (<strong>finite</strong>) multi-sets over X is defined by</p><ul><li>$S1 â‰»_{mul} S2$ â‡â‡’ S1 Ì¸&#x3D; S2 and âˆ€x âˆˆ S2\S1. âˆƒy âˆˆ S1\S2. y â‰» x</li></ul><ol><li>Remove common occurrences of elements from S1 and S2. Assume this gives Sâ€²&#x3D; Sâ€²</li></ol><p>2.Then check that for every element x in Sâ€²there is an element y âˆˆ Sâ€² that is greater than x. Then S1 $â‰»_mul$ S2.</p><center><img loading="lazy" src="/posts/c666161e/1.jpg" width="550"></center><hr><p>Ordering with one minimal element, but without the smallest element:</p><ul><li>${(0,y)\in {\Bbb{R}}^2: 0&lt;y&lt;1} \cup{} {(1,y)\in {\Bbb{R}}^2: 0\leq y&lt;1}$<ul><li>$(1,0)$ is the one and only one minimal element but not a smallest element</li><li>because it is not related to the elements with $x&#x3D;0$</li></ul></li></ul><h4 id="Properties">1.4.1. Properties</h4><h2 id="Lexicographic-Combination">2. Lexicographic Combination</h2><p>Let (X1, $â‰»<em>1$), (X2, $â‰»_2$) be two <strong>orderings</strong>. Lexicographic combination of (X1, â‰»1), (X2, â‰»2) is an ordering: $â‰»</em>{lex}&#x3D; ($â‰»_1$, $â‰»_2$)lex$ on X1 Ã— X2 such that</p><ul><li>(x1, x2) â‰»lex (y1, y2) iff <ul><li>x1 $â‰»_1$ y1</li><li><strong>or else</strong> x1 &#x3D; y1 and x2 $â‰»_2$ y2</li></ul></li></ul><h3 id="Properties-1">2.1. Properties</h3><p>Let (X1, $â‰»_1$), (X2, $â‰»_2$)) be two orderings. Then</p><ol><li>$â‰»_lex$ is an ordering.</li><li>if both $â‰»_1$ and $â‰»_2$ <strong>well-founded</strong> then $â‰»_lex$ well-founded.</li><li>if both $â‰»<em>1$ and $â‰»_2$ <strong>total</strong> then $â‰»</em>{lex}$ total.</li></ol><h2 id="ground-literal-and-clause-orderings">3. ground literal and clause orderings</h2><center><img loading="lazy" src="/posts/c666161e/3.png" width="550"></center><ul><li>ä¹Ÿå°±æ˜¯è¯´å‘½é¢˜é€»è¾‘ä¸­çš„literalç›¸å½“äºä¸€é˜¶é€»è¾‘ä¸­çš„ground literal</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Orderings-åº&quot;&gt;1. Orderings åº&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;åºæ˜¯ä¸€ä¸ªå…³ç³»&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A (&lt;strong&gt;strict&lt;/strong&gt;) ordering on a set X is a transitive and irreflexive &lt;strong&gt;binary relation&lt;/strong&gt; on X, here denoted by &lt;code&gt;â‰»&lt;/code&gt;  ï¼ˆåªæœ‰ä¸¥æ ¼æœ‰åºé›†æ˜¯è¦æ±‚éè‡ªåï¼Œå³æ— ç›¸ç­‰å…ƒç´ çš„ï¼Ÿæ¯•ç«Ÿç›¸ç­‰çš„è¯å°±æ˜¯multi-setäº†ï¼Œå¹¶ä¸”è¿™ä¸ªç¬¦å·ä¹Ÿä¸æ˜¯$\geq$ï¼‰&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The pair&lt;code&gt; (X, â‰»)&lt;/code&gt; is then called &lt;strong&gt;a (strictly) ordered set&lt;/strong&gt;æœ‰åºé›† (æ„Ÿè§‰æœ‰ç‚¹ç±»ä¼¼ç¾¤ï¼Œåªä¸è¿‡ç¾¤æ˜¯åœ¨é›†åˆçš„åŸºç¡€ä¸Šå®šä¹‰åŠ ä¹˜æ³•ï¼Œè€Œæœ‰åºé›†æ˜¯åœ¨é›†åˆçš„åŸºç¡€ä¸Šå®šä¹‰äº†åº)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An element x of X is &lt;strong&gt;minimal&lt;/strong&gt; wrt.(with regard to) â‰», if there is no y in X such that &lt;code&gt;x â‰» y&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;minimal&lt;/strong&gt; element x in X is called the &lt;strong&gt;smallest&lt;/strong&gt; (or strictly minimal) element, if for all y âˆˆ X different from x, y â‰» x.&lt;/li&gt;
&lt;li&gt;Maximal and largest (or strictly maximal) elements are defined analogously(ç±»ä¼¼çš„)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;$â‰º$ for the inverse relation $â‰»^{âˆ’1}$&lt;/li&gt;
&lt;li&gt;x âª° y iff either x â‰» y or x &amp;#x3D; y&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In a total ordering if an element is minimal then it is the smallest element.&lt;/li&gt;
&lt;li&gt;In any ordering, the smallest element is unique, if exists&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Strict-partial-order-ä¸¥æ ¼ååº&quot;&gt;1.1. Strict partial order ä¸¥æ ¼ååº&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Irreflexivity: &lt;/li&gt;
&lt;li&gt;Transitivity&lt;/li&gt;
&lt;li&gt;Asymmetry&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Total-order-å…¨åºå…³ç³»&quot;&gt;1.1.1. Total order å…¨åºå…³ç³»&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ä¹Ÿç§°linear orderçº¿æ€§å…³ç³»&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c666161e/2.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;strict&lt;/strong&gt; total order åˆ™ä¼šå°†reflexiveå˜ä¸ºirreflexive.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-é›†åˆè®º</title>
    <link href="https://hejueyun.github.io/posts/301925f/"/>
    <id>https://hejueyun.github.io/posts/301925f/</id>
    <published>2022-02-10T23:11:11.000Z</published>
    <updated>2022-02-16T12:11:27.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sets-é›†åˆ">1. Sets é›†åˆ</h2><ul><li>A set is composed of elements . a âˆˆ S denotes that a is an element of set S</li><li>The set with no elements is the empty set , denoted âˆ….</li></ul><h3 id="Multi-Sets-å¤šé‡é›†">1.1. Multi-Sets å¤šé‡é›†</h3><ul><li>sets which allow repetition</li><li>$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S<ul><li>S &#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then <code>S(a) = 3, S(b) = 2, S(c) = 0</code></li><li>denoted: $S: A\rightarrow{Z^{+}}$ï¼ŒA is the underlying set of the multiset</li></ul></li><li>multi-set S over X is called <strong>finite</strong>, if <code>&#123; x âˆˆ X | S(x) &gt; 0&#125;| &lt; âˆ</code>.</li></ul><center><img loading="lazy" src="/posts/301925f/5.png" width="550px"></center><h2 id="Set-Operators-é›†åˆæ“ä½œç¬¦">2. Set Operators é›†åˆæ“ä½œç¬¦</h2><ul><li>Let S and T be sets. S is a subset of T , denoted S âŠ† T , iff every element of S is an element of T , that is, x âˆˆ S â†’ x âˆˆ T . S is a proper subset of T , denoted S âŠ‚ T , iff S âŠ† T and S â‰  T</li><li><strong>Union</strong>è”åˆ<ul><li>S <code>âˆª</code> T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).</li></ul></li><li><strong>Intersection</strong>äº¤é›†<ul><li>S <code>âˆ©</code> T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S âˆ© T &#x3D;âˆ… then S and T are disjoint .</li></ul></li><li><strong>Difference</strong>å·®é›†<ul><li>S <code>âˆ’</code> T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$</li></ul></li><li><strong>complement</strong> è¡¥é›†<ul><li>Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S âˆ’ T</li></ul></li><li><strong>Cartesian product</strong>ç¬›å¡å°”ç§¯<ul><li>Let S and T be sets. S <code>Ã—</code> T , their Cartesian product , is the set of all pairs ( s , t ) such that s âˆˆ S and t âˆˆ T</li></ul></li></ul><center><img loading="lazy" src="/posts/301925f/4.gif" width="550px"></center><h2 id="Sequences-åºåˆ—">3. Sequences åºåˆ—</h2><p>Let $S$ be a set.</p><ul><li>A finite sequence $f$ on $S$ is a function from {0,â€¦, n âˆ’1} to $$ . The length of the sequence is n .</li><li>An infinite sequence $f$ on $S$ is a mapping from $N$ to $S$</li></ul><h3 id="tuple-å…ƒç»„">3.1. tuple å…ƒç»„</h3><ul><li>A finite sequence of length n is an n-tuple</li></ul><h2 id="Relations-and-Functions-å…³ç³»ä¸å‡½æ•°">4. Relations and Functions å…³ç³»ä¸å‡½æ•°</h2><blockquote><p>a relation is a subset of a Cartesian product of sets and a function is a relation with a special property</p><p>å…³ç³»æ˜¯é›†åˆçš„ç¬›å¡å°”ç§¯çš„ä¸€ä¸ªå­é›†ï¼Œå‡½æ•°æ˜¯å…·æœ‰ç‰¹æ®Šå±æ€§çš„å…³ç³»ã€‚</p></blockquote><h3 id="n-ary-relation-nå…ƒå…³ç³»">4.1. n-ary relation nå…ƒå…³ç³»</h3><center><img loading="lazy" src="/posts/301925f/6.png" width="550px"></center><h3 id="Properties-of-Relations-å…³ç³»çš„å±æ€§">4.2. Properties of Relations å…³ç³»çš„å±æ€§</h3><p>Let R be a binary relation on $S^2$ . (Notation: R(x,y) &lt;&#x3D;&gt;  yRx)</p><ul><li>R is reflexiveè‡ªå iff R ( x , x ) for all x âˆˆ S .</li><li>R is symmetricå¯¹ç§° iff R ( $x_1 , x_2$ ) implies R ( $x_1 , x_2$ ).</li><li>Antisymmetric åå¯¹ç§°<ul><li>è‹¥å¯¹æ‰€æœ‰çš„ a å’Œ b å±äº Xï¼Œä¸‹è¿°è¯­å¥ä¿æŒæœ‰æ•ˆï¼Œåˆ™é›†åˆ X ä¸Šçš„äºŒå…ƒå…³ç³» R æ˜¯åå¯¹ç§°çš„ï¼šâ€œè‹¥ a å…³ç³»åˆ° b ä¸” b å…³ç³»åˆ° aï¼Œåˆ™ a &#x3D; bã€‚â€ <blockquote><p>æ³¨æ„ï¼Œ<strong>åå¯¹ç§°å…³ç³»ä¸æ˜¯å¯¹ç§°å…³ç³»ï¼ˆaRb å¾—åˆ° bRaï¼‰çš„åä¹‰</strong>ã€‚æœ‰äº›å…³ç³»æ—¢æ˜¯å¯¹ç§°çš„åˆæ˜¯åå¯¹ç§°çš„ï¼Œæ¯”å¦‚â€ç­‰äºâ€ï¼ˆè¯æ˜ï¼ša&#x3D;bæ¨å‡ºb&#x3D;aï¼›a&#x3D;bä¸”b&#x3D;aæ¨å‡ºa&#x3D;bï¼‰ï¼›æœ‰äº›å…³ç³»æ—¢ä¸æ˜¯å¯¹ç§°çš„ä¹Ÿä¸æ˜¯åå¯¹ç§°çš„ï¼Œæ¯”å¦‚â€çˆ±ä¸Šâ€¦â€¦â€ï¼ˆè¯æ˜ï¼šaçˆ±bä¸èƒ½æ¨å‡ºbçˆ±aï¼›açˆ±bä¸”bçˆ±aä¸èƒ½æ¨å‡ºaå’Œbæ˜¯åŒä¸€ä¸ªäººï¼‰</p></blockquote></li></ul></li><li>R is transitiveä¼ é€’ iff R ($x_1 , x_2$ ) and R ( $x_2 , x_3$ ) imply R ( $x_1 , x_3$ ).</li></ul><p>$R^{âˆ—}$ , the <strong>reflexive transitive closure</strong>è‡ªåä¼ é€’é—­åŒ… of $R$ , is defined as follows:</p><ul><li>If R ( $x_1 , x_2$ ) then $R^{âˆ—}$ ( $x_1 , x_2$ ).<ul><li>$R\subseteq{R^{*}}$</li></ul></li><li>$R^{âˆ—}$ ( x i , x i ) for all $x_i$ âˆˆ S .<ul><li>$R^{*}$ is symmetric</li></ul></li><li>$R^{âˆ—}$ ( $x_1 , x_2$ ) and $R^{âˆ—}$ ( $x_2 , x_3$ ) imply $R^{âˆ—}$ ( $x_1 , x_3$ )<ul><li>$R^{*}$ is transitive</li></ul></li></ul><hr><p>Definition. A <strong>transition relation <code>â‡’</code></strong> on set S is</p><ul><li><strong>terminating</strong>ç»ˆæ­¢ if there is no infinite s1 â‡’ s2 â‡’ . . . â‡’ sn â‡’ . . ..</li><li><strong>compatible</strong> with an ordering â‰» on S if â‡’âŠ†â‰».<blockquote><p>A transition relation â‡’ is terminating if and only if there is a well-founded ordering â‰» compatible with â‡’</p></blockquote></li></ul><hr><p>symmetric and reflexive but not transitive:</p><ul><li>$R&#x3D;{(a,a),(a,b),(b,a),(b,b),(c,c),(b,c),(c,b)}$<ul><li>æ»¡è¶³aRa</li><li>æ»¡è¶³aRbâ†’bRa</li><li>ä¸æ»¡è¶³aRb,bRc-&gt;cRa</li></ul></li></ul><h3 id="Relation-of-multi-sets">4.3. Relation of multi-sets</h3><p>A and B are multisets in a given universe U, with multiplicity functions $m_a$ and $m_b$</p><ul><li>A is included in B, denoted A âŠ† B, if ${\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.} {\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.}$<br>å…¶ä½™å…³ç³»å®šä¹‰å‚è€ƒï¼š</li><li>(S1 âˆª S2)(x) &#x3D; S1(x) + S2(x)</li><li>(S1 âˆ© S2)(x) &#x3D; min{S1(x), S2(x)}</li><li>(S1\S2)(x) &#x3D; S1(x) âˆ’ S2(x)</li></ul><h3 id="Functions-å‡½æ•°">4.4. Functions å‡½æ•°</h3><center><img loading="lazy" src="/posts/301925f/1.jpg" width="550px"></center><ul><li>$x_n$ç›¸å½“äºyå€¼</li><li>domainï¼šé™ªåŸŸ range: å€¼åŸŸ</li><li>total: å…¨å‡½æ•° partial: éƒ¨åˆ†å‡½æ•°</li></ul><center><img loading="lazy" src="/posts/301925f/3.jpg" width="550px"></center><ul><li>injectiveå•å°„ï¼šæŒ‡å°†ä¸åŒçš„å˜é‡æ˜ å°„åˆ°ä¸åŒçš„å€¼çš„å‡½æ•°ã€‚</li><li>surjectiveæ»¡å°„ï¼šæŒ‡é™ªåŸŸç­‰äºå€¼åŸŸçš„å‡½æ•°ã€‚å³ï¼šå¯¹é™ªåŸŸä¸­ä»»æ„å…ƒç´ ï¼Œéƒ½å­˜åœ¨è‡³å°‘ä¸€ä¸ªå®šä¹‰åŸŸä¸­çš„å…ƒç´ ä¸ä¹‹å¯¹åº”ã€‚</li><li>bijectiveåŒå°„ï¼ˆä¹Ÿç§°ä¸€ä¸€å¯¹åº”æˆ–ä¸€ä¸€æ˜ å°„ one-to-one and ontoï¼‰ï¼šæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„çš„å‡½æ•°</li></ul><center><img loading="lazy" src="/posts/301925f/2.png" width="550px"></center><h2 id="Cardinality-åŠ¿">5. Cardinality åŠ¿</h2><ul><li>The cardinality<code>/ËˆkÉ‘Ë.dÉªnËˆÃ¦l.É™.ti/</code> of a set is the <strong>number</strong> of elements in the set</li><li>å¦‚æœå­˜åœ¨ç€ä»é›†åˆAåˆ°é›†åˆBçš„åŒå°„ï¼Œé‚£ä¹ˆé›†åˆAä¸é›†åˆBç­‰åŠ¿ï¼Œè®°ä¸ºA~B</li></ul><h3 id="powerset-å¹‚é›†">5.1. powerset å¹‚é›†</h3><ul><li>The powerset of a set S , denoted $2^S$ , is the set of all subsets ofÂ S <ul><li>ç”±è¯¥é›†åˆå…¨éƒ¨å­é›†ä¸ºå…ƒç´ æ„æˆçš„é›†åˆ</li></ul></li><li>Let S be a finite set of cardinality n ; then the cardinality of its powerset is $2^n$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Sets-é›†åˆ&quot;&gt;1. Sets é›†åˆ&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A set is composed of elements . a âˆˆ S denotes that a is an element of set S&lt;/li&gt;
&lt;li&gt;The set with no elements is the empty set , denoted âˆ….&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Multi-Sets-å¤šé‡é›†&quot;&gt;1.1. Multi-Sets å¤šé‡é›†&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;sets which allow repetition&lt;/li&gt;
&lt;li&gt;$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S&lt;ul&gt;
&lt;li&gt;S &amp;#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then &lt;code&gt;S(a) = 3, S(b) = 2, S(c) = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;denoted: $S: A\rightarrow{Z^{+}}$ï¼ŒA is the underlying set of the multiset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;multi-set S over X is called &lt;strong&gt;finite&lt;/strong&gt;, if &lt;code&gt;&amp;#123; x âˆˆ X | S(x) &amp;gt; 0&amp;#125;| &amp;lt; âˆ&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/5.png&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Set-Operators-é›†åˆæ“ä½œç¬¦&quot;&gt;2. Set Operators é›†åˆæ“ä½œç¬¦&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S is a subset of T , denoted S âŠ† T , iff every element of S is an element of T , that is, x âˆˆ S â†’ x âˆˆ T . S is a proper subset of T , denoted S âŠ‚ T , iff S âŠ† T and S â‰  T&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union&lt;/strong&gt;è”åˆ&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;âˆª&lt;/code&gt; T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intersection&lt;/strong&gt;äº¤é›†&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;âˆ©&lt;/code&gt; T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S âˆ© T &amp;#x3D;âˆ… then S and T are disjoint .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difference&lt;/strong&gt;å·®é›†&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;âˆ’&lt;/code&gt; T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;complement&lt;/strong&gt; è¡¥é›†&lt;ul&gt;
&lt;li&gt;Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S âˆ’ T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cartesian product&lt;/strong&gt;ç¬›å¡å°”ç§¯&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S &lt;code&gt;Ã—&lt;/code&gt; T , their Cartesian product , is the set of all pairs ( s , t ) such that s âˆˆ S and t âˆˆ T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/4.gif&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Sequences-åºåˆ—&quot;&gt;3. Sequences åºåˆ—&lt;/h2&gt;&lt;p&gt;Let $S$ be a set.&lt;/p&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>è®¡ç®—æœºæ•°ç†é€»è¾‘-å‘½é¢˜é€»è¾‘-å½’ç»“</title>
    <link href="https://hejueyun.github.io/posts/f59d8546/"/>
    <id>https://hejueyun.github.io/posts/f59d8546/</id>
    <published>2022-02-09T23:09:30.000Z</published>
    <updated>2022-02-21T00:00:46.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The method of resolution is an efficient method for <strong>searching for a proof</strong>.</p></blockquote><h2 id="Reasoning-Methods">1. Reasoning Methods</h2><ul><li>Resolution</li><li>DPLL&#x2F;CDCL</li><li>Tableaux</li></ul><p>A refutational reasoningåé©³æ€§æ¨ç† method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either â€œsatisfiableâ€, â€œunsatisfiableâ€ or â€œdonâ€™t knowâ€</p><h3 id="soundness">1.1. soundness</h3><p>Consider <strong>a set of formulas</strong> Î¦ (usually called a <strong>fragment</strong>).<br>A reasoning method <strong>RM</strong> is sound for Î¦ if for any set S âŠ† Î¦:</p><ul><li>if RM(S) is â€œsatisfiableâ€ then there is an interpretation satisfying all formulas in S</li><li>if RM(S) is â€œunsatisfiableâ€ then there is no interpretation satisfying all formulas in S.</li><li>A trivialçç¢ RM which on all inputs returns â€œdonâ€™t knowâ€ is a sound reasoning method</li></ul><h3 id="Completeness">1.2. Completeness</h3><p>A reasoning method RM is <strong>(refutationally) complete</strong> for Î¦ if for any set<br>S âŠ† Î¦:</p><ul><li>if S is unsatisfiable then RM(S) is terminating and returns â€œunsatisfiableâ€</li></ul><h3 id="Trivialism-çç¢è®º">1.3. Trivialism çç¢è®º</h3><ul><li>çç¢è®ºæ˜¯ä¸€æ‰¿è®¤æ‰€æœ‰è¯­å¥ï¼ˆä¹Ÿç§°ä¸ºå‘½é¢˜ï¼‰ä¸ºçœŸå¹¶ä¸”æ‰€æœ‰â€œPä¸éPâ€å½¢å¼çš„çŸ›ç›¾å¥éƒ½ä¸ºçœŸçš„é€»è¾‘ç†è®º</li><li>På½“ä¸”ä»…å½“Pä¸ºçœŸ</li></ul><h2 id="Clause-å­å¥">2. Clause å­å¥</h2><p>Clause: a disjunctionæå– $L_1 âˆ¨ . . . âˆ¨ L_n$, n â‰¥ 0 of literals.</p><ul><li>A clause can be seen as a mulit-set of literals ${L_1, . . . , L_n}$</li><li><strong>Empty clause</strong>, denoted by <code>âŠ¥: n = 0 </code>(also denoted as <code>â–¡</code>, the empty clause is false in every interpretation)</li><li><strong>Unit clause</strong>å•ä½å­å¥: n &#x3D; 1<ul><li>A clause is unit under a partial assignment when that assignment makes every literal in the clause unsatisfied but leaves a single literal undecided</li><li>å¦‚æœä¸€ä¸ªå­å¥ä¸­ï¼Œé™¤äº†ä¸€ä¸ªæœªå†³å®šçš„å­—é¢é‡ï¼Œæ‰€æœ‰å­—é¢é‡éƒ½å·²ç»ç¡®å®šä¸ºå‡ï¼Œæˆ‘ä»¬å°±ç§°è¿™ä¸ªå­å¥ä¸ºâ€œå•ä½å­å¥â€</li></ul></li><li><strong>Trivial Clauses</strong><ul><li>clause if trivial if it contains a pair of clashingå†²çªçš„ literals.â€ƒ</li><li>Since a trivial clause is valid ($pâˆ¨Â¬â€‰p â‰¡ T$), <strong>it can be removed from a set of clauses without changing the truth value of the formula</strong>.</li></ul></li><li>A formula is considered to be an implicit conjunction of its clauses</li><li>The formula that is the empty set of clauses is denoted by âˆ….</li></ul><center><img loading="lazy" src="/posts/f59d8546/1.png" width="550"></center><ul><li><p>ä¹Ÿå°±æ˜¯å…¬å¼å½¢å¼vsé›†åˆå½¢å¼</p></li><li><p>Clausal form of a formula A: a set of clauses which is satisfiable if and only if A is satisfiable.</p></li><li><p>Clausal form of a set S of formulas: a set of clauses which is satisfiable if and only if so is S.</p></li></ul><h3 id="Horn-Clauses-éœæ©å­å¥">2.1. Horn Clauses éœæ©å­å¥</h3><p>éœæ©å­å¥ï¼ˆHorn Clauseï¼‰æ˜¯å¸¦æœ‰æœ€å¤šä¸€ä¸ªè‚¯å®šæ–‡å­—çš„å­å¥</p><ul><li>ä¸€ä¸ªéœæ©å­å¥çš„ä¾‹å­ï¼š${\displaystyle \neg p\lor \neg q\vee \cdots \vee \neg t\vee u}$ </li><li>å®ƒå¯ä»¥è¢«ç­‰ä»·åœ°å†™ä¸ºï¼š${\displaystyle (p\wedge q\wedge \cdots \wedge t)\rightarrow u}$</li></ul><h3 id="Definitional-Clausal-Form-Transformation">2.2. Definitional Clausal Form Transformation</h3><center><img loading="lazy" src="/posts/f59d8546/5.png" width="550"></center><ol><li>Take all subformulas that are not literals</li><li>Introduce names for these formulas. Note we do not introduce names for literals.</li><li>Introduce definitions.</li><li>Convert resulting formulas into CNF using the standard transformation</li></ol><h2 id="Conjunctive-Normal-Form-åˆå–èŒƒå¼">3. Conjunctive Normal Form åˆå–èŒƒå¼</h2><blockquote><p>å†™æˆåˆå–èŒƒå¼çš„å…¬å¼ç”±ä¸€äº›å­å¥ï¼ˆclauseï¼‰ç›¸<strong>ä¸ï¼ˆAND, $\lor$()ï¼‰</strong>è€Œæˆï¼›å­å¥åˆ™æ˜¯ç”±å­—é¢é‡ï¼ˆliteralï¼‰ç›¸<strong>æˆ–ï¼ˆOR, $\land{}$)</strong> è€Œæˆï¼›æ¯ä¸ªå­—é¢é‡å°±æ˜¯ä¸€ä¸ªå˜é‡ï¼Œæˆ–è€…ç”±å˜é‡ <strong>å–é($\lnot{}$)</strong> å¾—åˆ°</p><ul><li>ç”±äºè¿™æ ·çš„å…¬å¼åªæ˜¯ä¸€äº›å­å¥â€œä¸â€èµ·æ¥ï¼Œä¸ºä½¿<strong>å…¬å¼</strong>æ»¡è¶³ï¼Œæ¯ä¸ª<strong>å­å¥</strong>ä¹Ÿéƒ½å¿…é¡»å¾—åˆ°æ»¡è¶³ï¼›</li><li>ç”±äºæ¯ä¸ªå­å¥åªæ˜¯ä¸€äº›å­—é¢é‡â€œæˆ–â€èµ·æ¥ï¼Œåªè¦æ»¡è¶³äº†ä¸€ä¸ª<strong>å­—é¢é‡</strong>å°±æ»¡è¶³äº†æ•´ä¸ª<strong>å­å¥</strong></li></ul></blockquote><p>A formula is in conjunctive normal form (CNF) iff it is a conjunction of disjunctions of <strong>å­—é¢é‡literals</strong></p><ul><li>åœ¨å¸ƒå°”é€»è¾‘ä¸­ï¼Œå¦‚æœä¸€ä¸ªå…¬å¼æ˜¯<strong>å­å¥clause</strong>çš„åˆå–(conjucntion)</li></ul><center><img loading="lazy" src="/posts/f59d8546/2.png" width="550"></center><ul><li>Every formula in propositional logic can be transformed into an equivalent formula in CNF</li></ul><center><img loading="lazy" src="/posts/f59d8546/3.png" width="550"></center><ul><li>A formula is in 3CNF iff it is in CNF and each disjunction has exactly three literals.</li></ul><p>æ¨å¯¼ä¾‹å­</p><center><img loading="lazy" src="/posts/f59d8546/4.png" width="550"></center><ul><li>cnf cannot avoid exponential blowup<ul><li>Approach: relax requirement of equivalence preserving to equisatisfiability preserving</li><li>ä¹Ÿå°±æ˜¯é‡å‘½åï¼ˆæ¯”å¦‚n&#x3D;$p_1\leftrightarrow{p_2}$ï¼‰</li></ul></li></ul><h2 id="Resolution-Rule-å½’ç»“åŸç†">4. Resolution Rule å½’ç»“åŸç†</h2><p>Propositional Resolution inference system BR, consists of the following inference rules</p><center><img loading="lazy" src="/posts/f59d8546/6.png" width="550"></center><p>example</p><center><img loading="lazy" src="/posts/f59d8546/7.png" width="550"></center><h3 id="Tree-vs-Linear">4.1. Tree vs Linear</h3><center><img loading="lazy" src="/posts/f59d8546/9.png" width="550"></center><h2 id="inference-æ¨ç†">5. inference æ¨ç†</h2><center><img loading="lazy" src="/posts/f59d8546/8.png" width="550"></center><ul><li>premiseså‰æ: known or assumed to be true</li><li>conclusionç»“è®º</li><li>An inference rule <code>R</code> is a set of inferences.</li><li>An inference system, (or a calculusæ¼”ç®—) <code>I</code> is a set of inference rules.</li></ul><h3 id="sound">5.1. sound</h3><ul><li>An inference system is sound if all its inference rules are sound</li><li>If an inference system $I$ is sound then for any set of formulas S:<ul><li>$S âŠ¢_I âŠ¥$ implies $S âŠ¨ âŠ¥$</li></ul></li></ul><h3 id="completeness">5.2. completeness</h3><ul><li>An inference system $I$ is refutationally complete if for any set of formulas S we have<ul><li>$S âŠ¨ âŠ¥$ implies $S âŠ¢_I âŠ¥$</li></ul></li></ul><h2 id="Simplification-rules-åŒ–ç®€è§„åˆ™">6. Simplification rules åŒ–ç®€è§„åˆ™</h2><blockquote><p>to remove clauses in the saturation process without affecting neither soundness nor completeness</p></blockquote><h3 id="derived-and-saturated">6.1. derived and saturated</h3><ul><li>âŠ¥ is <strong>derived</strong> &#x3D;&#x3D; $âŠ¥ âˆˆ S_n$ for some n</li><li>no new clauses can be derived from S and âŠ¥ Ì¸âˆˆ S, then S is <strong>saturated</strong>; in this case S is satisfiable</li></ul><h3 id="Rule-Tautology-elimination-TE">6.2. Rule: Tautology elimination (TE)</h3><ul><li><code>S â‡’ S \ &#123;C&#125;</code> <ul><li>where C is a tautology (âŠ¨ C)</li></ul></li></ul><h3 id="Rule-Subsumption-Elimination-SE">6.3. Rule: Subsumption Elimination (SE)</h3><ul><li><p>A clause C <strong>subsumes</strong>å½’å…¥ a clause D if C âŠ‚ D</p></li><li><p><code>S â‡’ S \ &#123;D&#125;</code></p><ul><li>where there is C âˆˆ S such that C âŠ‚ D</li></ul></li></ul><center><img loading="lazy" src="/posts/f59d8546/10.png" width="550"></center><ul><li>We say a clause C to is in a <strong>set-reduced</strong> form if every literal occurs no more than once in C. A clause C in a set-reduced from can be seen as <strong>a set of literals</strong> (rather than <strong>a multi-set</strong>).</li><li>BR with eager (BF) and (SE) is a <strong>decision procedure</strong> for propositional logic</li></ul><h2 id="Inference-vs-Deductive-vs-Resolutuion-æ¨è®ºvsæ¼”ç»vså½’ç»“">7. Inference vs Deductive vs Resolutuion æ¨è®ºvsæ¼”ç»vså½’ç»“</h2><ul><li>We use reasons or reasoning to form inferences which are basically conclusions drawn from propositions or assumptions that are supposed to be true.<ul><li><strong>æ¨è®º</strong>æ˜¯ä»å‡å®šä¸ºçœŸå®çš„å‘½é¢˜(<strong>å‰æ</strong>)å¾—å‡ºçš„<strong>ç»“è®º</strong></li></ul></li><li>Deduction is a general-to-specific form of reasoning that goes from known truths to specific instances. It starts with a hypothesis and examines the possibilities within that hypothesis to reach a conclusion. Example, in chemistry deducing a chemical equation basis two or more agents.<ul><li><strong>æ¼”ç»</strong>æ˜¯ä¸€ç§ä»ä¸€èˆ¬åˆ°å…·ä½“çš„æ¨ç†å½¢å¼ï¼Œä»å·²çŸ¥çœŸç†åˆ°å…·ä½“å®ä¾‹</li><li>å®ƒä»ä¸€ä¸ªå‡è®¾å¼€å§‹ï¼Œç ”ç©¶è¯¥å‡è®¾ä¸­çš„å„ç§å¯èƒ½æ€§ä»¥å¾—å‡ºç»“è®º</li></ul></li><li>resolution is <strong>a rule of inference</strong> leading to a <strong>refutation complete theorem-proving technique</strong> for sentences in propositional logic and first-order logic<ul><li><strong>å½’ç»“</strong>æ˜¯ä¸€ç§åå‘è¯æ˜çš„æ–¹æ³•ï¼Œæ˜¯å¯¹äºå‘½é¢˜é€»è¾‘å’Œä¸€é˜¶é€»è¾‘ä¸­çš„å¥å­çš„<strong>æ¨ç†è§„åˆ™</strong></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The method of resolution is an efficient method for &lt;strong&gt;searching for a proof&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Reasoning-Methods&quot;&gt;1. Reasoning Methods&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Resolution&lt;/li&gt;
&lt;li&gt;DPLL&amp;#x2F;CDCL&lt;/li&gt;
&lt;li&gt;Tableaux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A refutational reasoningåé©³æ€§æ¨ç† method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either â€œsatisfiableâ€, â€œunsatisfiableâ€ or â€œdonâ€™t knowâ€&lt;/p&gt;
&lt;h3 id=&quot;soundness&quot;&gt;1.1. soundness&lt;/h3&gt;&lt;p&gt;Consider &lt;strong&gt;a set of formulas&lt;/strong&gt; Î¦ (usually called a &lt;strong&gt;fragment&lt;/strong&gt;).&lt;br&gt;A reasoning method &lt;strong&gt;RM&lt;/strong&gt; is sound for Î¦ if for any set S âŠ† Î¦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if RM(S) is â€œsatisfiableâ€ then there is an interpretation satisfying all formulas in S&lt;/li&gt;
&lt;li&gt;if RM(S) is â€œunsatisfiableâ€ then there is no interpretation satisfying all formulas in S.&lt;/li&gt;
&lt;li&gt;A trivialçç¢ RM which on all inputs returns â€œdonâ€™t knowâ€ is a sound reasoning method&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Completeness&quot;&gt;1.2. Completeness&lt;/h3&gt;&lt;p&gt;A reasoning method RM is &lt;strong&gt;(refutationally) complete&lt;/strong&gt; for Î¦ if for any set&lt;br&gt;S âŠ† Î¦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if S is unsatisfiable then RM(S) is terminating and returns â€œunsatisfiableâ€&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Security" scheme="https://hejueyun.github.io/categories/Security/"/>
    
    <category term="Automated Reasoning" scheme="https://hejueyun.github.io/categories/Security/Automated-Reasoning/"/>
    
    
    <category term="sec" scheme="https://hejueyun.github.io/tags/sec/"/>
    
  </entry>
  
</feed>
