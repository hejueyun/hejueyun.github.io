<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>烏巢</title>
    <link>https://hejueyun.github.io/</link>
    
    <image>
      <url>https://hejueyun.github.io/icon.png</url>
      <title>烏巢</title>
      <link>https://hejueyun.github.io/</link>
    </image>
    
    <atom:link href="https://hejueyun.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 24 Apr 2023 13:26:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>见过的一些值得记录的相机与镜头-2</title>
      <link>https://hejueyun.github.io/posts/3ae6db23/</link>
      <guid>https://hejueyun.github.io/posts/3ae6db23/</guid>
      <pubDate>Mon, 24 Apr 2023 13:26:04 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://hejueyun.github.io/posts/3ae6db23/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>见过的一些值得记录的相机与镜头-1</title>
      <link>https://hejueyun.github.io/posts/a3ef8a99/</link>
      <guid>https://hejueyun.github.io/posts/a3ef8a99/</guid>
      <pubDate>Thu, 09 Feb 2023 15:23:01 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;相机&quot;&gt;1. 相机&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;军旗木制烟囱机 Ensign Special reflex Tropical Model&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“热带”型号一向是收藏家追捧的热点，尽管这台相机成色非常的差，木头已经龟裂。但还是被拍卖到了近200磅。这个价格去买一个成色完美的非热带的普通型号都绰绰有余。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3ef8a99/11.jpg&quot; width=&quot;500&quot;&gt;&lt;/center&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;柯达格拉菲 Kodak RB Cycle Graphic camera 5x7&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;轨道能延展这么长的饭盒5x7相机属实不容易，还有旋转后背，放到今天也是相当能打。产量稀少，据说只有500台。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3ef8a99/16.jpg&quot; width=&quot;500&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3ef8a99/17.jpg&quot; width=&quot;500&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3ef8a99/18.jpg&quot; width=&quot;500&quot;&gt;&lt;/center&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Ross &amp;amp; Co London Magazine Camera&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="相机">1. 相机</h2><ol><li>军旗木制烟囱机 Ensign Special reflex Tropical Model</li></ol><p>“热带”型号一向是收藏家追捧的热点，尽管这台相机成色非常的差，木头已经龟裂。但还是被拍卖到了近200磅。这个价格去买一个成色完美的非热带的普通型号都绰绰有余。</p><center><img loading="lazy" src="/posts/a3ef8a99/11.jpg" width="500"></center><ol start="2"><li>柯达格拉菲 Kodak RB Cycle Graphic camera 5x7</li></ol><p>轨道能延展这么长的饭盒5x7相机属实不容易，还有旋转后背，放到今天也是相当能打。产量稀少，据说只有500台。</p><center><img loading="lazy" src="/posts/a3ef8a99/16.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/17.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/18.jpg" width="500"></center><ol start="3"><li>Ross &amp; Co London Magazine Camera</li></ol><p>神奇的杂志相机。外形酷似老式box camera</p><center><img loading="lazy" src="/posts/a3ef8a99/19.jpg" width="500"></center><ol start="4"><li>Dawes Instruments 4x5</li></ol><center><img loading="lazy" src="/posts/a3ef8a99/21.jpg" width="500"></center><ul><li>新闻机，带焦平面快门。似乎是全金属的</li></ul><h2 id="镜头">2. 镜头</h2><ol><li>大型痞子瓦 Watson&amp;Sons F4 PETZVAL No3</li></ol><p>凡是带有Petzval标签的镜头都有着令人费解的热度。作为一个古老的镜头设计，放到今天无论是像差还是锐度都不太够用了。但不得不说，口味独特的人像摄影师还真就好“旋焦”、“大光圈”、“像差”这些玄学。不过话说回来，覆盖8x10，F4，W&amp;S这几个标签也确实值得推上高价。</p><center><img loading="lazy" src="/posts/a3ef8a99/12.jpg" width="500"></center><ol start="2"><li>施耐德 schneider D-Claron 210mm f5.6</li></ol><p>见过Repo-claron,C-claron和G-claron，有见过D-claron吗？D-claron用于将文档翻拍到微缩胶卷上，这意味着：①微距镜头但又不是1:1，②成像圈不会很大。这只210镜头官方推荐用于93x132,但实测无穷远可以覆盖5x7。</p><center><img loading="lazy" src="/posts/a3ef8a99/13.jpg" width="500"></center><ol start="3"><li>乌雷航空镜头 Wray 36” F6.3 14A4246 Air Ministry</li></ol><p>36寸大光圈镜头，过于庞大导致放在今天几乎没有使用价值。</p><center><img loading="lazy" src="/posts/a3ef8a99/14.jpg" width="500"></center><ol start="4"><li>Aldis 20 INCH F&#x2F;6.3. AIR MINISTRY</li></ol><p>又一个超大航空镜头。此头有两个版本，分别标注为EE和VV。EE为5片3组xpres结构，aldis代工，无镀膜，非常重。VV为plasmat结构，ross生产，有镀膜，相对较轻。 有意思的是，这颗镜头同时标注了，VV和EE，然后VV的代码被划去了。神奇的错版镜头。</p><center><img loading="lazy" src="/posts/a3ef8a99/15.jpg" width="500"></center><ol start="5"><li>刀梅2B Dallmeyer 2B Petzval 8.25 inch f3.1</li></ol><p>知识盲区</p><center><img loading="lazy" src="/posts/a3ef8a99/4.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/5.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/6.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/8.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/4.jpg" width="500"></center><ol start="6"><li>徕兹 Leitz Epis F&#x3D;40cm 1:3,6 Lens.</li></ol><p>看样子像是投影镜头，知识盲区不予评价</p><center><img loading="lazy" src="/posts/a3ef8a99/20.jpg" width="500"></center><h2 id="配件">3. 配件</h2><ol><li>1&#x2F;2板转4x5片夹适配器</li></ol><p>目前1&#x2F;2干板相机大多都挺便宜，成色好制作精良的相机稍微蹲一蹲就能蹲到，但是使用上非常的麻烦，1&#x2F;2胶片只能去定制。有了这个片夹转换器就可以当45机器拍了。</p><center><img loading="lazy" src="/posts/a3ef8a99/10.png" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/1.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/2.jpg" width="500"></center><center><img loading="lazy" src="/posts/a3ef8a99/3.jpg" width="500"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Photography/">Photography</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/a3ef8a99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ESBMC增强：从递归到迭代</title>
      <link>https://hejueyun.github.io/posts/caf5b5e3/</link>
      <guid>https://hejueyun.github.io/posts/caf5b5e3/</guid>
      <pubDate>Tue, 07 Feb 2023 19:49:18 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;递归的类型&quot;&gt;1. 递归的类型&lt;/h2&gt;&lt;h3 id=&quot;Direct&quot;&gt;1.1. Direct&lt;/h3&gt;&lt;h3 id=&quot;Indirect&quot;&gt;1.2. Indirect&lt;/h3&gt;&lt;p&gt;先考虑最简单的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一个函数：&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;tail&quot;&gt;1.3. tail&lt;/h3&gt;&lt;p&gt;Tail Recursion: If a recursive function calling itself and that recursive call is the last statement in the function then it’s known as Tail Recursion. After that call the recursive function performs nothing. The function has to process or perform any operation at the time of calling and it does nothing at returning time.&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Last statement in the function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fun(n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;Mutual-Recursion-–-indirect&quot;&gt;1.4. Mutual Recursion – indirect&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;funA&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Fun(A) is calling fun(B)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        funB(n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;funB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;%d &amp;quot;&lt;/span&gt;, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Fun(B) is calling fun(A)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        funA(n / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="递归的类型">1. 递归的类型</h2><h3 id="Direct">1.1. Direct</h3><h3 id="Indirect">1.2. Indirect</h3><p>先考虑最简单的情况</p><ul><li>找到一个函数：</li></ul><h3 id="tail">1.3. tail</h3><p>Tail Recursion: If a recursive function calling itself and that recursive call is the last statement in the function then it’s known as Tail Recursion. After that call the recursive function performs nothing. The function has to process or perform any operation at the time of calling and it does nothing at returning time.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Last statement in the function</span></span><br><span class="line">        fun(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutual-Recursion-–-indirect">1.4. Mutual Recursion – indirect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">funA</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Fun(A) is calling fun(B)</span></span><br><span class="line">        funB(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">funB</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Fun(B) is calling fun(A)</span></span><br><span class="line">        funA(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>solution: track the recursive </p></li><li><p>how to optimise</p></li><li><p>basic idea: you create your own stack instead of the stack in system memory</p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://hejueyun.github.io/posts/caf5b5e3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>区块链和智能合约背景知识</title>
      <link>https://hejueyun.github.io/posts/d95176f7/</link>
      <guid>https://hejueyun.github.io/posts/d95176f7/</guid>
      <pubDate>Tue, 31 Jan 2023 09:10:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Web-1-x2F-2-x2F-3-0&quot;&gt;1. Web 1&amp;#x2F;2&amp;#x2F;3.0&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Web 1.0 是单向的。大公司创造了供人们阅读的内容，几乎没有交互，用户只能读取数据，只有内容创造者才能编辑和创作内容。所以，就像在图书馆看书一样，用户没有太多权利，他们只是消费者。&lt;/li&gt;
&lt;li&gt;Web 2.0允许用户自主上传内容，分享内容；&lt;/li&gt;
&lt;li&gt;Web 3.0 区块链 DApp 更注重以用户为中心，它将排除中间人，我们不必依赖私人公司控制的巨大数据服务器，我们的个人数据将更加安全和私密。由于没有中心化服务器，所有数据都将在设备之间传播，人们可以自由访问它们。&lt;blockquote&gt;
&lt;p&gt;区块链技术堆栈提出了称为语义网的主题。语义网意味着理解 Web 内容的方法，就像人类行为，它与机器学习和人工智能相关联，试图教会计算机理解数据及其行为方式。在语义搜索中，搜索结果将更加准确和相关。Web 2.0 依赖于关键字，页面权限和域权限来对内容进行排名，但 Web 3 浏览器试图像人一样理解 Web 内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;区块链&quot;&gt;2. 区块链&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;区块链是一个全球性的&lt;strong&gt;去中心化分布式&lt;/strong&gt;数据库账本&lt;ul&gt;
&lt;li&gt;A blockchain is a digitally &lt;strong&gt;distributed&lt;/strong&gt;, &lt;strong&gt;decentralized&lt;/strong&gt;, public ledger that exists across a network.&lt;/li&gt;
&lt;li&gt;本质上就是个&lt;strong&gt;数据库&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这个技术平台是开放的、可编程的,它不仅能够记录金融 交易,还可以与智能合约相结合,记录并运行、维护几乎所有 有价值的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;“区块”：指的是数据和状态是按顺序批量或”区块”存储的。 如果你向别人发送 ETH，需要将交易数据添加到一个区块中才算成功。&lt;ul&gt;
&lt;li&gt;本质上就是数据库中的数据，是一组交易记录（狭义）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“链”：指的是每个区块加密引用其父块。 换句话说，区块被链接在一起。 在不改变所有后续区块的情况下，区块内数据是无法改变，但改变后续区块需要整个网络的共识&lt;/li&gt;
&lt;li&gt;“共识机制”：网络中的每台计算机都必须就每个新区块和链达成一致。 这些计算机被称为“节点”。 节点保证所有与区块链交互的人都有相同的数据。 要完成此分布式协议，区块链需要一个&lt;strong&gt;共识机制&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d95176f7/1.png&quot; width=&quot;500&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d95176f7/2.png&quot; width=&quot;500&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d95176f7/3.png&quot; width=&quot;500&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意chain和Linked List都被翻译成了链表，但区块“链”的链是指chain，而他的结构式栈stack&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Web-1-x2F-2-x2F-3-0">1. Web 1&#x2F;2&#x2F;3.0</h2><ul><li>Web 1.0 是单向的。大公司创造了供人们阅读的内容，几乎没有交互，用户只能读取数据，只有内容创造者才能编辑和创作内容。所以，就像在图书馆看书一样，用户没有太多权利，他们只是消费者。</li><li>Web 2.0允许用户自主上传内容，分享内容；</li><li>Web 3.0 区块链 DApp 更注重以用户为中心，它将排除中间人，我们不必依赖私人公司控制的巨大数据服务器，我们的个人数据将更加安全和私密。由于没有中心化服务器，所有数据都将在设备之间传播，人们可以自由访问它们。<blockquote><p>区块链技术堆栈提出了称为语义网的主题。语义网意味着理解 Web 内容的方法，就像人类行为，它与机器学习和人工智能相关联，试图教会计算机理解数据及其行为方式。在语义搜索中，搜索结果将更加准确和相关。Web 2.0 依赖于关键字，页面权限和域权限来对内容进行排名，但 Web 3 浏览器试图像人一样理解 Web 内容。</p></blockquote></li></ul><h2 id="区块链">2. 区块链</h2><ul><li>区块链是一个全球性的<strong>去中心化分布式</strong>数据库账本<ul><li>A blockchain is a digitally <strong>distributed</strong>, <strong>decentralized</strong>, public ledger that exists across a network.</li><li>本质上就是个<strong>数据库</strong></li></ul></li><li>这个技术平台是开放的、可编程的,它不仅能够记录金融 交易,还可以与智能合约相结合,记录并运行、维护几乎所有 有价值的东西</li></ul><hr><ul><li>“区块”：指的是数据和状态是按顺序批量或”区块”存储的。 如果你向别人发送 ETH，需要将交易数据添加到一个区块中才算成功。<ul><li>本质上就是数据库中的数据，是一组交易记录（狭义）</li></ul></li><li>“链”：指的是每个区块加密引用其父块。 换句话说，区块被链接在一起。 在不改变所有后续区块的情况下，区块内数据是无法改变，但改变后续区块需要整个网络的共识</li><li>“共识机制”：网络中的每台计算机都必须就每个新区块和链达成一致。 这些计算机被称为“节点”。 节点保证所有与区块链交互的人都有相同的数据。 要完成此分布式协议，区块链需要一个<strong>共识机制</strong></li></ul><center><img loading="lazy" src="/posts/d95176f7/1.png" width="500"></center><center><img loading="lazy" src="/posts/d95176f7/2.png" width="500"></center><center><img loading="lazy" src="/posts/d95176f7/3.png" width="500"></center><ul><li><strong>注意chain和Linked List都被翻译成了链表，但区块“链”的链是指chain，而他的结构式栈stack</strong></li></ul><h3 id="区块链系统">2.1. 区块链系统</h3><ol><li>比特币(Bitcoin)</li><li>以太坊 (Ethereum)</li><li>超级账本(Hyperledger)</li></ol><p>…</p><ul><li>区块链的系统进化过程可以归纳为 3 个阶段:</li><li>区块链 1.0———数字货币; </li><li>区块链 2.0———数字资产与智能合约; </li><li>区块链 3.0———从 DAO(区块链自洽组织)、DAC(区块链自洽公司)到区块链社会(科学、医疗、教育等)</li></ul><blockquote><ul><li>其中,比特币、Litecoin、 Zcash 属于<strong>加密货币系统</strong></li><li>以太坊、超级账本、EOS、Parity 等 系统应用扩展到了<strong>数字资产与通用智能合约</strong>的范畴</li></ul></blockquote><h3 id="DAO">2.2. DAO</h3><ul><li>Decentralized autonomous organizations去中心化自治组织 <ul><li>是一种以公开透明的计算机代码来体现的组织，其受控于股东，并不受中央政府影响</li><li>Member-owned communities without centralized leadership. 解决中介问题</li><li>A safe way to collaborate with <strong>internet strangers</strong>. 解决信任问题</li><li>A safe place to commit funds to a specific cause</li></ul></li></ul><h3 id="分布式账本的优势">2.3. 分布式账本的优势</h3><ul><li>分布式账本可以描述为在不同地点和人员之间以分散形式维护的任何交易或合同的账本。</li><li>分布式账本的使用减少了网络攻击和金融欺诈</li><li>分布式账本还可以减少运营效率低下，加快完成交易所需的时间，并且是自动化的，因此可以 24&#x2F;7 全天候运行，所有这些都可以降低使用它们的实体的总体成本</li></ul><h3 id="吐槽">2.4. 吐槽</h3><ul><li><strong>区块链系统的本质——一个公钥系统，私钥签名，公钥加密！</strong></li><li>然后为了防止赖账，以往的做法是引入一个中间人C，然后A to C C to B，现在不过是让所有人当中间人，看似去中心化，实际上所有人都是中心</li><li>鼓励大家保持电脑开机，保持这个中间人一直存在，会给一些奖励</li><li>然后挖矿就是数学难题，为什么要计算这个数学难题呢，本质上就和高考一样，是一种证明：高考证明我智力很高；挖矿证明自己电脑算力（其实就是配置）很好，更有作为中间人的资格</li><li>当然，某种程度上分布式账本还是具有优势的，比如有时候超远距离交易需要太多中间人？以及成本优势？（本质上就是机器便宜但人力成本更贵？）</li></ul><h2 id="比特币">3. 比特币</h2><ul><li>比特币的关键创新开始：它教会了世界如何 在没有可信第三方的情况下远距离转移价值。比特币开启了点对点电子价值转移的可能性</li><li>类似比特币的系统是建立在我开始称之为“复制的、共享的账本”（<strong>“replicated, shared ledgers”</strong>）的东西之上的。 也就是说：网络中的每个完整参与者都拥有交易分类帐的完整副本，而系统的“魔力”在于它如何确保每个人的副本与其他人的副本保持一致（ <strong>makes sure that everybody’s copy stays in step with everybody else’s</strong>）</li></ul><blockquote><p>以太坊的去中心化程度相对比特币就差很多，现在存在以太坊基金会以及V神（以太坊的实际创造者）等中心，ETH与ETC的分叉事件，充分说明了V神的绝对话语权，他说谁是正宗以太坊谁就是。最严重的问题还是以太坊的全节点数量太少。由于过度膨胀的区块数据，运行以太坊节点不再是普通人甚至普通团体能胜任的。成功同步以太坊区块数据需要极高的宽带以及存储资源，目前全球的以太坊全节点可能不足5个，一旦面临强力打压，会直接死掉</p></blockquote><h2 id="以太坊">4. 以太坊</h2><ul><li>以太坊是一个开源的支持智能合约功能的公共区块链平台</li></ul><blockquote><p>以太坊采用权益证明共识机制。 任何想在链上添加新区块的人都需要往存款合约里至少质押 32 个以太币并运行验证者软件。 然后，他们会被随机选择去提议区块，其他验证者检查区块并将其添加入区块链。 在这种模型中，通常只有一条链，但由于网络延迟和不诚实的行为，可能导致多个区块存在于链头部附近的同一位置。 为解决此问题，一种分叉选择算法会选择一组规范区块。 选择的区块是构成权重可能最大的链的区块，“权重”是指认可区块的验证者数量（并以验证者质押的以太币加权）。 还有一种奖罚制度，大力鼓励参与者尽可能诚实并在线</p></blockquote><hr><ul><li>以太坊是<strong>可编程</strong>的区块链。它并不是给用户一系列预先设定好的操作（例如比特币交易），而是允许用户按照自己的意愿创建复杂的操作。 这样一来，它就可以作为多种类型去中心化区块链应用的平台，<strong>包括加密货币在内但并不仅限于此</strong>。</li><li>以太坊狭义上是指一系列定义去中心化应用平台的协议<ul><li><strong>区块链是数据库，以太坊是协议</strong></li></ul></li><li>，以太坊的核心是<strong>以太坊虚拟机</strong>（“EVM”），可以执行任意复杂算法的编码。 <ul><li>以太坊是“图灵完备的”。开发者能够使用现有的JavaScript和Python等语言为模型的其他友好的编程语言，创建出在以太坊模拟机上运行的应用</li></ul></li></ul><blockquote><p>所谓图灵完备,是指能用该编程语言模拟任何图灵机 .图灵完备的规则能够实现任何操作逻辑,例如,一种编程语言中包含条件控制语句 if,goto 等,并且能够维护任意 数量的变量,则可以编写出符合任何逻辑的代码,因此这种编 程语言具备图灵完备性</p><ul><li>比特币脚本是非图灵完备的，编写的智能合约交易模式非常有限,只能用于虚拟货币类应用</li></ul></blockquote><hr><ul><li>以太坊区块链数据库由众多连接到网络的节点来维护和更新。 每个网络节点都运行着以太坊模拟机并执行相同的指令。因此，人们有时形象地称以太坊为“<strong>世界电脑</strong>”</li><li>除金融类应用外，任何对信任、安全和持久性要求较高的应用场景————比如资产注册、投票、管理和物联网————都会大规模地受到以太坊平台影响</li></ul><h3 id="以太坊虚拟机">4.1. 以太坊虚拟机</h3><blockquote><p>While Ethereum has its own native cryptocurrency (Ether) that follows almost exactly the same intuitive rules, it also enables a much more powerful function: smart contracts. For this more complex feature, a more sophisticated analogy is required. <strong>Instead of a distributed ledger, Ethereum is a distributed state machine</strong>. Ethereum’s state is a large data structure which holds not only all accounts and balances, but <strong>a machine state, which can change from block to block according to a pre-defined set of rules, and which can execute arbitrary machine code</strong>. The specific rules of changing state from block to block are defined by the EVM</p><ul><li>以太坊不是分布式账本，而是分布式状态机器。 以太坊的状态是一个大型数据结构，它不仅保存所有帐户和余额，而且还保存一个机器状态，它可以根据预定义的一组规则在不同的区块之间进行更改，并且可以执行任意的机器代码。 在区块中更改状态的具体规则由 EVM 定义</li><li>EVM 的行为就像一个数学函数：在给定输入的情况下，它会产生确定性的输出。 因此，将以太坊更正式地描述为具有 状态转换函数非常有帮助</li></ul></blockquote><center><img loading="lazy" src="/posts/d95176f7/evm.png" width="500"></center><ul><li><em>类似一个操作系统</em></li></ul><hr><ul><li>World state：The world state is a mapping between address and account state</li></ul><center><img loading="lazy" src="/posts/d95176f7/4.png" width="500"></center><ul><li>An account is an object in the world state<ul><li>An account is a mapping between address and account</li><li>An account state could contain EVM code and storage</li></ul></li></ul><center><img loading="lazy" src="/posts/d95176f7/5.png" width="500"></center><p><strong>type</strong></p><ul><li>Externally-owned account (EOA)外部账户 – controlled by anyone with the private keys</li><li>Contract account合约账户 – <strong>a smart contract deployed to the network</strong>, controlled by code.</li></ul><center><img loading="lazy" src="/posts/d95176f7/6.png" width="500"></center><p>address</p><ul><li>相当于index<ul><li>A 160-bit code used for identifying account</li></ul></li></ul><center><img loading="lazy" src="/posts/d95176f7/7.png" width="500"></center><h2 id="智能合约">5. 智能合约</h2><ul><li>The transactions are performed by smart contracts, which are programs automatically executed on blockchain networks <strong>when specific conditions are met</strong><ul><li>智能合约的定义为:一段由事件驱动的、具有状态的、运行在一个复制的且分享的账本之上的、能够保管账本上资产的程序</li></ul></li></ul><blockquote><p>智能合约是以太坊账户的一种类型。这意味着它们有一个<strong>余额</strong>，且可以成为交易的目标。然而，它们不是由用户控制的，相反，它们被部署到网络上并按程序运行。然后，<strong>用户账户可以通过提交执行智能合约上定义的功能的交易来与智能合约互动</strong>。智能合约可以定义规则，就像普通合约一样，并通过代码自动执行这些规则。<strong>智能合约默认不能被删除，与它们的互动是不可逆转的</strong>。</p></blockquote><ul><li>相当于沙盒系统中一直再跑的守护程序，无法被杀掉，可以通过命令行与其交互执行</li></ul><h2 id="智能合约语言">6. 智能合约语言</h2><ul><li>以太坊提供了 2 种编程语言: Serpent和Solidity</li></ul><h3 id="Solidity">6.1. Solidity</h3><ul><li><p>Solidity 是一种“面向合约”(或面向对象)的高级编程语言,它是专门为编写运行在 EVM 上的智能合约而设计的. 其语法接近 JavaScript,并且支持强类型、继承、库以及用户自定义类型</p></li><li><p>solidty vs javascript</p><ul><li>安全上新引入问题？</li></ul></li></ul><h2 id="安全性问题">7. 安全性问题</h2><h3 id="区块链的安全性问题">7.1. 区块链的安全性问题</h3><ul><li>how is the ledger secured? How does the consensus process work? How are bad guys kept at bay?</li></ul><h3 id="智能合约的安全性问题">7.2. 智能合约的安全性问题</h3><blockquote><p>Although smart contract programming in many ways resembles traditional programming, it raises important new security challenges. Contracts are “play-for-keeps”, since virtual currencies have real value. If you load money into a buggy smart contract, you will likely lose it. Further, <strong>smart contract programming requires an “economic thinking” perspective that traditional programmers may not have acquired.</strong> Contract must be written to ensure fairness even when counterparties may attempt to cheat in arbitrary ways that maximize their economic gain</p><ul><li>智能合约编程需要一种 “经济思维 “的观点，而传统的程序员可能没有掌握这种观点。合同的编写必须确保公平，即使对手方可能试图以任意的方式作弊，使其经济利益最大化。</li></ul></blockquote><h2 id="防范漏洞的方式">8. 防范漏洞的方式</h2><h2 id="参考">9. 参考</h2><ul><li>区块链系统中智能合约技术综述</li><li><a href="https://gendal.me/2015/02/10/a-simple-model-for-smart-contracts/">智能合约的简单模型 |  理查德·詹德尔·布朗</a></li><li><a href="https://ethereumdocch.readthedocs.io/zh/latest/index.html">Ethereum Homestead 中文文档 — Ethereum Homestead中文文档 0.1 文档</a></li><li><a href="https://ethereum.org/zh/developers/docs/">以太坊开发文档 | ethereum.org</a></li><li><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">ethereum-evm-illustrated - ethereum_evm_illustrated.pdf</a></li><li><a href="https://www.zhihu.com/question/432920175/answer/2013531587">比特币与以太坊的区别是什么? - 知乎</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/d95176f7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【外设】Doio Retro83键盘组装记录</title>
      <link>https://hejueyun.github.io/posts/d3be0bfc/</link>
      <guid>https://hejueyun.github.io/posts/d3be0bfc/</guid>
      <pubDate>Tue, 10 Jan 2023 11:18:58 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;&lt;p&gt;自从组了自己的PC之后，一直感觉自己缺了一把游戏专用的键盘——无论是Forkere 的SA键帽玩游戏还是加装了消音垫的cheap 60都相当累手，于是萌生了组一把游戏键盘的想法。因为是游戏键盘，所以尽量要减少组合键，重量上也不必有所顾及。最终，选择了Doio出品的Retro 83。1000元以内的价格，电泳，gasket，长佩列，现货，光就这几点就爆杀大部分阳极氧化还要加配重骗钱的键盘。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d3be0bfc/11.JPEG&quot; width=&quot;400px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;组装&quot;&gt;2. 组装&lt;/h2&gt;&lt;p&gt;83配列在现在算是比较少见的配列，相当于在GH60的基础上，加上3个控制键区的键，再加上完整的数字键区。但当初键盘发展史上曾经流行过这个配列。键盘名称中的”Retro”应该即是此意。不过，传统的83键是完整F区加右shift和4控制区，而Doio Retro是完整数字区加3个控制键区的键，还是有所区别。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d3be0bfc/1.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;

&lt;p&gt;值得肯定的是，Doio Retro 83（以下简称Retro 83）在设计上花费了不少心思。从整体方面看，最引人耳目的便是左侧的一块电路板，包含一块芯片和数组电容。电路板本身是不起任何功能的装饰，但确实让整个键盘geek和retro了起来。一个可能的隐患是对手感的影响，比如小拇指无处可依，但实测几乎没有太大影响。&lt;/p&gt;
&lt;p&gt;背面则做了镂空处理，可以直接看到键盘背板（未拍出）。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/d3be0bfc/4.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;

&lt;p&gt;在小细节上，retro 83同样颇具心思。由于是gasket结构，所以需要上下拼接，如果直接进行拼合会有一条不雅的细缝，而retro则是用一个亚克力中框来填充与过度。（事实上，Retro 83最初的设计就是简单的上下拼合。然而首发用户反馈，这种处理导致了“漏轴”。于是Doio团队紧急更改设计才加上了这个中框，通过垫高来解决漏轴）。出于装饰，Retro83的上框还增加了一层，左侧装饰区也做了内倒角（可惜键盘区没有）。这些小细节整个键盘的不那么单调（在此不点名批评某些毫无设计的铝块）。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前言">1. 前言</h2><p>自从组了自己的PC之后，一直感觉自己缺了一把游戏专用的键盘——无论是Forkere 的SA键帽玩游戏还是加装了消音垫的cheap 60都相当累手，于是萌生了组一把游戏键盘的想法。因为是游戏键盘，所以尽量要减少组合键，重量上也不必有所顾及。最终，选择了Doio出品的Retro 83。1000元以内的价格，电泳，gasket，长佩列，现货，光就这几点就爆杀大部分阳极氧化还要加配重骗钱的键盘。</p><center><img loading="lazy" src="/posts/d3be0bfc/11.JPEG" width="400px"></center><h2 id="组装">2. 组装</h2><p>83配列在现在算是比较少见的配列，相当于在GH60的基础上，加上3个控制键区的键，再加上完整的数字键区。但当初键盘发展史上曾经流行过这个配列。键盘名称中的”Retro”应该即是此意。不过，传统的83键是完整F区加右shift和4控制区，而Doio Retro是完整数字区加3个控制键区的键，还是有所区别。</p><center><img loading="lazy" src="/posts/d3be0bfc/1.JPG" width="500px"></center><p>值得肯定的是，Doio Retro 83（以下简称Retro 83）在设计上花费了不少心思。从整体方面看，最引人耳目的便是左侧的一块电路板，包含一块芯片和数组电容。电路板本身是不起任何功能的装饰，但确实让整个键盘geek和retro了起来。一个可能的隐患是对手感的影响，比如小拇指无处可依，但实测几乎没有太大影响。</p><p>背面则做了镂空处理，可以直接看到键盘背板（未拍出）。</p><center><img loading="lazy" src="/posts/d3be0bfc/4.JPG" width="500px"></center><p>在小细节上，retro 83同样颇具心思。由于是gasket结构，所以需要上下拼接，如果直接进行拼合会有一条不雅的细缝，而retro则是用一个亚克力中框来填充与过度。（事实上，Retro 83最初的设计就是简单的上下拼合。然而首发用户反馈，这种处理导致了“漏轴”。于是Doio团队紧急更改设计才加上了这个中框，通过垫高来解决漏轴）。出于装饰，Retro83的上框还增加了一层，左侧装饰区也做了内倒角（可惜键盘区没有）。这些小细节整个键盘的不那么单调（在此不点名批评某些毫无设计的铝块）。</p><p>Retro83的正面是无螺丝的，它的螺丝都藏在了背面。可惜我收的这把键盘的上一个主人在拆卸的过程中留下了刀痕。这是可以理解的，毕竟我一开始也将键盘拆开、加装一个消音棉的想法——由于漏背板的设计，Retro83没有官配消音垫。另外可以看到的一点是，Retro 83的电泳完成度还是在及格线上的，没有很多的颗粒，但仍然不够丝滑，漆面不够厚，算是美中不足吧。</p><center><img loading="lazy" src="/posts/d3be0bfc/5.JPG" width="500px"></center><p>这次组装使用的是TTC金兰轴。这个轴在上次改装Mojo Christian时给我留下了深刻印象，可以预期的非常适合打游戏。上两块钱的轴不用润，到手即用。金兰轴额外的一个优点是透明上盖，这点在一定程度上影响了我键帽的选择。</p><center><img loading="lazy" src="/posts/d3be0bfc/6.JPG" width="500px"></center><p>卫星轴非常稳固。黑金PCB非常漂亮，可以看到型号是KB83-01。</p><center><img loading="lazy" src="/posts/d3be0bfc/7.JPG" width="500px"></center><p>键帽的选择是凡思透明PC材质原厂高度有刻键帽，选择这个键帽的原因：①契合键盘整体“探索风格”，将内部结构外露 ②这个键盘主要是用于打游戏，所以需要尽可能的展示光效。整套键帽用着感觉非常的滑，字符似乎是UV覆膜。唯一想要吐槽的是，凡思用自己的商标取代了回车键符号，简直是恶心至极。</p><center><img loading="lazy" src="/posts/d3be0bfc/2.JPG" width="500px"></center><p>数据线选课akko的航插线。无他，便宜耳。但代价就是极低的素质，和geek cable完全无法比拟。首先航插头很小，质感很垃。线材也比较细，荧光更是不用想了，唯一的好处大概就是比较长吧。最令人想吐槽的是，航插头实际上不是插上去的，而是靠螺纹旋紧的…</p><center><img loading="lazy" src="/posts/d3be0bfc/8.JPG" width="500px"></center><p>Retro 83预留的type-c口正常大小，有好有坏吧…可能较粗的头就没法使用了</p><center><img loading="lazy" src="/posts/d3be0bfc/9.JPG" width="500px"></center><p>整个键盘的灯效还是比较丰富的，不过我个人还是比较喜欢单色白背光。</p><center><img loading="lazy" src="/posts/d3be0bfc/3.JPG" width="500px"></center><h2 id="价格列表及配列图">3. 价格列表及配列图</h2><table><thead><tr><th></th><th>价格</th></tr></thead><tbody><tr><td>键盘套件</td><td>888</td></tr><tr><td>金兰轴(88颗)</td><td>200</td></tr><tr><td>键帽</td><td>129</td></tr><tr><td>航插线</td><td>50</td></tr><tr><td></td><td>1267</td></tr></tbody></table><hr><p>KB83-01采用VIA进行改键，去Doio的QQ群把json文件下下来然后import就行，整体使用下来还是非常方便的。Bug就是不能改灯效，但可以用其他方式曲线救国，所以无伤大雅。</p><center><img loading="lazy" src="/posts/d3be0bfc/10.PNG" width="500px"></center><h2 id="后记">4. 后记</h2><p>组完这把键盘后，我估计会很长一段时间不再碰键圈了。目前键圈收智商税的现象极其严重，甚至出现了“集邮”的现象——小到Matrix的配重，大到外壳色卡。而且gasket的结构也渐渐违背了最初发明的目的——即解决手感的不一致。如今gasket反而去追求所谓绵软的手感，属实是南辕北辙。价格上也开始大跃进，基本看不到千元以内的套件了。或许退圈才是当下最好的选择，我想。</p>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/toys/">杂玩</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/d3be0bfc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【相机】宾得KP</title>
      <link>https://hejueyun.github.io/posts/b91a5246/</link>
      <guid>https://hejueyun.github.io/posts/b91a5246/</guid>
      <pubDate>Mon, 26 Dec 2022 05:29:28 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;&lt;h2 id=&quot;操作简介&quot;&gt;2. 操作简介&lt;/h2&gt;&lt;h2 id&gt;3. &lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前言">1. 前言</h2><h2 id="操作简介">2. 操作简介</h2><h2 id>3. </h2>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Photography/">Photography</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/b91a5246/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【相机】Microcord Type-1</title>
      <link>https://hejueyun.github.io/posts/6494334c/</link>
      <guid>https://hejueyun.github.io/posts/6494334c/</guid>
      <pubDate>Wed, 23 Nov 2022 21:25:49 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;拆解&quot;&gt;1. 拆解&lt;/h2&gt;&lt;p&gt;之前打包买相机的时候包括了一台英国MPP公司出产的双反Microcord。经检查，镜头镀膜脱落，自动停片失效，光圈调节旋钮卡死，慢门速度不准。虽然外观成色不错，但这机器的好成色也是随便买，所以干脆当作练手的尸体机拆开看看到底问题是啥，并看看有什么值得拿下来的东西。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/1.JPG&quot; width=&quot;400px&quot;&gt;&lt;/center&gt;

&lt;p&gt;撕掉前面板的饰皮，将所有可见螺丝卸下，然而此时前脸和前组都无法完全拆除。这是因为前脸和前组通过交错的方式卡死，而前组和机身通过视差联动杆相连接。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/2.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/3.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/4.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;

&lt;p&gt;卸下联动杆图中的螺丝即可将整个前组拆除。&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/5.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6494334c/6.JPG&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="拆解">1. 拆解</h2><p>之前打包买相机的时候包括了一台英国MPP公司出产的双反Microcord。经检查，镜头镀膜脱落，自动停片失效，光圈调节旋钮卡死，慢门速度不准。虽然外观成色不错，但这机器的好成色也是随便买，所以干脆当作练手的尸体机拆开看看到底问题是啥，并看看有什么值得拿下来的东西。</p><center><img loading="lazy" src="/posts/6494334c/1.JPG" width="400px"></center><p>撕掉前面板的饰皮，将所有可见螺丝卸下，然而此时前脸和前组都无法完全拆除。这是因为前脸和前组通过交错的方式卡死，而前组和机身通过视差联动杆相连接。</p><center><img loading="lazy" src="/posts/6494334c/2.JPG" width="500px"></center><center><img loading="lazy" src="/posts/6494334c/3.JPG" width="500px"></center><center><img loading="lazy" src="/posts/6494334c/4.JPG" width="500px"></center><p>卸下联动杆图中的螺丝即可将整个前组拆除。</p><center><img loading="lazy" src="/posts/6494334c/5.JPG" width="500px"></center><center><img loading="lazy" src="/posts/6494334c/6.JPG" width="500px"></center><p>拆下前脸可以看到，光圈和快门的调节旋钮通过齿轮联动内部的两个大齿轮，这两个大齿轮则会联动镜头快门。这台相机光圈调节旋钮卡死，是由于内外齿轮联动的轴承卡死而无法旋转，目测可以通过上润滑油来解决。</p><p>相机镜组类似于大画幅&#x2F;皮腔机的结构，由一个前后组和Epsilon快门组成。Epsilon在英国产的皮腔机中极其常见，但素质比较一般。光圈通过光圈拨杆实现无极调节。快门范围为1秒至300分之一秒。这台相机在1秒以及二分之一秒快门偏慢（一般是自拍机所导致的）。在上弦后，快门只能在两个区间内调节：一是25分之一秒至1秒、T门和B门，二是25分之一秒至300分之一秒。</p><p>快门和前脸相固定的方式是通过压圈实现的，和大画幅镜头固定在镜头板的方法相似。</p><center><img loading="lazy" src="/posts/6494334c/7.JPG" width="500px"></center><center><img loading="lazy" src="/posts/6494334c/8.JPG" width="500px"></center><p>这颗77.5毫米Ross Xpres镜头的素质还是可圈可点的，尽管镀膜有些脱落，但无伤大雅。镜头拆除后没有光圈标识，需要自行打印粘贴一个光圈环。</p><blockquote><p>Mr Dell of MPP told of going to Ross to order this lens and insisting that a new design was required rather than a tired old drawing taken from a bottom drawer. The result in contemporary test bettered the German equivalent in the centre and was equal outside it in outer field areas.</p></blockquote><h2 id="点评">2. 点评</h2><p>这台相机的做工比我想像中的要好不少，消除了我使用MPP Mark VII大画幅相机时所留下的对MPP相机的偏见。比较大的槽点就是对焦屏比较暗，以及貌似没有自带的镜头盖。</p><h2 id="视频介绍">3. 视频介绍</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=987879792&bvid=BV1N44y1X7hX&cid=900997899&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Photography/">Photography</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/6494334c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【相机】Agfa Selecta-M</title>
      <link>https://hejueyun.github.io/posts/35a83251/</link>
      <guid>https://hejueyun.github.io/posts/35a83251/</guid>
      <pubDate>Mon, 14 Nov 2022 21:04:50 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;视频介绍&quot;&gt;1. 视频介绍&lt;/h2&gt;&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;
    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=945009275&amp;bvid=BV1AW4y1t7pS&amp;cid=889834347&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position:absolute; height: 100%; width: 100%;&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&quot;补充-amp-评价&quot;&gt;2. 补充&amp;amp;评价&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为了卖胶片而出相机，伊尔福如此、柯达如此，爱克发亦如此。在相机暗仓内部，贴有胶卷的广告（右侧，未拍出）&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/35a83251/4.jpg&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;机身和当时的德国相机潮流一样，又宽又大又重。下图可以看到这种转变的趋势。机身用料还是不错的，电镀水平一眼可见的优越，和我的其他老皮腔相机比起来天上地下。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/35a83251/1.jpg&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;取景器超级明亮，黄斑清晰，放大倍率目测0.9-0.95，可以双眼取景但略微有点不太舒服。&lt;/li&gt;
&lt;li&gt;连续拍摄1秒2张&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其余图片&quot;&gt;3. 其余图片&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/35a83251/2.jpg&quot; width=&quot;500px&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="视频介绍">1. 视频介绍</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=945009275&bvid=BV1AW4y1t7pS&cid=889834347&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div><h2 id="补充-amp-评价">2. 补充&amp;评价</h2><ul><li>为了卖胶片而出相机，伊尔福如此、柯达如此，爱克发亦如此。在相机暗仓内部，贴有胶卷的广告（右侧，未拍出）</li></ul><center><img loading="lazy" src="/posts/35a83251/4.jpg" width="500px"></center><ul><li>机身和当时的德国相机潮流一样，又宽又大又重。下图可以看到这种转变的趋势。机身用料还是不错的，电镀水平一眼可见的优越，和我的其他老皮腔相机比起来天上地下。</li></ul><center><img loading="lazy" src="/posts/35a83251/1.jpg" width="500px"></center><ul><li>取景器超级明亮，黄斑清晰，放大倍率目测0.9-0.95，可以双眼取景但略微有点不太舒服。</li><li>连续拍摄1秒2张</li></ul><h2 id="其余图片">3. 其余图片</h2><center><img loading="lazy" src="/posts/35a83251/2.jpg" width="500px"></center><center><img loading="lazy" src="/posts/35a83251/3.jpg" width="500px"></center><center><img loading="lazy" src="/posts/35a83251/5.jpg" width="500px"></center><center><img loading="lazy" src="/posts/35a83251/6.jpg" width="500px"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Photography/">Photography</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/35a83251/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dissertation: Fuzzing a Software Verifier</title>
      <link>https://hejueyun.github.io/posts/a9674538/</link>
      <guid>https://hejueyun.github.io/posts/a9674538/</guid>
      <pubDate>Tue, 26 Jul 2022 18:24:14 GMT</pubDate>
      
      <description>&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Authenticaiton Failed.&quot; data-whm=&quot;Authentication Error.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;3fb697aae307a73013d6734c744af705674df7bcb2e72f6f9476261d92499d69&quot;&gt;7ab9a17ca32127080b77e873e4f9e808db2d51ee809cd84e33fb316338269cbdbbd8674d6fc524144bd0a401286e5601cb9d9f75ab26fc38a0daa82b380117f0bddc5d2b3fdba87b6d8232f67afffd529cd69e217eff3228eff80cee7b7d22d9419d3a89bb526749ba515a7b74c22aa47f8cfa42ca9b12e074100cb2dbb886ef14d28c22a5345b63819b33328c59cadb1b5b9120c49030464d0067ce35e8913e&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-default&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-default&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-default&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-default&quot;&gt;Password Required.&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script data-pjax src=&quot;/lib/hbe.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/hbe.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Authenticaiton Failed." data-whm="Authentication Error.">  <script id="hbeData" type="hbeData" data-hmacdigest="3fb697aae307a73013d6734c744af705674df7bcb2e72f6f9476261d92499d69">7ab9a17ca32127080b77e873e4f9e808db2d51ee809cd84e33fb316338269cbdbbd8674d6fc524144bd0a401286e5601cb9d9f75ab26fc38a0daa82b380117f0bddc5d2b3fdba87b6d8232f67afffd529cd69e217eff3228eff80cee7b7d22d9419d3a89bb526749ba515a7b74c22aa47f8cfa42ca9b12e074100cb2dbb886ef14d28c22a5345b63819b33328c59cadb1b5b9120c49030464d0067ce35e8913e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password Required.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/a9674538/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>摄影随想-大画幅</title>
      <link>https://hejueyun.github.io/posts/b2cceb84/</link>
      <guid>https://hejueyun.github.io/posts/b2cceb84/</guid>
      <pubDate>Sun, 10 Jul 2022 16:13:23 GMT</pubDate>
      
      <description>&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Authenticaiton Failed.&quot; data-whm=&quot;Authentication Error.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;7127f69b3a61f1d038075cb20abb310377a2456ecc7bacb7ef0af0b4a93abb72&quot;&gt;5f3a913c3efbb6d02ba0af66f707e4879464ab65ffb6a0010833b9fccf364ebe581e9bb49d167449b80467bc3a3f1b4d445aba3c50ba043c99fe241606ec750cfa68b9196056aa5ffd352603c3751715c46904269f9174e44c87c10f0d7cb7d6096bbf5d43bb9cbbc685e3dbb51d728eadcddf70141ae11e1cdfdfc3b1be7aac2f0947ab2604365c3a5ac6f8cb3e39179e66fa9d6e816bea9a34bd21c1912b1b65cf62d0bbe8b340adbb52fff04b438f5c88e74a8b3f65f81ae1d0c39da1a28198acaf4b2ab5ec36c69e7d6c40763626bf42cfa7e07ed820431fe80ec91b0aa72564419b95058c8ada6d44fff205f7aa7aea0fcc537d8813c211a32ac088d7b3ef54f4b102af6b6ab98c10738af31fc4da2649225b9b32c562d460ffeea33678a255b3776e82efa64b7141699e3f3c5163ea81bf4ec9ec860677fdc920789792bc8909d7de204d4089eb2e82c07880a742724b106f3374a010aeaa269f1d1b24095bf1b5bb83b230960ed07096f22787d1c567f11153fd85126073b0d0ef299f33bd27c94c29defb008a8c548d17649308209c551feae6397ebc74cc49ad6125e38926667a77eba4981116cfae239d94fd446b9cb7e741e24572a740c9c3cdb2ba4c0583ebc76a587492f22b06903494ee06f3d94ccbaebcc60df51ddcb5ba1592f77727af8f88b31e3975c24bb514293ec7461c00c5aba182b047cd1d0785ae064b73712c40d94a72130581dc414ff0c0a4770b83835882717a4ffc2fce9a95f0365caaedffae489a07d8dc05d967d7bb56da6e5a01d167acec7504da80200a144064bba766d9552006197485c2d8f3cb67c64ea3aad99f72129431d1f8e31a7634a18d7ef056f3b05feddb98ee2ca3080a0b2cbef27da4710c99d6d379ce1525eba192e6b858138458390dbcf066004dea4e0f9b75e0ec9ace12f83430bbb14320b55d0a45dc9a0450a66e179f87743677a02298ba577043a97129e000982fae7cc8af40564887ba2fa8202fbb05dafc5c5b59c1f303eeca2343a8972a81a5508d9efdfa6182abd788e75a043f9aa053a06df8dc4fdfb18a738fe428eaf3b457cfb423c4a912ca6bd1c11730e7c1e33029f2ec0e4bdad8d73614b813db1295d37f19a6157a690519473b37ca413742674c272d18a55701d4965d168a8c10d058c613bf81065e9809da7981a0952632ed14f0bf62745e1d293329b7689cf3be80492cfac7c44433ea060004d5fba90f2ffd1e63cc9dfe4c3adfd19e0de4d88395059aceb0875022841988928815d28a4109654beca69593d3b7cc0100f202658f796a3ded8c53165304e09a8bee1c0af53b5ffdcc561b1a8df7966576e6b27da591ab6e6132fec23d4c0d6049164ea0f665991f2c496bba3957fdead586d50ed031f060b5b83330d84ac408eca0f4e91bf9101e8f22cc25215ae7eb1b41b3a4b7b7439ca46f510902514beca99f5182db8a864bd119c5af758732dd8d7921930ab39d867507cbbfd849b765925f2d61dbac50d6b26ecf61fee84d0e7ef5c88f94712a3d852c258ff123d3a12c38e489c02fec8e88da836ac3b0bf8ec2ba20ecf92a914f70ecd872ae140a0e8ded7014b4f1b3129767f58d35cb6bd8e803091f9b351fee76a7b109aa4e978d22f747202aafff9fab41a172fb6a4186b64e1d14b3afca70d936c5760363d35004c7eaef16cdb59a95ae916fde9b1a1c6024aa7bedb639ceff6f2425f9a08cc4c16308365bd92ae4bf2afeb747a275316a7090c5d69c438ae4bcea7d22750f00caa6a11893b7d63b4348cdfef4e5dc51a1fb8e62c3c8194dcd3ab913c2ed722879c785b7a4c4ab3e846c0840f13fed86cac285c50a27170d497750a04ee676bd5938f7742fc3f6dc1fa081c3c57480c782c8a459642b47a880b321b9de8928819040e751683db56a6ca421c66f1f34b3f6e2a38ef67a8393afadf78e3f3f04f0cf936ce070bbd3c3532cbd3e1842febd618e468f9efefbc8c767756b0966f752e823df625d96ad9c97be35a92e99b03dc47ca497bd684ebf79d51ddff4e9e3753f7970ea320bc6a7dc5a015dc2030c5541102956eec10111cdbbe516078adb2af486bf932037842c43824607ef376031b9b94b96af888506ae45f4e0ad8f60c9ae006ca888a98665163555df07df80f34bfde656ccddcb2ad4a38ebc14d5d693eceb59db2f0334ffe9c16e0966ba40a9933b2e52f50d848d5727e972be0fdf71f3f8eb31c3c9219f544e7c2281e2c48af9e3d5015ef4976d89b71d737ea6f1343eb1506a7c86b72f41723dd7fe9635a4acbac47d5eb804d857ed061d65a63d588fca31fed174e5ecbea914af09447f3ad93372f83cb7607ba4fe5b6328bb2279b514c87e4629f5a75a255fc1d95a2f376be2b83978446bf3504a594ac9236bb86732c8e8066ea69f967b9bd20eedfd0e7c36716dd806fdc2b1cb9f84cc36eee8d3ac71b3f7acfb8641333e8439d96663ef55af671737ae8f8327c6deba024e77517d87b6728af5dfc8771c29fcae577ed93f6570c81d1a74ef444a61f3aa36738f4406fcf9d145afb1a395adc9288398c7ae43535f4774568dd94474c215594eb7937bffb906ed8351d81c29133768d39e11aad8cc301422bbf1c84cee434a32219cd25a7a96277c352c5fd6681345496637dfe0b53bdfaac2db1adc784ab4f936c4a97a97f2f3eae63e3407d859f6e7a2cecbea7db2b30651ae852a09be715be7804a4c1e4490cdfa18d916401f736e09578a120e2e316ec85eaada740c59e63e9518e6e894afbac99172868267ba18790a528fc804da66d1f7e4e62e2749793dba00ccd1ee0047e50e1142eae76e8db80e5c19cf1996df7a810b4046e95c6900e4ffd463219a9ff947ff62e88a4280b760fac2740d778a89a46815020089aa681f5c64a494882eeafebf82a335f9799a5bd4c01635871c7b6a23ae177507699c9ada190c01b29718125f2fb78e2fc6e56725a0b8d5bcc35f813f359a09ce7161b7e22e949ebbbef0e0936da59cd93f6364957f487edc41b702d19afada4e20273d436ad9e84b8af65d3432019899d60ab14a52af6e4700cb1414571cc440e522220f1259dd20e964ade4b32f5d5df4e012ab6f5346da3da600aeb9bb57544a63db292b71baedd1e348be756732d657a55285571567279013e0ac154e321d60a4a3d17716d7197a321c21aa0b3a2866aaa95c09ff83730049a503bc8f5830acef1c259c36a19f0302dd637f6f8da2f021880f190dc39219a9285dd62f9b0e31d72c4aceba24923b3b499488ad1b36d22ce9fbb6f52e930a8143290742b1b2117ccf6508905a3d0af1afc7fb0dfc7cb452009efcd19bc37fe5d693845919f818910868c2c8c35a7ce4252099b18b697176eff26b58864c84d8c721b7c173e4cc5ef623ff12ecaa33ca6a0b9a34b08a4d1802d43a6562e565ad055e5b399518e832b7f63651e21bf3f230ffaf25de76abe127edfd1a4485316ae32e701e26cdbabdb644e95a9c72e2aed1a43b9eb3fb5a1c5258f2e4595e1369aa37ef12399cbb31839cbd0ba00006a357071d818f82641edcdf32ff649901c3469e341121185712e446f4253973a872eaa662d65c7d44210607a5809fe3e96b2c0f19705b37837fd882899b8a6ab06fc16d8141533a8f834ed77567e294c1979f1a5b577ca7e68bd84f9570e3eba3435b73ee67d20dc2bd2588f8fc884c44917e62d3d6814e27a16bc44a88696ae3e71e1d5bbd9b500c7b4135f0d35b04b96c23b0765dac0109786ca818e845863d4fdaee4e19fc2d14a799c487236a79f7c7cc183d575044e355311fb596bba16a306f0e73154d93222535241741199c8f915a95c1f4b0f214e00e7a4e79522760f13ada48a7d91664f4a40d70ca3010ffee84c5414ed893f939cba2bf6ad272f4f8ebbd4723145009068f5a0ba822f3b8970c980f589a024c58089ad3f6d4f6a13b51358cd7b4ae67564b9f9b8fcdf79d1b6ab027a87d9ee234c18b674cb96c37681af82df91802a8e13978f5de6e09e060c0a3d3273e27920ccc4e49d49b5afd056c667448631fddbbddab26fcfed79cb6d170964674758d04b40183af65039d0f9c9b87d1b06d7885aeee1e43b277e40fc9fd6860ee0779e419caeff457a3963cc6c28d471db3f64f4c2df7c1d103c12a53cabaecb0ed003095796b622bc21f85bb7205add18104074fbf291c7e1f9aee5b843c1a4586a76d7e7c64828cb9916a6c9f7be28c2c02f38c424a1543d39d6b0e4ea8e7f09f112002adb33824e4b3924fae1ea36028f36c0853d6eb4fadeeb19d3a896e240f45e98b51e68599cb4d4f52372763c4ef66e1e521b1f4a69a27c445b6ccf7871840e9fc09423ec69947fe88bdde20349c93435af3bf3a2fb6f54e9a613b71c70a13f4f167dd3e510dd077cf058eb97c146259dafdf2dd397395704b58eea630794a79903ab91fe75ead3a29d5e44921dcbfe2c47b39ac5c4ae7b06c0eb31baa0e6d8a8ff4cf9b14765826b4e2a639e3f30ee13ec29327ec0e30d507f7d90f3d8658584932d700aa1be1fedb6e6b334d1d7fe591435d422230e3bfbfe1063ebd5f9a97e745d2fa17f19a401da7c5c40a79f6c13c796ad543ec9ed584e51eae59ca7c26184271cb2cffd710eeab1d9ea2020d6203f6317cb5bcaf19eed0ae2032d4d32da5598806a65da31735a9e919406ca3a8ce15b16c9abc809dfb3b81dbdc783cf5590ca48d0aff05698bc62425ff013fc72ae4b753c2320168aca055c4fce15aae85226a4702dc8ee9c3df431dce95634944ff1ec8066e99499fc519b9076da71f46d43cbeaab5aab4d1cec1e3248de5ac79b05775f7e4fbb8149993a6528741c56779ce54206cdadfc031de7109162bd8353e4f859cc1f3d3371fcffe7002117e0c6031a2669e836fca938de82d44ea33b34037132002480b7ccc20106a0dc9abf13d168d17cfa61967dc855652a060206d6a8c05d7c80a03238a2c53400fa4eb2fdea55687b571fb0d8f67f601b45a00992326a907ae7cb57cea6e1f714e019814f45588e39aa315ba96fb3c68d5efb4c527fbfb4d827074cf389a649bd6a5e388392d898d57ca548f7b874d9c50cdcdc0043054d9e3ae0a5dc7913cc5986c4e8edf3c0b84ed6d7229895192c7eb3ae9d1732fe55c530bd1c0969995e034a66aa421c6f759f311a5815364b81620dfe2c8bca5b484d5a418b005d19881f50f4ead37009581a3be0ab6d0ed1d9a9d130df9af7ecd699a3d43fd5babb2e6795e39624ee9067f26eb12bb8120bba1f05d4e2f02dab46ed04dab86762cad026f9abdcee4ebae9eed6d770b91938c6c4f97d0bd3c2dcda6b72bb8dbcda26500692997362871a2d7c52b8a728102ca286948245346edf113a61a33755cb4d4fb7f248f9e2a7f10929355276f220b5cd04209370cee654b1aaaff3d1e72fd009fb20cfb0574800090db9691929abd4a376e4600075569f385d6156d53e6ca8c2d0391aa2b20c5f5995c021851d097e3651d67a02a3062356ae8f9e7b1788f0f5a644582aba997dc45cf4cea08d9c5cf3660891dbc048aed8784f1d871d438bae0aee577585e74f2df2dc661441eb24f1d806afb7cb1bc1d9222ffaa72f5518f400883916754e15e05b02994f4f4e6a2b24d2662242313da43eebe08a26d8c15ee9b6134421ece5f1846ae7da30d5ce13f6204e5bdc87ad4ceee0f22809e001b359c03fef3428c1af5db693bfb65975011640ff1d255e2ff3107f02d6e3f2d7bfd58f875854a4aed3bb0c0371e33208ee65d7589c6e1c11185b9d0cc7740a986635d61e11e5f27c2151c9010308f30e8c6d5d393695866f13a5695129b9316c0284e20332aa27d66814ccd394124d291858f1f42a9c4ddc5b212f8c593212c2ee837cdeec8a83919affa1b08bc21ff5f4f38f0999d8ae755de372d414ce9124f30a4954eeaddf7c88a48298c9f67a882230c231f1036a9f1da671f712ab2f4fe15ea666e692557ef3bb2e3cefc4fdab0e76782309b503bcf9055e6f3b9ed103fea8f441e707b76281f62eb41624bd83784206fd8600f5e04c8ce3bdb610bef999677b6ee7ad9ca371f4789fef19792304c6d98042a7831c825b6575a5793d5677ed28c42c4a7c65956383e1e1feeb9808f723077aa56b8c86274a6e8020baf76ef51e374547a62660aa15e8c9bd8652cf04674fca7191aef5407e1a78e8d62c28ee3109ead6f3ea350d210faba74672326b06ebcb3707a4cfd2d24b550f2c5896aa06e3dad7526d45ff00d60f974ad52036ff29e3b6c7b761090ccb3a54bf25d328e4d16d52eaea4d31c9b152f569ca8fb8087b0dfc76ad8cc2b25cc31217b1f321fd51a0a6b849eba9c4a364db3848d0265a0ea6f0cea2f8837f505690ea76099e851b56aa50b5ec9562622be4f73cf6cf3b1c7a460765def25c5372a8b4199a20657c29e236e2495a02145e4ce6cde7c6d8ea45adc4cd73d28845a7abde47fac73561b1ef18df6373cc060051204da4498f2a91ed7b612d732dec82ec7d444da1a0b1806f8b5c04652d6acdee1d42e731e7a3e26783fe091308074a295382d2c5287648f5a7b8e4aadf5b711255126f23c60049696b7868ef76a2c18a6789974360a5ad7d70e1aa4d0a1a75592b5a165de2d108628dd29586060c91d42fdc371460adcbaa749424f0ae4d358bb2df1eaa65ccc1b74a2c358a719907737a1b47400b442cc4457f31621f760bdcc8b502fd759791a47937098b66d99a65d5a00b1ef5e24d31c90695cbd9a5ad2f70e17016dab462bfeba40eb34fd6abe88c0fdf7b318a0f153f9e384dc32953829e14a02c0b338ec452af84f43d77bc13a15df71dacc6ca0468e702be75ff08f3e242b3736f7a59dbf711e436407f0b9b083e03c16cca6edb839d3856b43604a574fdbdc7a0a3285991049d98e203679831fa9346ccdbf285756fd18c85629e357b9976ea7ac923fcb7fdd91e863e0313b536cf13a26503b9544ffe2fdebab0887a6718777152aed5651846735b42a0ada13c6270c803c0ec8e2acb7edbaaee42300a8c8062417048357d7eaf193687eb5ae681bc9517873cc71687096c5787a450a7d4268bcbcdcdbbde69585b8bd6d1871bae42bbcf688552828791c26f3e0f91b54304cd8ce60cda13b459a8b79fc4119ecb6289db50b401d2f10e06778fe64fb8e2bc8793c133ddc97314a8a2776dbcba066a78767bc99cc7ec5669b9b54e143dcf16cfd8133de5ef2745906a7bea7cd91923a56ea987fd683bff6482a50771205029c1bba2f710c9fe55d5bae3ff9ec63c127b715b31b45aef5164eec4f7f605078ab76c9eeeda5c1b11153866cf080fee819ba45c65363954beb8410e67c57ffcb61eeeba52bc6b71cc1ef09917ad819da2dec077827347ff8b15c4b0a536e98f83f479c66838e2da88f04aafe4587bafbe0441c2f6cb39075ec7118f83adc17bd3311608e19670be5d29b8bdc54d3af22382a25f619305983968544c8af157ff428f1087baaea707e12f21232a4521ea293bfddc5ca5c15824ab016f94ec1812d75bea086babbdcc5a7ad1928d11538357bfc76d82113853845e59473eaca2fc4956d57ed1d6cc635a950bda5774a993d2fe8ecd0186b8bfcd1620b7f566b274e9e7f8f1e178b6004d0ba96104ddda1e054749aecb683a45fcd2000f6a3f19174ebfe1ddb0c564ccf81f5b7dbbfdfe952c9d2002b7ed504267a955137130f37743fee6bc347ca5b663f0f37fdb9aee577f465d739f769a5dabf1a7409c4975667147f17e4f459a0854c6ce27fe5bb6145554a75c61a81f7cf7d355aafaa2b9e0935cdec4a9266a8d55ee473e53c269037ec0b800837c5ce39df83c76fd10a9cef81efb69471d1b36528060f1e3de4db978d1adce10f235740d66c857c2c22b6b57ee0a81f2aab179d6a1426c73c33b50ec822c9531429922fb06889f56789fa2d22e146ad425d3990e36ccf27df9445546e6dcb60c34717ba3051f8fcfc77eabca6753858e3636aa83bbfb8337c8709ba0a4778e12f181c2881549d6842d5115b425f909d4d02f21cd075bbf26bd5bc86aa1c52577a6a94d602cec38f638aef32abfb19aefcceb555a82cee2e22d87f85fe3351d581d80c1af9c01be3f6107a35e869726f767ae42e7d5d66e08874725f6a94ccdb162100a6c5b85a753b7355b9b3742edc6098996511aebcbd60319747396b96c26c64754e5485c29828f1a12f285b7d4ca4d2aeb919c959a9ec9b7b8f6a9c56373f2bb3bd007e95a8cbdf00ac17e3601d1f23503dfe92ed03d1878b856ae646615670c44ab750179b7a704ac6faa293962b1ca7a55fe10b3f0af32100f3dc09c25abc681fbd0691ed17b272ef989c90b106baf9fa779ed50f5fb1ebda81b0d4df93c93f4570380bf1a8c4e858c7169f51833f&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-default&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-default&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-default&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-default&quot;&gt;Password Required.&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script data-pjax src=&quot;/lib/hbe.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/hbe.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Authenticaiton Failed." data-whm="Authentication Error.">  <script id="hbeData" type="hbeData" data-hmacdigest="7127f69b3a61f1d038075cb20abb310377a2456ecc7bacb7ef0af0b4a93abb72">5f3a913c3efbb6d02ba0af66f707e4879464ab65ffb6a0010833b9fccf364ebe581e9bb49d167449b80467bc3a3f1b4d445aba3c50ba043c99fe241606ec750cfa68b9196056aa5ffd352603c3751715c46904269f9174e44c87c10f0d7cb7d6096bbf5d43bb9cbbc685e3dbb51d728eadcddf70141ae11e1cdfdfc3b1be7aac2f0947ab2604365c3a5ac6f8cb3e39179e66fa9d6e816bea9a34bd21c1912b1b65cf62d0bbe8b340adbb52fff04b438f5c88e74a8b3f65f81ae1d0c39da1a28198acaf4b2ab5ec36c69e7d6c40763626bf42cfa7e07ed820431fe80ec91b0aa72564419b95058c8ada6d44fff205f7aa7aea0fcc537d8813c211a32ac088d7b3ef54f4b102af6b6ab98c10738af31fc4da2649225b9b32c562d460ffeea33678a255b3776e82efa64b7141699e3f3c5163ea81bf4ec9ec860677fdc920789792bc8909d7de204d4089eb2e82c07880a742724b106f3374a010aeaa269f1d1b24095bf1b5bb83b230960ed07096f22787d1c567f11153fd85126073b0d0ef299f33bd27c94c29defb008a8c548d17649308209c551feae6397ebc74cc49ad6125e38926667a77eba4981116cfae239d94fd446b9cb7e741e24572a740c9c3cdb2ba4c0583ebc76a587492f22b06903494ee06f3d94ccbaebcc60df51ddcb5ba1592f77727af8f88b31e3975c24bb514293ec7461c00c5aba182b047cd1d0785ae064b73712c40d94a72130581dc414ff0c0a4770b83835882717a4ffc2fce9a95f0365caaedffae489a07d8dc05d967d7bb56da6e5a01d167acec7504da80200a144064bba766d9552006197485c2d8f3cb67c64ea3aad99f72129431d1f8e31a7634a18d7ef056f3b05feddb98ee2ca3080a0b2cbef27da4710c99d6d379ce1525eba192e6b858138458390dbcf066004dea4e0f9b75e0ec9ace12f83430bbb14320b55d0a45dc9a0450a66e179f87743677a02298ba577043a97129e000982fae7cc8af40564887ba2fa8202fbb05dafc5c5b59c1f303eeca2343a8972a81a5508d9efdfa6182abd788e75a043f9aa053a06df8dc4fdfb18a738fe428eaf3b457cfb423c4a912ca6bd1c11730e7c1e33029f2ec0e4bdad8d73614b813db1295d37f19a6157a690519473b37ca413742674c272d18a55701d4965d168a8c10d058c613bf81065e9809da7981a0952632ed14f0bf62745e1d293329b7689cf3be80492cfac7c44433ea060004d5fba90f2ffd1e63cc9dfe4c3adfd19e0de4d88395059aceb0875022841988928815d28a4109654beca69593d3b7cc0100f202658f796a3ded8c53165304e09a8bee1c0af53b5ffdcc561b1a8df7966576e6b27da591ab6e6132fec23d4c0d6049164ea0f665991f2c496bba3957fdead586d50ed031f060b5b83330d84ac408eca0f4e91bf9101e8f22cc25215ae7eb1b41b3a4b7b7439ca46f510902514beca99f5182db8a864bd119c5af758732dd8d7921930ab39d867507cbbfd849b765925f2d61dbac50d6b26ecf61fee84d0e7ef5c88f94712a3d852c258ff123d3a12c38e489c02fec8e88da836ac3b0bf8ec2ba20ecf92a914f70ecd872ae140a0e8ded7014b4f1b3129767f58d35cb6bd8e803091f9b351fee76a7b109aa4e978d22f747202aafff9fab41a172fb6a4186b64e1d14b3afca70d936c5760363d35004c7eaef16cdb59a95ae916fde9b1a1c6024aa7bedb639ceff6f2425f9a08cc4c16308365bd92ae4bf2afeb747a275316a7090c5d69c438ae4bcea7d22750f00caa6a11893b7d63b4348cdfef4e5dc51a1fb8e62c3c8194dcd3ab913c2ed722879c785b7a4c4ab3e846c0840f13fed86cac285c50a27170d497750a04ee676bd5938f7742fc3f6dc1fa081c3c57480c782c8a459642b47a880b321b9de8928819040e751683db56a6ca421c66f1f34b3f6e2a38ef67a8393afadf78e3f3f04f0cf936ce070bbd3c3532cbd3e1842febd618e468f9efefbc8c767756b0966f752e823df625d96ad9c97be35a92e99b03dc47ca497bd684ebf79d51ddff4e9e3753f7970ea320bc6a7dc5a015dc2030c5541102956eec10111cdbbe516078adb2af486bf932037842c43824607ef376031b9b94b96af888506ae45f4e0ad8f60c9ae006ca888a98665163555df07df80f34bfde656ccddcb2ad4a38ebc14d5d693eceb59db2f0334ffe9c16e0966ba40a9933b2e52f50d848d5727e972be0fdf71f3f8eb31c3c9219f544e7c2281e2c48af9e3d5015ef4976d89b71d737ea6f1343eb1506a7c86b72f41723dd7fe9635a4acbac47d5eb804d857ed061d65a63d588fca31fed174e5ecbea914af09447f3ad93372f83cb7607ba4fe5b6328bb2279b514c87e4629f5a75a255fc1d95a2f376be2b83978446bf3504a594ac9236bb86732c8e8066ea69f967b9bd20eedfd0e7c36716dd806fdc2b1cb9f84cc36eee8d3ac71b3f7acfb8641333e8439d96663ef55af671737ae8f8327c6deba024e77517d87b6728af5dfc8771c29fcae577ed93f6570c81d1a74ef444a61f3aa36738f4406fcf9d145afb1a395adc9288398c7ae43535f4774568dd94474c215594eb7937bffb906ed8351d81c29133768d39e11aad8cc301422bbf1c84cee434a32219cd25a7a96277c352c5fd6681345496637dfe0b53bdfaac2db1adc784ab4f936c4a97a97f2f3eae63e3407d859f6e7a2cecbea7db2b30651ae852a09be715be7804a4c1e4490cdfa18d916401f736e09578a120e2e316ec85eaada740c59e63e9518e6e894afbac99172868267ba18790a528fc804da66d1f7e4e62e2749793dba00ccd1ee0047e50e1142eae76e8db80e5c19cf1996df7a810b4046e95c6900e4ffd463219a9ff947ff62e88a4280b760fac2740d778a89a46815020089aa681f5c64a494882eeafebf82a335f9799a5bd4c01635871c7b6a23ae177507699c9ada190c01b29718125f2fb78e2fc6e56725a0b8d5bcc35f813f359a09ce7161b7e22e949ebbbef0e0936da59cd93f6364957f487edc41b702d19afada4e20273d436ad9e84b8af65d3432019899d60ab14a52af6e4700cb1414571cc440e522220f1259dd20e964ade4b32f5d5df4e012ab6f5346da3da600aeb9bb57544a63db292b71baedd1e348be756732d657a55285571567279013e0ac154e321d60a4a3d17716d7197a321c21aa0b3a2866aaa95c09ff83730049a503bc8f5830acef1c259c36a19f0302dd637f6f8da2f021880f190dc39219a9285dd62f9b0e31d72c4aceba24923b3b499488ad1b36d22ce9fbb6f52e930a8143290742b1b2117ccf6508905a3d0af1afc7fb0dfc7cb452009efcd19bc37fe5d693845919f818910868c2c8c35a7ce4252099b18b697176eff26b58864c84d8c721b7c173e4cc5ef623ff12ecaa33ca6a0b9a34b08a4d1802d43a6562e565ad055e5b399518e832b7f63651e21bf3f230ffaf25de76abe127edfd1a4485316ae32e701e26cdbabdb644e95a9c72e2aed1a43b9eb3fb5a1c5258f2e4595e1369aa37ef12399cbb31839cbd0ba00006a357071d818f82641edcdf32ff649901c3469e341121185712e446f4253973a872eaa662d65c7d44210607a5809fe3e96b2c0f19705b37837fd882899b8a6ab06fc16d8141533a8f834ed77567e294c1979f1a5b577ca7e68bd84f9570e3eba3435b73ee67d20dc2bd2588f8fc884c44917e62d3d6814e27a16bc44a88696ae3e71e1d5bbd9b500c7b4135f0d35b04b96c23b0765dac0109786ca818e845863d4fdaee4e19fc2d14a799c487236a79f7c7cc183d575044e355311fb596bba16a306f0e73154d93222535241741199c8f915a95c1f4b0f214e00e7a4e79522760f13ada48a7d91664f4a40d70ca3010ffee84c5414ed893f939cba2bf6ad272f4f8ebbd4723145009068f5a0ba822f3b8970c980f589a024c58089ad3f6d4f6a13b51358cd7b4ae67564b9f9b8fcdf79d1b6ab027a87d9ee234c18b674cb96c37681af82df91802a8e13978f5de6e09e060c0a3d3273e27920ccc4e49d49b5afd056c667448631fddbbddab26fcfed79cb6d170964674758d04b40183af65039d0f9c9b87d1b06d7885aeee1e43b277e40fc9fd6860ee0779e419caeff457a3963cc6c28d471db3f64f4c2df7c1d103c12a53cabaecb0ed003095796b622bc21f85bb7205add18104074fbf291c7e1f9aee5b843c1a4586a76d7e7c64828cb9916a6c9f7be28c2c02f38c424a1543d39d6b0e4ea8e7f09f112002adb33824e4b3924fae1ea36028f36c0853d6eb4fadeeb19d3a896e240f45e98b51e68599cb4d4f52372763c4ef66e1e521b1f4a69a27c445b6ccf7871840e9fc09423ec69947fe88bdde20349c93435af3bf3a2fb6f54e9a613b71c70a13f4f167dd3e510dd077cf058eb97c146259dafdf2dd397395704b58eea630794a79903ab91fe75ead3a29d5e44921dcbfe2c47b39ac5c4ae7b06c0eb31baa0e6d8a8ff4cf9b14765826b4e2a639e3f30ee13ec29327ec0e30d507f7d90f3d8658584932d700aa1be1fedb6e6b334d1d7fe591435d422230e3bfbfe1063ebd5f9a97e745d2fa17f19a401da7c5c40a79f6c13c796ad543ec9ed584e51eae59ca7c26184271cb2cffd710eeab1d9ea2020d6203f6317cb5bcaf19eed0ae2032d4d32da5598806a65da31735a9e919406ca3a8ce15b16c9abc809dfb3b81dbdc783cf5590ca48d0aff05698bc62425ff013fc72ae4b753c2320168aca055c4fce15aae85226a4702dc8ee9c3df431dce95634944ff1ec8066e99499fc519b9076da71f46d43cbeaab5aab4d1cec1e3248de5ac79b05775f7e4fbb8149993a6528741c56779ce54206cdadfc031de7109162bd8353e4f859cc1f3d3371fcffe7002117e0c6031a2669e836fca938de82d44ea33b34037132002480b7ccc20106a0dc9abf13d168d17cfa61967dc855652a060206d6a8c05d7c80a03238a2c53400fa4eb2fdea55687b571fb0d8f67f601b45a00992326a907ae7cb57cea6e1f714e019814f45588e39aa315ba96fb3c68d5efb4c527fbfb4d827074cf389a649bd6a5e388392d898d57ca548f7b874d9c50cdcdc0043054d9e3ae0a5dc7913cc5986c4e8edf3c0b84ed6d7229895192c7eb3ae9d1732fe55c530bd1c0969995e034a66aa421c6f759f311a5815364b81620dfe2c8bca5b484d5a418b005d19881f50f4ead37009581a3be0ab6d0ed1d9a9d130df9af7ecd699a3d43fd5babb2e6795e39624ee9067f26eb12bb8120bba1f05d4e2f02dab46ed04dab86762cad026f9abdcee4ebae9eed6d770b91938c6c4f97d0bd3c2dcda6b72bb8dbcda26500692997362871a2d7c52b8a728102ca286948245346edf113a61a33755cb4d4fb7f248f9e2a7f10929355276f220b5cd04209370cee654b1aaaff3d1e72fd009fb20cfb0574800090db9691929abd4a376e4600075569f385d6156d53e6ca8c2d0391aa2b20c5f5995c021851d097e3651d67a02a3062356ae8f9e7b1788f0f5a644582aba997dc45cf4cea08d9c5cf3660891dbc048aed8784f1d871d438bae0aee577585e74f2df2dc661441eb24f1d806afb7cb1bc1d9222ffaa72f5518f400883916754e15e05b02994f4f4e6a2b24d2662242313da43eebe08a26d8c15ee9b6134421ece5f1846ae7da30d5ce13f6204e5bdc87ad4ceee0f22809e001b359c03fef3428c1af5db693bfb65975011640ff1d255e2ff3107f02d6e3f2d7bfd58f875854a4aed3bb0c0371e33208ee65d7589c6e1c11185b9d0cc7740a986635d61e11e5f27c2151c9010308f30e8c6d5d393695866f13a5695129b9316c0284e20332aa27d66814ccd394124d291858f1f42a9c4ddc5b212f8c593212c2ee837cdeec8a83919affa1b08bc21ff5f4f38f0999d8ae755de372d414ce9124f30a4954eeaddf7c88a48298c9f67a882230c231f1036a9f1da671f712ab2f4fe15ea666e692557ef3bb2e3cefc4fdab0e76782309b503bcf9055e6f3b9ed103fea8f441e707b76281f62eb41624bd83784206fd8600f5e04c8ce3bdb610bef999677b6ee7ad9ca371f4789fef19792304c6d98042a7831c825b6575a5793d5677ed28c42c4a7c65956383e1e1feeb9808f723077aa56b8c86274a6e8020baf76ef51e374547a62660aa15e8c9bd8652cf04674fca7191aef5407e1a78e8d62c28ee3109ead6f3ea350d210faba74672326b06ebcb3707a4cfd2d24b550f2c5896aa06e3dad7526d45ff00d60f974ad52036ff29e3b6c7b761090ccb3a54bf25d328e4d16d52eaea4d31c9b152f569ca8fb8087b0dfc76ad8cc2b25cc31217b1f321fd51a0a6b849eba9c4a364db3848d0265a0ea6f0cea2f8837f505690ea76099e851b56aa50b5ec9562622be4f73cf6cf3b1c7a460765def25c5372a8b4199a20657c29e236e2495a02145e4ce6cde7c6d8ea45adc4cd73d28845a7abde47fac73561b1ef18df6373cc060051204da4498f2a91ed7b612d732dec82ec7d444da1a0b1806f8b5c04652d6acdee1d42e731e7a3e26783fe091308074a295382d2c5287648f5a7b8e4aadf5b711255126f23c60049696b7868ef76a2c18a6789974360a5ad7d70e1aa4d0a1a75592b5a165de2d108628dd29586060c91d42fdc371460adcbaa749424f0ae4d358bb2df1eaa65ccc1b74a2c358a719907737a1b47400b442cc4457f31621f760bdcc8b502fd759791a47937098b66d99a65d5a00b1ef5e24d31c90695cbd9a5ad2f70e17016dab462bfeba40eb34fd6abe88c0fdf7b318a0f153f9e384dc32953829e14a02c0b338ec452af84f43d77bc13a15df71dacc6ca0468e702be75ff08f3e242b3736f7a59dbf711e436407f0b9b083e03c16cca6edb839d3856b43604a574fdbdc7a0a3285991049d98e203679831fa9346ccdbf285756fd18c85629e357b9976ea7ac923fcb7fdd91e863e0313b536cf13a26503b9544ffe2fdebab0887a6718777152aed5651846735b42a0ada13c6270c803c0ec8e2acb7edbaaee42300a8c8062417048357d7eaf193687eb5ae681bc9517873cc71687096c5787a450a7d4268bcbcdcdbbde69585b8bd6d1871bae42bbcf688552828791c26f3e0f91b54304cd8ce60cda13b459a8b79fc4119ecb6289db50b401d2f10e06778fe64fb8e2bc8793c133ddc97314a8a2776dbcba066a78767bc99cc7ec5669b9b54e143dcf16cfd8133de5ef2745906a7bea7cd91923a56ea987fd683bff6482a50771205029c1bba2f710c9fe55d5bae3ff9ec63c127b715b31b45aef5164eec4f7f605078ab76c9eeeda5c1b11153866cf080fee819ba45c65363954beb8410e67c57ffcb61eeeba52bc6b71cc1ef09917ad819da2dec077827347ff8b15c4b0a536e98f83f479c66838e2da88f04aafe4587bafbe0441c2f6cb39075ec7118f83adc17bd3311608e19670be5d29b8bdc54d3af22382a25f619305983968544c8af157ff428f1087baaea707e12f21232a4521ea293bfddc5ca5c15824ab016f94ec1812d75bea086babbdcc5a7ad1928d11538357bfc76d82113853845e59473eaca2fc4956d57ed1d6cc635a950bda5774a993d2fe8ecd0186b8bfcd1620b7f566b274e9e7f8f1e178b6004d0ba96104ddda1e054749aecb683a45fcd2000f6a3f19174ebfe1ddb0c564ccf81f5b7dbbfdfe952c9d2002b7ed504267a955137130f37743fee6bc347ca5b663f0f37fdb9aee577f465d739f769a5dabf1a7409c4975667147f17e4f459a0854c6ce27fe5bb6145554a75c61a81f7cf7d355aafaa2b9e0935cdec4a9266a8d55ee473e53c269037ec0b800837c5ce39df83c76fd10a9cef81efb69471d1b36528060f1e3de4db978d1adce10f235740d66c857c2c22b6b57ee0a81f2aab179d6a1426c73c33b50ec822c9531429922fb06889f56789fa2d22e146ad425d3990e36ccf27df9445546e6dcb60c34717ba3051f8fcfc77eabca6753858e3636aa83bbfb8337c8709ba0a4778e12f181c2881549d6842d5115b425f909d4d02f21cd075bbf26bd5bc86aa1c52577a6a94d602cec38f638aef32abfb19aefcceb555a82cee2e22d87f85fe3351d581d80c1af9c01be3f6107a35e869726f767ae42e7d5d66e08874725f6a94ccdb162100a6c5b85a753b7355b9b3742edc6098996511aebcbd60319747396b96c26c64754e5485c29828f1a12f285b7d4ca4d2aeb919c959a9ec9b7b8f6a9c56373f2bb3bd007e95a8cbdf00ac17e3601d1f23503dfe92ed03d1878b856ae646615670c44ab750179b7a704ac6faa293962b1ca7a55fe10b3f0af32100f3dc09c25abc681fbd0691ed17b272ef989c90b106baf9fa779ed50f5fb1ebda81b0d4df93c93f4570380bf1a8c4e858c7169f51833f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password Required.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/photography/">photography</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/b2cceb84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Detection of Software Vulnerabilities: Dynamic Analysis</title>
      <link>https://hejueyun.github.io/posts/6f7caca3/</link>
      <guid>https://hejueyun.github.io/posts/6f7caca3/</guid>
      <pubDate>Fri, 27 May 2022 15:20:05 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Testing-for-functionality-vs-testing-for-security&quot;&gt;1. Testing for functionality vs testing for security&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A majority of security defects and vulnerabilities in software are not directly related to functionality&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i.e. Side-channel effect in the hardware 侧信道&lt;/li&gt;
&lt;li&gt;information obtained from the impl. rather than weaknesses in the code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Traditional testing checks functionalities for sensible inputs and corner conditions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Security testing &lt;strong&gt;also&lt;/strong&gt; requires looking for the &lt;strong&gt;wrong, unwanted behavior for uncommon inputs&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;users&lt;/strong&gt; will complain about &lt;strong&gt;functional problems&lt;/strong&gt;, but &lt;strong&gt;hackers&lt;/strong&gt; will not complain about &lt;strong&gt;security problems&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To test a software system, we need:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;test suite&lt;/strong&gt;测试套件: a collection of input data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test oracle&lt;/strong&gt;测试准则: decides if a test succeeded or led to an error&lt;ul&gt;
&lt;li&gt;A test oracle consists of a long list, which &lt;strong&gt;for every individual test case, specifies what should happen&lt;/strong&gt;&lt;br&gt;– A simple test oracle: just looking &lt;strong&gt;if the application does not crash&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Code-Coverage-代码覆盖&quot;&gt;2. Code Coverage 代码覆盖&lt;/h2&gt;&lt;h3 id=&quot;Statement-Coverage-语句覆盖&quot;&gt;2.1. Statement Coverage 语句覆盖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;involves the execution of all the executable statements at least once&lt;ul&gt;
&lt;li&gt;涉及所有可执行语句的至少一次执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/6f7caca3/1.jpg&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;Decision-Coverage-判定覆盖&quot;&gt;2.2. Decision Coverage 判定覆盖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;reports the true or false outcomes of each Boolean expression (tough to achieve 100%) &lt;ul&gt;
&lt;li&gt;报告每个布尔表达式的真或假结果&lt;/li&gt;
&lt;li&gt;(decision outcomes exercised &amp;#x2F; total decision outcomes) * 100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Testing-for-functionality-vs-testing-for-security">1. Testing for functionality vs testing for security</h2><ul><li><p>A majority of security defects and vulnerabilities in software are not directly related to functionality</p><ul><li>i.e. Side-channel effect in the hardware 侧信道</li><li>information obtained from the impl. rather than weaknesses in the code</li></ul></li><li><p>Traditional testing checks functionalities for sensible inputs and corner conditions</p></li><li><p>Security testing <strong>also</strong> requires looking for the <strong>wrong, unwanted behavior for uncommon inputs</strong></p></li><li><p><strong>users</strong> will complain about <strong>functional problems</strong>, but <strong>hackers</strong> will not complain about <strong>security problems</strong></p></li></ul><p>To test a software system, we need:</p><ul><li><strong>test suite</strong>测试套件: a collection of input data</li><li><strong>test oracle</strong>测试准则: decides if a test succeeded or led to an error<ul><li>A test oracle consists of a long list, which <strong>for every individual test case, specifies what should happen</strong><br>– A simple test oracle: just looking <strong>if the application does not crash</strong></li></ul></li></ul><h2 id="Code-Coverage-代码覆盖">2. Code Coverage 代码覆盖</h2><h3 id="Statement-Coverage-语句覆盖">2.1. Statement Coverage 语句覆盖</h3><ul><li>involves the execution of all the executable statements at least once<ul><li>涉及所有可执行语句的至少一次执行</li></ul></li></ul><center><img loading="lazy" src="/posts/6f7caca3/1.jpg" width="600"></center><h3 id="Decision-Coverage-判定覆盖">2.2. Decision Coverage 判定覆盖</h3><ul><li>reports the true or false outcomes of each Boolean expression (tough to achieve 100%) <ul><li>报告每个布尔表达式的真或假结果</li><li>(decision outcomes exercised &#x2F; total decision outcomes) * 100</li></ul></li></ul><center><img loading="lazy" src="/posts/6f7caca3/2.jpg" width="600"></center><h3 id="Branch-Coverage-分支覆盖">2.3. Branch Coverage 分支覆盖</h3><ul><li>tests every outcome from the code to ensure that every branch is executed at least once<ul><li>测试代码中的每个结果，以确保每个分支至少被执行一次</li><li>(executed branches &#x2F; total branches)*100</li></ul></li></ul><center><img loading="lazy" src="/posts/6f7caca3/3.jpg" width="600"></center><h3 id="Condition-Coverage-条件覆盖">2.4. Condition Coverage 条件覆盖</h3><ul><li>reveals how the variables in the conditional statement are evaluated (logical operands)<ul><li>揭示了条件语句中的变量是如何被评估的（逻辑操作数）</li><li>(executed operands &#x2F; total operands)*100</li></ul></li></ul><center><img loading="lazy" src="/posts/6f7caca3/4.jpg" width="600"></center><ul><li><strong>Code coverage criteria</strong> to measure the <strong>test suite quality</strong><ul><li>Statement, decision, branch and condition coverage</li></ul></li><li>Statement coverage does not imply branch coverage</li><li>Other coverage criteria exists, e.g., modified condition&#x2F; decision coverage (MCDC), which is used to test <strong>avionics embedded software</strong>航空电子嵌入式软件</li></ul><h2 id="Dynamic-Detection">3. Dynamic Detection</h2><blockquote><p>Dynamic detection techniques <strong>execute a program</strong> and <strong>monitor the execution</strong> to detect <strong>vulnerabilities</strong></p></blockquote><ul><li><strong>How</strong> should one monitor an execution such that vulnerabilities are detected?</li><li><strong>How many</strong> and <strong>what</strong> program executions (i.e., for what input values) should one monitor?</li></ul><h3 id="Monitoring">3.1. Monitoring</h3><ul><li>In cases where a dynamic analysis is approximative, it can also generate false positives or false negatives, even though it operates on a concrete execution trace<ul><li>在动态分析是近似的情况下，它也可能产生假阳性或假阴性，尽管它是在具体的执行轨迹上操作的。</li></ul></li><li>For <strong>structured output generation vulnerabilities</strong>, the main challenge is that the intended structure of the generated output is often <strong>implicit</strong>. There exists <strong>no explicit specification</strong> that can be monitored.<ul><li>对于结构化输出的漏洞，主要的挑战是生成的输出的预期结构往往是<strong>隐性的</strong>。不存在可以被监控的明确规范。</li><li>For example, a monitor can use a <strong>fine-grained dynamic taint analysis</strong> to track the flow of untrusted input strings § flag a violation when untrusted input has an impact on the parse tree of the generated output<ul><li>例如，监控器可以使用<strong>细粒度的动态污点分析</strong>来跟踪不受信任的输入字符串的流向，当不受信任的输入对生成的输出的解析树产生影响时，就会标记出违规行为</li></ul></li></ul></li><li><strong>Assertions</strong>, <strong>pre-conditions</strong>, and <strong>post-conditions</strong> can be compiled into the code to provide a monitor for API vulnerabilities at testing time, even if the cost of these compiled-in run-time checks can be too high to use them in production code<ul><li>可以将断言、前条件和后条件编译到代码中，以便在测试时提供对API漏洞的监控，即使这些编译的运行时检查的成本太高，无法在生产代码中使用它们。</li></ul></li><li>Monitoring for race conditions is hard, but some approaches for monitoring data races on shared memory cells exist. E.g., by monitoring whether all shared memory accesses <strong>follow a consistent locking discipline</strong></li></ul><h4 id="Using-BAs-to-check-the-program">3.1.1. Using BAs to check the program</h4><center><img loading="lazy" src="/posts/6f7caca3/5.png" width="600"></center><blockquote><p>A <strong>never claim</strong> can be used to define system behavior … It is most commonly used to specify behavior that should never happen. The claim is defined as a series of propositions, or boolean expressions, on the system state that must become true in the sequence specified for the behavior of interest to be matched. </p><ul><li>never claim可以用来定义系统行为…<strong>它最常被用来指定永远不应该发生的行为</strong>。Claim被定义为一系列命题或布尔表达式，这些命题或布尔表达式在系统状态上必须按照指定的顺序成为真，才能与感兴趣的行为匹配。</li></ul></blockquote><ul><li>线性时序逻辑转换Büchi自动机: convert LTL to never claim</li><li>Theory: check product of model and never claim for accepting state</li><li>ESBMC<ul><li>run <strong>never claim program</strong> as a <strong>monitor thread</strong> concurrently with other program thread(s)<ul><li>no distinction between monitor thread and other threads</li></ul></li></ul></li></ul><h4 id="Ensuring-soundness-of-monitor-thread">3.1.2. Ensuring soundness of monitor thread</h4><center><img loading="lazy" src="/posts/6f7caca3/6.png" width="600"></center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atomic_begin</span>();</span><br><span class="line"><span class="built_in">assume</span>(trans_count &lt;= trans_seen + <span class="number">1</span>); </span><br><span class="line">trans_seen = trans_count;</span><br><span class="line"><span class="keyword">switch</span>(state) &#123; </span><br><span class="line">  <span class="keyword">case</span> T0_init:</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">assume</span>((<span class="number">1</span>)); </span><br><span class="line">      state = T0_init;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">assume</span>((!cexpr_1 &amp;&amp; cexpr_0)); </span><br><span class="line">      state = accept_S2; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">assume</span>(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> accept_S2: </span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">assume</span>((!cexpr_1)); </span><br><span class="line">      state = accept_S2; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">assume</span>(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">atomic_end</span>();</span><br></pre></td></tr></table></figure><center><img loading="lazy" src="/posts/6f7caca3/7.png" width="300"></center><p><strong>Problem</strong>: BMC forces program execution to eventually end, but BA are defined over infinite traces</p><ul><li>Solution:<ul><li>pretend final state extends infinitely</li><li>re-run monitor thread after program termination, with enough loop iterations to pass through each state twice</li><li>if an accepting state is visited at least twice while stuttering, BA accepts extended trace</li></ul></li></ul><h2 id="Fuzzing">4. Fuzzing</h2><ul><li>Challenge: generate executions of the program along paths that will lead to the discovery of new vulnerabilities<ul><li>how to systematically select appropriate inputs for a program under test</li></ul></li></ul><p>Fuzzing</p><ul><li>Basic idea: generate <strong>random inputs</strong> and check whether an application <strong>crashes</strong></li><li>Original fuzzing: generate long inputs and check whether the system crashes</li><li>Why would inputs ideally be very long?  <ul><li>To make it likely that buffer overruns cross segment boundaries so that the OS triggers a fault</li><li>所以一大区别是传统的需要很长，但结构性的不需要？</li></ul></li><li>Types<ul><li>very long string</li><li>blank strings</li><li>min&#x2F;max values of integers</li><li>zero and negative values</li><li>unique values, characters or keywords likely to trigger bugs</li></ul></li></ul><h3 id="Pros-amp-cons">4.1. Pros &amp; cons</h3><ul><li>Pros: Minimal effort: <ul><li>the test cases are automatically generated, and test oracle is is merely looking for crashes</li><li>Fuzzing of a C&#x2F;C++ binary can quickly give a good picture of the robustness of the code</li></ul></li><li>Cons: <ul><li>Fuzzers do not find all bugs</li><li>Crashes may be hard to analyze, but a crash is a true positive that something is wrong</li><li>For programs that take <strong>complex inputs</strong>, more work will be needed to get reasonable code coverage and hit unusual test cases 对于接受复杂输入的程序，需要做更多的工作来获得合理的代码覆盖率并击中不寻常的测试案例<ul><li>Leads to various studies on “smarter” fuzzers</li></ul></li></ul></li></ul><h3 id="Black-box-fuzzing">4.2. Black-box fuzzing</h3><blockquote><p>The generation of values depends on the program input&#x2F;output behaviour, and not on its internal structure</p><ul><li>值的产生取决于程序的输入&#x2F;输出行为，而不是其内部结构</li></ul></blockquote><ol><li><strong>Random testing</strong> （original fuzzing）<ol><li>input values are randomly sampled from the appropriate value domain</li></ol></li><li><strong>Grammar-based fuzzing</strong><ol><li>a model of the expected format of input values is taken into account during the generation of input values</li></ol></li><li><strong>Mutation-based fuzzing</strong><ol><li>the fuzzer is provided with <strong>typical input values</strong>; it generates <strong>new input values</strong> by performing <strong>small mutations</strong> on the provided input</li></ol></li></ol><ul><li>Use a model checker to produce an input that triggers the property violation</li></ul><p><strong>应用</strong></p><center><img loading="lazy" src="/posts/6f7caca3/13.png" width="600"></center><center><img loading="lazy" src="/posts/6f7caca3/14.png" width="600"></center><h4 id="AFL">4.2.1. AFL</h4><p>AFL (American Fuzzy Lop) takes an evolutionary approach to learn mutations based on measuring code coverage </p><ul><li>basic idea: if a mutation of the input triggers a new path through the code, then it is an exciting mutation; otherwise, the mutation is discarded<ul><li>如果输入的突变触发了代码的新路径，那么它就是一个令人兴奋的突变；否则，突变就会被丢弃</li></ul></li><li>Produce random mutations of the input and observe their effect on code coverage, AFL can learn what interesting inputs are<ul><li>产生输入的随机突变，观察它们对代码覆盖率的影响，AFL可以了解什么是有趣的输入 </li><li>也就是所谓的<strong>Coverage-Guided</strong></li></ul></li><li>Code instrumented to observe execution paths: – if source code is available, then use modified compiler; otherwise, run code in an emulator</li></ul><h3 id="White-box-fuzzing">4.3. White-box fuzzing</h3><blockquote><p>The internal structure of the program is analysed to assist in the generation of appropriate input values</p><ul><li>对程序的内部结构进行分析，以协助生成适当的输入值</li></ul></blockquote><ul><li>The primary systematic white-box fuzzing technique is a <strong>dynamic symbolic execution</strong><ul><li>Executes a program with concrete input values and builds at the same time a <strong>path condition</strong><ul><li>An <strong>expression</strong> that specifies the <strong>constraints</strong> on those input values that have to be fulfilled <strong>to take this specific execution path</strong></li></ul></li><li>Solve input values that do not satisfy the path condition of the current execution<ul><li>the fuzzer can make sure that these input values will drive the program to a different execution path, thus improving coverage 模糊器可以确保这些输入值将驱动程序进入不同的执行路径，从而提高覆盖率</li></ul></li></ul></li></ul><p><strong>Step</strong></p><ul><li>Combine <strong>fuzz testing</strong> with <strong>dynamic test generation</strong></li><li>Run the code with some initial input </li><li>Collect constraints on input with symbolic execution </li><li>Generate new constraints </li><li>Solve constraints with c**onstraint solver **</li><li>Synthesize合成 new inputs</li><li>Leverages Directed Automated Random Testing</li></ul><center><img loading="lazy" src="/posts/6f7caca3/9.png" width="600"></center><center><img loading="lazy" src="/posts/6f7caca3/10.png" width="600"></center><h3 id="BMC-for-Coverage-Test-Generation">4.4. BMC for Coverage Test Generation</h3><ol><li>Translate the program to an intermediate representation (IR) </li><li><strong>Add goals indicating the coverage</strong><ol><li>location, branch, decision, condition and path</li></ol></li><li>Symbolically execute IR to produce an SSA program </li><li>Translate the resulting SSA program into a logical formula </li><li><strong>Solve the formula iteratively to cover different goals</strong> </li><li>Interpret the solution to <strong>figure out the input conditions</strong></li><li>Spit吐出 those input conditions out as a test case</li></ol><center><img loading="lazy" src="/posts/6f7caca3/11.png" width="600"></center><p><strong>example</strong></p><ul><li><code>esbmc main.c lib/lib.c --error-label GOALX -I lib/</code></li></ul><center><img loading="lazy" src="/posts/6f7caca3/12.jpg" width="600"></center><h2 id="summary">5. summary</h2><center><img loading="lazy" src="/posts/6f7caca3/8.png" width="600"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Software-Security/">Software Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/6f7caca3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Detection of Software Vulnerabilities: Static Analysis</title>
      <link>https://hejueyun.github.io/posts/536aff33/</link>
      <guid>https://hejueyun.github.io/posts/536aff33/</guid>
      <pubDate>Thu, 05 May 2022 12:30:25 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Verification-vs-Validation&quot;&gt;1. Verification vs Validation&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Verification: “Are we building the product right?”  &lt;ul&gt;
&lt;li&gt;The software should conform to its specification&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Validation: “Are we building the right product?” &lt;ul&gt;
&lt;li&gt;The software should do what the user requires&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Verification and validation must be applied at each stage in the software process&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Static-and-Dynamic-Verification&quot;&gt;2. Static and Dynamic Verification&lt;/h2&gt;&lt;p&gt;static verification&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aka Software inspections&lt;/li&gt;
&lt;li&gt;Code analysis can prove the absence of errors but might subject to incorrect results&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dynamic verification&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aka Software testing&lt;/li&gt;
&lt;li&gt;The system is executed with test data&lt;/li&gt;
&lt;li&gt;Operational behaviour is observed&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/536aff33/1.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;The-V-model-of-development&quot;&gt;2.1. The V-model of development&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/536aff33/2.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Verification-vs-Validation">1. Verification vs Validation</h2><ul><li>Verification: “Are we building the product right?”  <ul><li>The software should conform to its specification</li></ul></li><li>Validation: “Are we building the right product?” <ul><li>The software should do what the user requires</li></ul></li><li>Verification and validation must be applied at each stage in the software process</li></ul><h2 id="Static-and-Dynamic-Verification">2. Static and Dynamic Verification</h2><p>static verification</p><ul><li>aka Software inspections</li><li>Code analysis can prove the absence of errors but might subject to incorrect results</li></ul><p>dynamic verification</p><ul><li>aka Software testing</li><li>The system is executed with test data</li><li>Operational behaviour is observed</li></ul><center><img loading="lazy" src="/posts/536aff33/1.png" width="600"></center><h3 id="The-V-model-of-development">2.1. The V-model of development</h3><center><img loading="lazy" src="/posts/536aff33/2.png" width="600"></center><h2 id="Detection-of-Vulnerabilities">3. Detection of Vulnerabilities</h2><ul><li><p>Detect the presence of vulnerabilities in the code during the development, testing, and maintenance</p></li><li><p>Trade-off between <strong>soundness</strong> and <strong>completeness</strong></p><ul><li>Achieving <strong>soundness</strong> requires reasoning about all executions of a program<ul><li>This can be done by static checking of the program code while making suitable abstractions of the executions</li></ul></li><li>Achieving <strong>completeness</strong> can be done by performing actual, concrete executions of a program that are witnesses to any vulnerability reported<ul><li>The analysis technique has to come up with concrete inputs for the program that triggers a vulnerability</li><li>A typical dynamic approach is software testing: the tester writes test cases with concrete inputs and specific checks for the outputs</li></ul></li></ul></li><li><p>Detection tools can use a <strong>hybrid混合 combination of static and dynamic analysis techniques</strong> to achieve a good trade-off between soundness and completeness</p></li><li><p><strong>Dynamic verification</strong> should be used in conjunction with <strong>static verification</strong> to provide <strong>full code coverage</strong></p></li></ul><h2 id="difference-among-static-analysis-testing-x2F-simulation-and-debugging">4. difference among static analysis, testing &#x2F; simulation, and debugging</h2><center><img loading="lazy" src="/posts/536aff33/3.jpg" width="600"></center><ul><li>Simulation<ul><li>Checks only <strong>some</strong> of the system executions, thus may miss errors</li></ul></li><li>Static analysis (BMC) <ul><li>Exhaustively explores <strong>all</strong> executions</li><li>Report errors as <strong>traces</strong></li><li>May produce <strong>incorrect results</strong></li></ul></li></ul><h3 id="Avoiding-state-space-explosion">4.1. Avoiding state space explosion</h3><ul><li>Bounded Model Checking (BMC)<ul><li>Breadth-first search (BFS) approach 广度优先</li></ul></li><li>Symbolic Execution<ul><li>Depth-first search (DFS) approach 深度优先</li></ul></li></ul><h3 id="V-amp-V-vs-debugging">4.2. V&amp;V vs debugging</h3><ul><li>V &amp; V is concerned with establishing the absence or existence of defects in a program, resp.</li><li>Debugging is concerned with two main tasks <ul><li>Locating</li><li>Repairing these errors</li></ul></li><li>Debugging involves <ul><li>Formulating a hypothesis about program behaviour </li><li>Test these hypotheses to find the system error</li></ul></li></ul><center><img loading="lazy" src="/posts/536aff33/4.png" width="600"></center><h2 id="Concurrency-verification">5. Concurrency verification</h2><center><img loading="lazy" src="/posts/536aff33/5.jpg" width="600"></center><center><img loading="lazy" src="/posts/536aff33/6.png" width="600"></center><p><strong>Concurrency errors</strong></p><ul><li>progress errors: deadlock, starvation, … <ul><li>typically caused by wrong synchronization</li></ul></li><li>safety errors: assertion violation<ul><li>typically caused by data races (i.e., unsynchronized access to shared data)</li></ul></li></ul><p><strong>Concurrent programming styles</strong></p><ul><li>communication via message passing<ul><li>“truly” parallel distributed systems “真正的 “并行分布式系统</li></ul></li><li>communication via shared memory<ul><li>multi-threaded programs</li></ul></li></ul><p><strong>Round-robin scheduling</strong></p><ul><li>context: segment of a run of an active thread $t_i$</li><li>context switch: change of active thread from $t_i$ to $t_k$ <ul><li><strong>global state</strong> is passed on to $t_k$ </li><li>context switch back to $t_i$ resumes at old local state (incl. pc)</li></ul></li><li>round: formed of one context of each thread</li><li>round robin schedule: same order of threads in each round</li><li>can simulate all schedules by round robin schedules</li></ul><center><img loading="lazy" src="/posts/536aff33/7.png" width="300"></center><ul><li>更多可参考：<a href="https://hejueyun.github.io/posts/ad1bb4ae/">操作系统备忘录–处理机</a></li></ul><h3 id="BMC-of-Multi-threaded-Software">5.1. BMC of Multi-threaded Software</h3><p><strong>Idea</strong>: iteratively generate all possible interleavings and call the BMC procedure on each interleaving</p><center><img loading="lazy" src="/posts/536aff33/8.png" width="600"></center><h3 id="Lazy-exploration-of-interleavings">5.2. Lazy exploration of interleavings</h3><p><strong>Idea</strong>: iteratively generate all possible interleavings and call the BMC procedure on each interleaving, combines:</p><ul><li><strong>symbolic</strong> model checking: on each individual interleaving</li><li><strong>explicit state</strong> model checking: explore all interleavings</li></ul><p><strong>Reachability Tree</strong></p><center><img loading="lazy" src="/posts/536aff33/9.png" width="600"></center><ul><li>每一层相当于多走一步单步，例如左子树，在上了m1的锁之后，跳到reader线程是无法进入cs的，所以会被blocked.</li></ul><center><img loading="lazy" src="/posts/536aff33/10.jpg" width="600"></center><p><strong>Exploring Reachability Tree</strong></p><ul><li>Use a reachability tree (RT) to describe reachable states of a multi-threaded program</li><li>Each node in the RT is a tuple $\left (A_i,C_i,s_i,    \left \langle l_i^j,G_i^j \right \rangle ^n_{j&#x3D;i} \right )_i$<ul><li>$A_i$ represents the <strong>currently active thread</strong> 当前活跃线程</li><li>$C_i$ represents the <strong>context switch number</strong> 上下文切换序号</li><li>$s_i$ represents the <strong>current state</strong> 当前状态</li><li>$l_i^j$ represents the <strong>current location</strong> of thread $j$ 命令instruction位置</li><li>$G_i^j$ represents the <strong>control flow guards accumulated in thread</strong> $j$ along the path from $l_0^j$ to $l_i^j$ 积累的守护条件</li></ul></li></ul><p><strong>Expansion Rules of the RT</strong></p><center><img loading="lazy" src="/posts/536aff33/12.jpg" width="600"></center><p><strong>main algorithm</strong></p><ol><li>Initialize the stack with the initial <strong>node</strong> $v_0$ and the initial <strong>path</strong> $\pi_0 &#x3D; \left \langle v_0 \right \rangle$</li><li>If the stack is empty, terminate with “no error”</li><li>Pop the current node $v$ and current path $\pi$ off the stack and compute the set $v’$ of successors后续 of $v$ using rules R1-R8</li><li>If $v’$ is empty, derive the VC $\phi^{\pi}_k$ for $\pi$ and call the SMT solver on it. If $\phi^{\pi}_k$ is satisfiable, terminate with “error”; otherwise, goto step 2</li><li>If $v’$ is not empty, then for each node $v \in v’$, add $v$ to $\pi$, and push node and extended path on the stack. goto step 3.</li></ol><center><img loading="lazy" src="/posts/536aff33/11.png" width="450"></center><p>can suffer performance degradation:</p><ul><li>in particular for correct programs where we need to invoke the SMT solver once for each possible execution path</li></ul><h3 id="Schedule-Recording">5.3. Schedule Recording</h3><p><strong>Idea</strong>: systematically encode all possible <strong>interleavings</strong> into one <strong>formula</strong></p><ul><li>explore reachability tree in same way as lazy approach<ul><li>but call SMT solver only once</li></ul></li><li>add a schedule guard $ts_i$ for each context switch block $i$ (0&lt; $ts_i$ &lt; #threads)<ul><li>record in which order the scheduler has executed the program</li><li>SMT solver determines the order in which threads are simulated</li></ul></li><li>add <strong>scheduler guards</strong> only to effective statements<ul><li>record <strong>effective context switches (ECS)</strong> (assignments and assertions)</li><li>ECS block: sequence of program statements that are executed with no intervening ECS</li></ul></li></ul><center><img loading="lazy" src="/posts/536aff33/13.png" width="600"></center><p>number of threads and context switches grows very large quickly, and easily “blow-up” the solver</p><ul><li>there is a clear trade-off between usage of time and memory resources</li></ul><h2 id="Sequentialization-序列化">6. Sequentialization 序列化</h2><ul><li>Building verification tools for full-fledged成熟的 <strong>concurrent</strong> languages is difficult and expensive<ul><li>but scalable verification techniques exist for <strong>sequential</strong> languages<ul><li>Abstraction techniques</li><li>SAT&#x2F;SMT techniques</li></ul></li></ul></li></ul><p>Sequentialization:</p><ul><li>convert concurrent programs into sequential programs such that <strong>reachability is preserved</strong></li><li>replace control non-determinism by data non-determinism</li><li>source-to-source transformation: T1 ∥ T2 ↝ T1’ ; T2’</li></ul><h3 id="KISS">6.1. KISS</h3><p><strong>Keep It Simple and Sequential</strong></p><ul><li>Under-approximation (subset of interleavings) <ul><li>也就是说不会cover所有情况</li></ul></li><li>Thread creation → function call<ul><li>Thread被转换为function</li><li>at context-switches &#x2F; when a thread is terminated, <strong>either</strong>:<ul><li>the active thread is terminated &#x2F; the thread that has called it is resumed (if any)</li><li><strong>or</strong> a not yet scheduled thread is started (by calling its main function)</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/536aff33/14.png" width="600"></center><center><img loading="lazy" src="/posts/536aff33/15.png" width="600"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Software-Security/">Software Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/536aff33/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Fuzzing A Software Verifier - POP</title>
      <link>https://hejueyun.github.io/posts/a0a87206/</link>
      <guid>https://hejueyun.github.io/posts/a0a87206/</guid>
      <pubDate>Mon, 02 May 2022 15:11:23 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;The complexity of manually and dynamic testing increases with the growth of the project. This results in the increasing usage of static analysis tools, such as bounded model checker, which do not require compilation and act automatically [1]. As an SMT-based model checker for program static analysis and verification, ESBMC has been successfully used in a variety of environments due to its adaptability to multi-language, multi-platform and high efficiency[2]. However, these features have led to the difficulty of fuzzing this software verifier. Firstly, the construction of a generation-based fuzzer for ESBMC is a challenge. The adaptability for multiple source programming languages means that the fuzzer needs to consider certain source language’s grammar, in the worst case, constructing different inputs for corresponding front-ends. Secondly, the construction of a coverage-guided mutation-based fuzzer is a challenge, as directly generated random input cannot be “understood” by ESBMC and will be excluded beyond validating. These deficiencies will result in fuzzy tests that do not detect errors hidden in the deep execution path of the program and insufficient code coverage. Hence, we propose a fuzzer construction on intermediate representation, which refers to Goto programs. Instead of converting from the source file, this generic fuzzer would generate syntactically correct Goto programs directly. The introduction of mutation will further dynamically modify the properties in the Goto programs by tracking and updating the corpus. These Goto programs will finally be used as input to fuzz test the ESBMC.&lt;/p&gt;
&lt;p&gt;The achievement of this goal can be divided into the following steps: (1) Summarise the syntax grammar for constructing Goto intermediate representation, including the symbol table and Goto instructions, i.e. each statement in the Goto program, as well as the Goto programs itself. (2) Investigate a mutation approach for the generated Goto programs, which will be achieved by introducing libFuzzer[3]. (3) Design and implement the program architecture of the Goto-fuzzer. (4) Debugging and testing, including error detection and performance testing. (5) Fuzz the ESBMC by Goto-fuzzer. Collect the error logs and coverage information.(6) Analyse the data and draw conclusions.&lt;/p&gt;
&lt;h2 id=&quot;Background&quot;&gt;2. Background&lt;/h2&gt;&lt;h3 id=&quot;ESBMC&quot;&gt;2.1. ESBMC&lt;/h3&gt;&lt;p&gt;ESBMC is a licensed open-source SMT-based contextual boundary model checker that has been widely used to verify multi-language programs, including C&amp;#x2F;C++, Java and Solidity. ESBMC can automatically find memory safety and assertion violations[4]. The basic workflow of this bounded model checker begins with a transition system $M$, a property $φ$, and a bound $k$. ESBMC unwinds the system $k$ times and converts it into a verification condition (VC) $ψ$. ESBMC checks the negation of this VC so that $ψ$ is satisfiable if and only if $φ$ has a counterexample of depth $k$ or less. To cope with increasing software complexity, sorts of SMT (Satisfiability Modulo Theories) solvers have been used as the back-end of ESBMC for solving the generated VCs[5].&lt;/p&gt;
&lt;p&gt;From an architectural point of view, ESBMC can be divided into three components: front-end, middleware and back-end. A C++ Oriented ESBMC structure can been shown by Figure 1.&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a0a87206/3.svg&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;b&gt;FIGURE 1&lt;/b&gt; C++ oriented ESBMC&#39;s architecture overview. White rectangles represent input and output; grey rectangles represent the steps of the verification&lt;/center&gt;

&lt;h4 id=&quot;Front-end&quot;&gt;2.1.1. Front-end&lt;/h4&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Introduction">1. Introduction</h2><p>The complexity of manually and dynamic testing increases with the growth of the project. This results in the increasing usage of static analysis tools, such as bounded model checker, which do not require compilation and act automatically [1]. As an SMT-based model checker for program static analysis and verification, ESBMC has been successfully used in a variety of environments due to its adaptability to multi-language, multi-platform and high efficiency[2]. However, these features have led to the difficulty of fuzzing this software verifier. Firstly, the construction of a generation-based fuzzer for ESBMC is a challenge. The adaptability for multiple source programming languages means that the fuzzer needs to consider certain source language’s grammar, in the worst case, constructing different inputs for corresponding front-ends. Secondly, the construction of a coverage-guided mutation-based fuzzer is a challenge, as directly generated random input cannot be “understood” by ESBMC and will be excluded beyond validating. These deficiencies will result in fuzzy tests that do not detect errors hidden in the deep execution path of the program and insufficient code coverage. Hence, we propose a fuzzer construction on intermediate representation, which refers to Goto programs. Instead of converting from the source file, this generic fuzzer would generate syntactically correct Goto programs directly. The introduction of mutation will further dynamically modify the properties in the Goto programs by tracking and updating the corpus. These Goto programs will finally be used as input to fuzz test the ESBMC.</p><p>The achievement of this goal can be divided into the following steps: (1) Summarise the syntax grammar for constructing Goto intermediate representation, including the symbol table and Goto instructions, i.e. each statement in the Goto program, as well as the Goto programs itself. (2) Investigate a mutation approach for the generated Goto programs, which will be achieved by introducing libFuzzer[3]. (3) Design and implement the program architecture of the Goto-fuzzer. (4) Debugging and testing, including error detection and performance testing. (5) Fuzz the ESBMC by Goto-fuzzer. Collect the error logs and coverage information.(6) Analyse the data and draw conclusions.</p><h2 id="Background">2. Background</h2><h3 id="ESBMC">2.1. ESBMC</h3><p>ESBMC is a licensed open-source SMT-based contextual boundary model checker that has been widely used to verify multi-language programs, including C&#x2F;C++, Java and Solidity. ESBMC can automatically find memory safety and assertion violations[4]. The basic workflow of this bounded model checker begins with a transition system $M$, a property $φ$, and a bound $k$. ESBMC unwinds the system $k$ times and converts it into a verification condition (VC) $ψ$. ESBMC checks the negation of this VC so that $ψ$ is satisfiable if and only if $φ$ has a counterexample of depth $k$ or less. To cope with increasing software complexity, sorts of SMT (Satisfiability Modulo Theories) solvers have been used as the back-end of ESBMC for solving the generated VCs[5].</p><p>From an architectural point of view, ESBMC can be divided into three components: front-end, middleware and back-end. A C++ Oriented ESBMC structure can been shown by Figure 1.</p><center><img loading="lazy" src="/posts/a0a87206/3.svg"></center><center><b>FIGURE 1</b> C++ oriented ESBMC's architecture overview. White rectangles represent input and output; grey rectangles represent the steps of the verification</center><h4 id="Front-end">2.1.1. Front-end</h4><p>Front-end is an important piece of technology that should facilitate the transition between the program under verification and a format the tool can work upon. Despite that several front-ends have been constructed corresponding to different programming languages in ESBMC，the final output will always be a symbol table, an auxiliary data structure storing the meaning and range of variable names. A general front-end framework includes a pre-processor, scanner, parser and type checker. <strong>Pre-processor</strong> handles special operations that will be performed according to the preprocessor instructions, such as replacement or expansion macros [6]. A lexical analysis of the <strong>scanner</strong> and a syntax score of the <strong>parser</strong> resulted in the Abstract Syntax Tree (AST) [7]. To simplify the analysis, ASTs have been converted into a simpler form, called an intermediate representation (IR), by <strong>type checker</strong> in which a symbol table is generated simultaneously. At this point, the source code as input is converted into symbol tables [8].  </p><h4 id="Middleware">2.1.2. Middleware</h4><p>In ESBMC, the generated symbol table enables the middleware to perform further actions, including the conversion from the original program into the equivalent Goto program, an intermediate representation generated from the symbol table, the generation of the single static assignment (SSA) form and the symbolical execution of the program.</p><p><strong>Goto Converter</strong> firstly AST into its Control flow chart form, which refers to Goto programs. These programs are language independent and similar to the intermediate languages of many compilers. Each program is a list of instructions, each of which has the type of instruction (one of 19 instructions), a code expression, a protection expression and possibly some target for the next instruction. An <strong>Instructions Type</strong> is an enum value describing the action performed by this instruction. <strong>Guard</strong> is an (arbitrarily complex) expression (usually an expert) of Boolean type. And <strong>Code</strong> represents a code statement, which can be seen as a unit in the symbol table. The type field determines the meaning of an instruction node, while the guard and code fields are used for a variety of purposes by different types of instructions [9].</p><p><strong>Symbolic Engine</strong> will firstly convert the variables from program text to a single static assignment (SSA) form. New variables are created to identify branch and loop entry conditions. These variables will guard the assignments based on the branch taken [4]. Symbolic execution will be performed after the conversion to perform semantic analysis, including dynamic memory checks (bounds, memory alignment, offset pointer-free, and double-free) and unwinding assertions. The point of this step is to make sure each assignment is independent.[8] </p><h4 id="Back-end">2.1.3. Back-end</h4><p>During this workflow, two sets of SMT formulae are created based on the SSA expressions. We denote $C$ for the constraints and $P$ for the properties. These quantifier-free formulae will be used as input for the SMT solver, a counterexample will be created if there exists a violation of a given property, or an unsatisfiable answer if the property holds [4]. </p><h3 id="Fuzzing">2.2. Fuzzing</h3><p>Fuzz testing (fuzzing) is a software testing technique. The core idea is to feed random data generated automatically into a program by a fuzzer. Traditionally, fuzzers can be classified into two categories based on how they are input, including generation-based fuzzers and coverage-guided mutation-based fuzzers.</p><h4 id="Generation-Based-Fuzzer">2.2.1. Generation-Based Fuzzer</h4><p>A <strong>generation-based</strong> fuzzer construct inputs according to some provided format specification, especially the grammar of a language[11]. One of the good examples of such fuzzers is <strong>Csmith</strong> [10] which is already applied in ESBMC. Csmith works as a generator for C programs. These programs will be fed to the target software, in most cases compilers, run the executables and compare the outputs. In practice, it is used as a stress testing tool to check the stability of ESBMC.</p><h4 id="Mutation-Based-Fuzzer">2.2.2. Mutation-Based Fuzzer</h4><p>A <strong>mutation-based</strong> fuzzer generates inputs by randomly altering analyst-supplied or created seeds.<br>These programmes do not require syntactic definitions and are not limited to a single input type [11]. These coverage-guided fuzzers use coverage information as feedback to alter existing inputs into new ones, attempting to maximise the amount of code covered by the overall input corpus. </p><p><strong>LibFuzzer</strong> is a powerful mutation-based Fuzzer chosen as our research object. LibFuzzer is linked to the library under test and feeds fuzzed inputs to it through a defined fuzzing target function. The fuzzer records which branches of the code were accessed and creates mutations on the corpus of input data to optimise code coverage. LLVM’s SanitizerCoverage instrumentation provides code coverage information for libFuzzer. [3]</p><h4 id="Structure-Aware-Fuzzer">2.2.3. Structure-Aware Fuzzer</h4><p>Both fuzzer types mentioned above are inherently flawed. On one hand, A generation-based fuzzer lacks a coverage-guided trace-feedback mechanism, which leads to possible duplication of the generated test cases. Another common flaw in generation-based testing occurs when the input is required to fulfil sophisticated semantic validity criteria that are not explicitly evaluated by the generator [13]. On the other hand, the presence of checksums in the input format or the complexity of the input format itself can easily trip up a mutation-based fuzzer, as virtually all generated inputs can be invalid for the target data structure.</p><p>We, therefore, consider a <strong>structure-aware</strong> fuzzer proposed by Google [12]. This fuzzer is a combination of the two fuzzing approaches described above: as a generation-based fuzzer in essence, the generator will now accept random value generated by the mutation-based fuzzer as seed. This mutator, in this case, libFuzzer, will mutate and optimise the random bytes by tracking and feedback.</p><h2 id="Research-Methodology">3. Research Methodology</h2><p>This section is originally divided into three subsections, with Section 3.1 discussing the introduction and application of structure-aware fuzzer to ESBMC, after which two approaches are proposed. We will first introduce the first approach in Section 3.2, which uses Csmith as a generator, and then mutates the original program via libFuzzer. We will discuss this method and explain why the second approach was chosen. In Section 3.2, we will t describe the second approach that will be used in development.</p><h3 id="Introduce-Structure-Aware-fuzzer-to-ESBMC">3.1. Introduce Structure-Aware fuzzer to ESBMC</h3><p>First, we need to decide the output form of the fuzzer, in this case, the generator. In theory, the potential object can be any temporary variable passed in the ESBMC workflow. We have chosen the Goto program as the output for several reasons: (1) the Goto program is language-independent, reflected in no dependency on the front-end (2) Goto program is a demarcation between syntax and semantics. As described in Section 2.1.2, symbolic execution represents the input to a program symbolically, based on constraints obtained by analysing the semantics of the program, whilst the semantics in the program will be translated and executed. The correctness of both syntax and semantics is required in and beyond this component, yet previously only the syntax was required. The main goal, therefore, is to create semantically arbitrary, in most cases incorrect, but syntactically correct goto programs.</p><p>Next, we explore how to achieve randomness via mutation. We use structure-aware mutations to look for interesting input structures in the space of valid inputs, which is mirrored in the Goto program’s randomization of the structure between instructions. We also use structure-preserving mutations to create distinct mutations of the same input structure to investigate alternative execution trails. This is accomplished by making the values of context-sensitive variables unequal [13].</p><p>As shown in Figure 2, we take a simple goto program as an example, where we can make the assignment to x precede its definition by changing the order between instructions; in addition, we can break the contextual relationship between the target of the GOTO instruction and the LABEL instruction by making their values no longer equal, thus changing the semantics without violating the syntax grammar rules.  that the changes of names or values of variables would predictably be unhelpful.</p><center><img loading="lazy" src="/posts/a0a87206/4.svg"></center><center><b>FIGURE 2</b> A simple Goto program</center><h3 id="First-Approach-Csmith-Mutation-Fuzzer">3.2. First Approach: Csmith-Mutation Fuzzer</h3><center><img loading="lazy" src="/posts/a0a87206/2.svg"></center><center><b>FIGURE 3</b> Csmith-mutation fuzzer architecture. White rectangles represent components reused from ESBMC; grey rectangles represent new created components</center><p>We propose the first implementation approach, whose architecture is shown in Figure 2. First, Csmith will create random C files, which will be passed through a front-end and a converter to form Goto programs. Here we introduce a mutator which semantically randomizing Goto programs by libFuzzer. Randonmized goto programs will finally be deliverred to the subsequent process. A simplified version of the programming logic is shown in Figure 4.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size, string filepath)</span> </span>&#123;</span><br><span class="line">    Goto_program=<span class="built_in">c2goto</span>(filepath);  <span class="comment">// Convert C codes to Goto programs</span></span><br><span class="line">    Goto_program=<span class="built_in">mutateor</span>(Goto_program, Data,size)  <span class="comment">// randomise Goto programs by libFuzzer</span></span><br><span class="line">    <span class="built_in">do_bmc</span>(Goto_program);   <span class="comment">// Apply the Goto program to the subsequent process</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><b>FIGURE 4</b> Programming Logic of Csmith-Mutation Fuzzer</center><p>The advantage of the Csmith-Mutation Fuzzer is that it can reuse the existing generator Csmith and only need to consider constructing a mutator; however, it also has several drawbacks: (1) We cannot guarantee that all language features supported within ESBMC are covered, as Csmith’s C standard support is c99 while that of ESBMC is c11. This will result in some of the statements not being covered during fuzz testing; (2) The fuzzer cannot be refined to test for specific statements (3) The approach of Csmith fuzzing is still front-end related as C file can only be read in via C-based front-end (in this case clang). We would like to have a more generic, front-end-independent fuzzer.</p><h3 id="Second-Approach-Goto-Fuzzer">3.3. Second Approach: Goto-Fuzzer</h3><center><img loading="lazy" src="/posts/a0a87206/1.svg"></center><center><b>FIGURE 5</b> Goto-fuzzer architecture. White rectangles represent components reused from ESBMC; grey rectangles represent new created components</center><p>Here we propose a second approaches, the architecture of which is shown in Figure 5. The core difference between two methods is that the construction output of the generator has changed from a source file to an intermediate file, which refers to the symbol. The choice of the symbol table over the goto program as the output of the generator is more a matter of development convenience, as no direct functions to construct a Goto program are provided in ESBMC. In contrast, the construction of a code statement is considerably simpler. In addition, contextual properties are initialised automatically during the conversion from symbol table to goto program, which will be a tough task if building Goto program directly. To ensure that the symbol table based generator works indentically as the direct goto program generator，We will prove that the types of generated statement will cover that of goto program instruction during the Goto converson. A simplified version of the programming implementation is shown in Figure 6.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">    Goto_program = <span class="built_in">generator</span>(Data, Size);    <span class="comment">// use libFuzzer as seed generator </span></span><br><span class="line">    <span class="built_in">do_bmc</span>(Goto_program);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><b>FIGURE 6</b> Programming Logic of Goto-Fuzzer</center><h2 id="Ethics-and-professional-considerations">4. Ethics and professional considerations</h2><p>This project does not require the participation of any volunteers, nor will user data be collected in any form， the involvement of humans and data can therefore be excluded. Considering that ESBMC is under the Apache License 2.0, our modifications and development should follow the same open-source rules. In addition, given that ESBMC will be used in commercial and other production environments, the fuzzer needs to be tested before it is released, and the project documentation needs to be supplemented with relevant notes.</p><h2 id="Risk-consideration">5. Risk consideration</h2><h3 id="Design-Stage">5.1. Design Stage</h3><p>To design an efficient structure-awared fuzzer, which is the combination of generation and mutation fuzzer, will be the first challenge. This will have a direct impact on the final outcome. For example, test cases generated from a mutation algorithm that lacks logic may have the following problems: (1) the test cases are not useful, which is often reflected in the simplicity of the test cases (2) the test cases are virtually identical to others from the aspect of code coverage, which will result in test objects being limited to only some branches. </p><h3 id="Implement-Stage">5.2. Implement Stage</h3><p>The difficulty of the implement of Goto-fuzzer can be reflected in several aspects. Coupling and component independence needed to be firstly considered at the top-level design stage in order to avoid fuzzer having side effects on other functions in ESBMC. In addition, although the data structures and libraries for the intermediate representation were already provided, there was still a lot of coding to be done. Furthermore, the complex internal cross-referencing within ESBMC and the use of “magic” functions put the developer’s C++ reading skills to the test.</p><h3 id="Debug-and-Test-Stage">5.3. Debug and Test Stage</h3><p>The debuging and testing of Goto-fuzzer will be challenge, as the interdependencies of the libraries make debugging Goto-fuzzer as time consuming as debugging the entire ESBMC, requiring recompilation and relinking of the entire ESBMC project.</p><h2 id="Project-evaluation">6. Project evaluation</h2><p>The project can be evaluated from the following aspects: First, the primary purpose of a fuzzer is to use it to find hidden bugs in the program, thus the ability of error detection will be tested. One possible approach is to quantify the statistics of distinct crash errors found, rates of the crash and wrong-code errors from different versions of ESBMC, as well as the statistics of Bug-Finding Performance as a function of test-case size [14]. What’s more, the improvement of code coverage will be measured. Tools for statistical code coverage are provided in ESBMC and can be output visually. In the worst-case scenario, where our Goto fuzzer fails to find any bug, then the code coverage will be the key evaluation of the effectiveness. Besides, despite the libFuzzer as the mutator being a pre-requisite for the project, we could also propose other mutation-based fuzzer to compare and evaluate their relative performance. This optional task will be done if possible.</p><h2 id="Planning">7. Planning</h2><p>As the stage division in the section above, the general arrangement of this project will be divided into four parts, as shown in the Gantt Chart in Figure 5. First, the design stage will take 2 weeks and will be devoted mainly to summarizing the syntax grammar for the generator and to working out how to apply mutation to this fuzzer. Second, the implementation stage will last a month, and this stage will complete all. As an optional arrangement, we consider building an additional interface to output the goto program for debugging purposes. This task will be cancelled due to insufficient time. Third, the debug and testing stage will take three weeks, during which we focus on collecting data to verify the effectiveness of our Goto fuzzer. Finally, the writing stage will begin with the design stage simultaneously and will continue until August 8th .</p><center><img loading="lazy" src="/posts/a0a87206/5.png"></center><center><b>FIGURE 7</b> Gantt Chart</center><h2 id="Reference">8. Reference:</h2><ul><li>[1]: Seacord, Robert C. The CERT C Secure Coding Standard, 2008, 1st. edition.</li><li>[2]: ESBMC. <a href="http://www.esbmc.org/">http://www.ESBMC.org/</a>.</li><li>[3]: Kostya Serebryany. libFuzzer - a Library for Coverage-Guided Fuzz Testing. <a href="https://llvm.org/docs/LibFuzzer.htm">https://llvm.org/docs/LibFuzzer.htm</a>.</li><li>[4]: ESBMC Book. <a href="http://www.esbmc.org/">http://www.ESBMC.org/</a></li><li>[5]: L. Cordeiro, B. Fischer and J. Marques-Silva, “SMT-Based Bounded Model Checking for Embedded ANSI-C Software,” 2009 IEEE&#x2F;ACM International Conference on Automated Software Engineering, 2009, pp. 137-148, doi: 10.1109&#x2F;ASE.2009.63.</li><li>[6]: Deitel, Paul J., and Harvey M. Deitel. C: How to Program; with an Introduction to C++. 8., ed.Global ed, Pearson, 2016.</li><li>[7]: Aho, Alfred V., and Alfred V. Aho, editors. Compilers: Principles, Techniques, &amp; Tools. 2nd ed, Pearson&#x2F;Addison Wesley, 200.</li><li>[8]: cprover - Background Concepts. <a href="http://cprover.diffblue.com/background-concepts.html">http://cprover.diffblue.com/background-concepts.html</a>.</li><li>[9]: cprover - goto programt. <a href="http://cprover.diffblue.com/group__goto-programs.html">http://cprover.diffblue.com/group__goto-programs.html</a>.</li><li>[10]: Csmith. <a href="https://embed.cs.utah.edu/csmith/">https://embed.cs.utah.edu/csmith/</a>.</li><li>[11]: Hui Peng, Yan Shoshitaishvili and Mathias Payer, T-Fuzz: Fuzzing by Program Transformation,<br>2018-05. </li><li>[12]: Google. Structure-Aware Fuzzing with libFuzzer. <a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md">https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md</a>.</li><li>[13]: Nguyen, Hoang Lam and Grunske, Lars, BeDivFuzz: Integrating Behavioral Diversity into Generator-based Fuzzing, 2022. </li><li>[14]: Xuejun Yang, Yang Chen, Eric Eide, and John Regehr. 2011. Finding and understanding bugs in C compilers. SIGPLAN Not. 46, 6 (June 2011), 283–294.</li></ul><div class="row">    <embed src="./report.pdf" width="100%" height="550" type="application/pdf"></div>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/a0a87206/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ESBMC Symbol Table</title>
      <link>https://hejueyun.github.io/posts/1ad13e77/</link>
      <guid>https://hejueyun.github.io/posts/1ad13e77/</guid>
      <pubDate>Fri, 22 Apr 2022 20:06:36 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Namespacet&quot;&gt;1. Namespacet&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A namespacet is essentially one or two symbol tables bound together, to allow for symbol lookups in them.&lt;/p&gt;
&lt;p&gt;The basic idea is that you might want to combine a value table and a type table, so that for a variable you can lookup both of these essential properties, in one structure. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;contextt&quot;&gt;2. contextt&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;symbol_base_mapt symbol_base_map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;symbolst symbols;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ordered_symbolst ordered_symbols;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;symbolt-x2F-symbolst&quot;&gt;3. symbolt&amp;#x2F;symbolst&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GOTO conversion component constructs a goto-program from a symbol table. Each symbol in the symbol table with function type (that is, the symbol’s type field contains a &lt;code&gt;code_typet&lt;/code&gt;) will be converted to a corresponding GOTO program. Function &lt;code&gt;goto_convertt::convert&lt;/code&gt; turns each &lt;code&gt;codet&lt;/code&gt; in the symbol table into corresponding GOTO instructions.&lt;/li&gt;
&lt;/ul&gt;
</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Namespacet">1. Namespacet</h2><blockquote><p>A namespacet is essentially one or two symbol tables bound together, to allow for symbol lookups in them.</p><p>The basic idea is that you might want to combine a value table and a type table, so that for a variable you can lookup both of these essential properties, in one structure. </p></blockquote><h2 id="contextt">2. contextt</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbol_base_mapt symbol_base_map;</span><br><span class="line">symbolst symbols;</span><br><span class="line">ordered_symbolst ordered_symbols;</span><br></pre></td></tr></table></figure><h2 id="symbolt-x2F-symbolst">3. symbolt&#x2F;symbolst</h2><ul><li>GOTO conversion component constructs a goto-program from a symbol table. Each symbol in the symbol table with function type (that is, the symbol’s type field contains a <code>code_typet</code>) will be converted to a corresponding GOTO program. Function <code>goto_convertt::convert</code> turns each <code>codet</code> in the symbol table into corresponding GOTO instructions.</li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/1ad13e77/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GOTO Language Syntax Grammar</title>
      <link>https://hejueyun.github.io/posts/d48bdd8/</link>
      <guid>https://hejueyun.github.io/posts/d48bdd8/</guid>
      <pubDate>Fri, 22 Apr 2022 20:05:04 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Goto-Language&quot;&gt;1. Goto Language&lt;/h2&gt;&lt;p&gt;more like a descriptive document for ESBMC’s GOTO program&lt;/p&gt;
&lt;h3 id=&quot;Background&quot;&gt;1.1. Background&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;what is goto program&lt;/li&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;goto program拥有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;他是语言独立的，任何ESBMC的前端所支持的源程序都可以被转化为GOTO program。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;why we need it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main goal: replacement of swithc and for while to if goto&lt;/li&gt;
&lt;li&gt;add checing Verificiation Condition&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generally speaking, it’s a simplified from original source program, with the replacement of some expression.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;why&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c2goto. goto-binary 二进制文件&lt;/li&gt;
&lt;li&gt;while verifying d&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It compiles programs given in a C and C++ into GOTO-programs and serialises into a binary file. This goto-binary can be later deserialised and read in with the option “–binary”.&lt;/p&gt;
&lt;p&gt;In ESBMC, the options associated with the goto program can be listed in Table .&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Goto-Language">1. Goto Language</h2><p>more like a descriptive document for ESBMC’s GOTO program</p><h3 id="Background">1.1. Background</h3><ul><li>what is goto program</li><li>定义</li><li>结构</li></ul><p>goto program拥有如下特性：</p><ul><li><p>他是语言独立的，任何ESBMC的前端所支持的源程序都可以被转化为GOTO program。</p></li><li></li><li><p>why we need it</p><ul><li>main goal: replacement of swithc and for while to if goto</li><li>add checing Verificiation Condition</li></ul></li></ul><p>Generally speaking, it’s a simplified from original source program, with the replacement of some expression.</p><ul><li><p>why</p></li><li><p>生成方式</p><ul><li>c2goto. goto-binary 二进制文件</li><li>while verifying d</li></ul></li></ul><p>It compiles programs given in a C and C++ into GOTO-programs and serialises into a binary file. This goto-binary can be later deserialised and read in with the option “–binary”.</p><p>In ESBMC, the options associated with the goto program can be listed in Table .</p><p>Note that this representation makes it very easy to interpret the program, keeping just two pieces of state: the current position (which basic block and which line), and the values of all variables (in real software, this would also include parts of the heap and the call stack). Execution proceeds as follows: as long as there are still instructions to execute in the current basic block, run the next instruction and move the current position to right after that instruction. At the end of a basic block, take one of the available outgoing edges to another basic block.</p><p>generate the symbol table. Then the GOTO converter will use this symbol table to produce the GOTO program. Note that GOTO programs are the language-independent and context-free IR in ESBMC.</p><h2 id="post-processing">2. post-processing</h2><h3 id="goto-checking">2.1. goto checking</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">goto_checkt::div_by_zero_check</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> expr2tc &amp;expr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> guardt &amp;guard,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> locationt &amp;loc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(disable_div_by_zero_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">is_div2t</span>(expr) || <span class="built_in">is_modulus2t</span>(expr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add divison by zero subgoal</span></span><br><span class="line">  expr2tc side_2;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">is_div2t</span>(expr))</span><br><span class="line">    side_2 = <span class="built_in">to_div2t</span>(expr).side_2;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    side_2 = <span class="built_in">to_modulus2t</span>(expr).side_2;</span><br><span class="line"></span><br><span class="line">  expr2tc zero = <span class="built_in">gen_zero</span>(side_2-&gt;type);</span><br><span class="line">  <span class="built_in">assert</span>(!<span class="built_in">is_nil_expr</span>(zero));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">add_guarded_claim</span>(</span><br><span class="line">    <span class="built_in">notequal2tc</span>(side_2, zero),</span><br><span class="line">    <span class="string">&quot;division by zero&quot;</span>,</span><br><span class="line">    <span class="string">&quot;division-by-zero&quot;</span>,</span><br><span class="line">    loc,</span><br><span class="line">    guard);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Division by zero.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  signed int x;</span><br><span class="line">  x=1;</span><br><span class="line">  IF !(x == 1) THEN GOTO 1</span><br><span class="line">  ASSERT 0 // division by zero</span><br><span class="line">  x=x % 0;</span><br><span class="line">  GOTO 2</span><br><span class="line">1: ASSERT 0 // division by zero</span><br><span class="line">  x=x / 0;</span><br><span class="line">2: dead x;</span><br><span class="line">  RETURN: NONDET(signed int)</span><br><span class="line">  END_FUNCTION // main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  signed int x;</span><br><span class="line">  x=1;</span><br><span class="line">  IF !(x == 1) THEN GOTO 1</span><br><span class="line">  x=x % 0;</span><br><span class="line">  GOTO 2</span><br><span class="line">1: x=x / 0;</span><br><span class="line">2: dead x;</span><br><span class="line">  RETURN: NONDET(signed int)</span><br><span class="line">  END_FUNCTION // main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--no-bounds-check                do not do array bounds check</span><br><span class="line">--no-div-by-zero-check           do not do division by zero check</span><br><span class="line">--no-pointer-check               do not do pointer check</span><br><span class="line">--no-align-check                 do not check pointer alignment</span><br><span class="line">--no-pointer-relation-check      do not check pointer relations</span><br><span class="line">--nan-check                      check floating-point for NaN</span><br><span class="line">--memory-leak-check              enable memory leak check</span><br><span class="line">--overflow-check                 enable arithmetic over- and underflow check</span><br><span class="line">--struct-fields-check            enable over-sized read checks for struct</span><br><span class="line">                                 fields</span><br><span class="line">--deadlock-check                 enable global and local deadlock check with</span><br><span class="line">                                 mutex</span><br><span class="line">--data-races-check               enable data races check</span><br><span class="line">--lock-order-check               enable for lock acquisition ordering check</span><br><span class="line">--atomicity-check                enable atomicity check at visible</span><br><span class="line">                                 assignments</span><br><span class="line">--stack-limit bits (=-1)         check if stack limit is respected</span><br><span class="line">--error-label label              check if label is unreachable</span><br><span class="line">--force-malloc-success           do not check for malloc/new failure</span><br></pre></td></tr></table></figure><h2 id="GOTO-grammar">3. GOTO grammar</h2><h2 id="Expression">4. Expression</h2><ul><li>From the aspect of goto program, an expression (<code>expr2t</code>) is formed by <strong>two</strong> properties:<ul><li>expr_type (<code>type2t</code>): represents the type of an expression.</li><li>expr_ids (<code>expr_ids</code>): used for distinguishing different classes of expression</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr  ::=   expr_type + expr_ids  </span><br><span class="line">      |     expr     </span><br></pre></td></tr></table></figure><ul><li><p><strong>expr_type</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">expr_type   ::=</span><br><span class="line">            | bool_id</span><br><span class="line">            | empty_id</span><br><span class="line">            | symbol_id</span><br><span class="line">            | struct_id</span><br><span class="line">            | union_id</span><br><span class="line">            | code_id</span><br><span class="line">            | array_id</span><br><span class="line">            | pointer_id</span><br><span class="line">            | unsignedbv_id</span><br><span class="line">            | signedbv_id</span><br><span class="line">            | fixedbv_id</span><br><span class="line">            | floatbv_id</span><br><span class="line">            | string_id</span><br><span class="line">            | cpp_name_id</span><br><span class="line">            | end_type_id</span><br></pre></td></tr></table></figure></li><li><p><strong>expr_ids</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">expr_ids     ::=</span><br><span class="line">            |   constant_int_id</span><br><span class="line">            |   constant_fixedbv_id</span><br><span class="line">            |   constant_floatbv_id</span><br><span class="line">            |   constant_bool_id</span><br><span class="line">            |   constant_string_id</span><br><span class="line">            |   constant_struct_id</span><br><span class="line">            |   constant_union_id</span><br><span class="line">            |   constant_array_id</span><br><span class="line">            |   constant_array_of_id</span><br><span class="line">            ...</span><br><span class="line">            |   code_block_id</span><br><span class="line">            |   code_assign_id</span><br><span class="line">            |   code_init_id</span><br><span class="line">            ...</span><br><span class="line">            |   end_expr_id</span><br></pre></td></tr></table></figure></li></ul><h2 id="Goto-Instruction">5. Goto Instruction</h2><p>In ESBMC, a goto instruction (<code>goto_programt::instructiont</code>) is defined by <strong>three</strong> properties– The meaning of an instruction depends on the <strong>instruction_type</strong> (<code>goto_program_instruction_typet</code>) field, while different kinds of instructions make use of the fields <strong>guard</strong> (<code>expr2tc</code>) and <strong>code</strong> (<code>expr2tc</code>) for different purposes. </p><ul><li>In other words, these are the properties that need to be considered when initialising a goto-instruction data structure, any other property could be set default or generated afterwards. </li><li><code>expr2tc</code> is basically a reference pointer container for <code>expr2t</code>. In this situation, there is no need to distinguish these two.</li></ul><p>The syntax grammar can be roughly listed as follows.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instruction ::= </span><br><span class="line">            |   (instruction_type)</span><br><span class="line">            |   (instruction_type, guard)</span><br><span class="line">            |   (instruction_type, code)</span><br></pre></td></tr></table></figure><ul><li><p><strong>instruction_type</strong>: an enum value describing the action performed by this instruction.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">instruction_type    ::=</span><br><span class="line">                    |   NO_INSTRUCTION_TYPE </span><br><span class="line">                    |   GOTO            </span><br><span class="line">                    |   ASSUME          </span><br><span class="line">                    |   ASSERT          </span><br><span class="line">                    |   OTHER           </span><br><span class="line">                    |   SKIP            </span><br><span class="line">                    |   LOCATION        </span><br><span class="line">                    |   END_FUNCTION   </span><br><span class="line">                    |   ATOMIC_BEGIN    </span><br><span class="line">                    |   ATOMIC_END      </span><br><span class="line">                    |   RETURN         </span><br><span class="line">                    |   ASSIGN         </span><br><span class="line">                    |   DECL           </span><br><span class="line">                    |   DEAD           </span><br><span class="line">                    |   FUNCTION_CALL   </span><br><span class="line">                    |   THROW          </span><br><span class="line">                    |   CATCH          </span><br><span class="line">                    |   THROW_DECL      </span><br><span class="line">                    |   THROW_DECL_END</span><br></pre></td></tr></table></figure></li><li><p><strong>code</strong>: represents the code expression whose <code>id</code> is a subset of <code>expr_ids</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">code.ids     ::=</span><br><span class="line">            |   code_block_id</span><br><span class="line">            |   code_assign_id</span><br><span class="line">            |   code_init_id</span><br><span class="line">            |   code_decl_id</span><br><span class="line">            |   code_dead_id</span><br><span class="line">            |   code_printf_id</span><br><span class="line">            |   code_expression_id</span><br><span class="line">            |   code_return_id</span><br><span class="line">            |   code_skip_id</span><br><span class="line">            |   code_free_id</span><br><span class="line">            |   code_goto_id</span><br><span class="line">            |   code_asm_id</span><br><span class="line">            |   code_function_call_id</span><br><span class="line">            |   code_comma_id</span><br><span class="line">            |   code_cpp_del_array_id</span><br><span class="line">            |   code_cpp_delete_id</span><br><span class="line">            |   code_cpp_catch_id</span><br><span class="line">            |   code_cpp_throw_id</span><br><span class="line">            |   code_cpp_throw_decl_id</span><br><span class="line">            |   code_cpp_throw_decl_end_id</span><br></pre></td></tr></table></figure></li><li><p><strong>guard</strong>: an (arbitrarily complex) expression (usually an exprt) of Boolean type, whose <code>id</code> is a subset of <code>expr_ids</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">guard.id  ::=  </span><br><span class="line">          |     constant_bool_id</span><br><span class="line">          |     constant_int_id</span><br><span class="line">          |     constant_floatbv_id</span><br><span class="line">          |     constant_fixedbv_id</span><br></pre></td></tr></table></figure></li></ul><p>The detailed syntax grammar can be listed as follows. For simplification, we use the <strong>id</strong> of a expression directly to represent that expression, and <code>*</code> is denoted to represent a list of expressions&#x2F; instrucitons.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Instruction ::=</span><br><span class="line">            |   NO_INSTRUCTION_TYPE</span><br><span class="line">            |   GOTO   </span><br><span class="line">            |   GOTO + guard         </span><br><span class="line">            |   ASSUME + guard    </span><br><span class="line">            |   ASSERT + guard  </span><br><span class="line">            |   OTHER + code_expression_id</span><br><span class="line">            |   OTHER + code_free_id</span><br><span class="line">            |   OTHER + code_printf_id</span><br><span class="line">            |   OTHER + code_asm_id</span><br><span class="line">            |   OTHER + code_cpp_del_array_id</span><br><span class="line">            |   OTHER + code_cpp_delete_id</span><br><span class="line">            |   SKIP            </span><br><span class="line">            |   LOCATION        </span><br><span class="line">            |   ATOMIC_BEGIN + Instruction* + ATOMIC_END</span><br><span class="line">            |   RETURN </span><br><span class="line">            |   RETURN + code_return_id </span><br><span class="line">            |   ASSIGN + code_assign_id     </span><br><span class="line">            |   DECL + code_decl_id          </span><br><span class="line">            |   DEAD + code_dead_id         </span><br><span class="line">            |   FUNCTION_CALL + code_function_call_id</span><br><span class="line">            |   THROW  + code_cpp_throw_id*</span><br><span class="line">            |   CATCH  + code_cpp_catch_id*</span><br><span class="line">            |   THROW_DECL + code_cpp_throw_decl_id* </span><br><span class="line">            |   THROW_DECL_END + code_cpp_throw_decl_end_id*</span><br></pre></td></tr></table></figure><ul><li><code>NO_INSTRUCTION_TYPE</code>: Instruction will be set to <code>NO_INSTRUCTION_TYPE</code> if it is not explicitly defined.</li><li><code>GOTO</code>: <code>GOTO</code> targets if and only if <code>guard</code> is true. The <code>guard</code> will be set to <strong>TRUE</strong> if it is not explicitly given.</li><li><code>ASSUME</code>: This thread of execution waits for <code>guard</code> to evaluate to <strong>TRUE</strong>, which performs a non-failing guarded self loop.</li><li><code>ASSERT</code>: An assertion is <strong>TRUE</strong> &#x2F; safe if <code>guard</code> is <strong>TRUE</strong>  in all possible executions, otherwise it is <strong>FALSE</strong> &#x2F; unsafe. This instructions is used to express properties to be verified</li><li><code>OTHER</code>: Represents an expression that gets evaluated, but does not have any other effect on execution, i.e. doesn’t contain a <strong>call</strong> or <strong>assignment</strong>.         </li><li><code>SKIP</code>: Just advance the PC.            </li><li><code>LOCATION</code>: Semantically like <code>SKIP</code>.        </li><li><code>ATOMIC_BEGIN</code>, <code>ATOMIC_END</code>: Marks&#x2F; Ends a block without interleavings. When a thread executes <code>ATOMIC_BEGIN</code>, no thread other will be able to execute any Instruction until the same thread executes <code>ATOMIC_END</code>.</li><li><code>RETURN</code>: Set the value returned by <code>code</code> (which shall be either <strong>nil</strong> or an instance of <code>code_return_id</code>) and then jump to the end of the function.          </li><li><code>ASSIGN</code>: Update the left-hand side of <code>code</code> (an instance of <code>code_assign_id</code>) to the value of the right-hand side.          </li><li><code>DECL</code>: Introduces a symbol denoted by the field <code>code</code> (an instance of <code>code_decl_id</code>). Semantically, the life-time of which is bounded by a corresponding <code>DEAD</code> instruction.         </li><li><code>DEAD</code>: Ends the life of the symbol denoted by the field <code>code</code>.           </li><li><code>FUNCTION_CALL</code>: Invoke the function denoted by field <code>code</code> (an instance of <code>code_function_call_id</code>).   </li><li><code>THROW</code>: Throw an exception. Throw $exception_1, …, exception_N$ where the list of exceptions is extracted from the <code>code</code> field      </li><li><code>CATCH</code>: Catch an exception.</li><li><code>THROW_DECL</code>: List of throws that a function can throw.    </li><li><code>THROW_DECL_END</code>: End of throw declaration.</li></ul><h2 id="Goto-Program">6. Goto Program</h2><p>An instance of goto program (<code>goto_programt</code>) is effectively a list of instructions, and must end with  <code>END_FUNCTION</code>. </p><ul><li><code>END_FUNCTION</code>: Must occur as the last instruction of the list and nowhere else.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="GOTO-Conversion">7. GOTO Conversion</h2><center><img loading="lazy" src="/posts/d48bdd8/1.svg" width="700"></center><center>Fig 1. GOTO Conversion</center><p>Each symbol in the symbol table with function type (that is, the symbol’s type field contains a <code>code_typet</code>) will be converted to a corresponding <code>GOTO</code> program. The conversion happens in <strong>two</strong> phases:</p><ol><li><code>goto_convertt::convert</code> turns each <code>codet</code> in the symbol table into corresponding GOTO instructions</li><li><code>goto_convertt::finish_gotos</code> and others (i.e. <code>goto_convertt::optimize_guarded_gotos</code>) populate the <code>GOTO</code> and <code>CATCH</code> instructions’ targets members, pointing to their possible successors. <code>DEAD</code> instructions are also added when GOTO instructions branch out of one or more lexical blocks</li></ol><p><code>codet</code> represents statements, which is a subset of expression( inherit from <code>exprt</code>). </p><ul><li><code>exprt</code>&#x2F; <code>typet</code>: </li><li><code>Statement</code>: </li><li><code>Operands</code>:</li></ul><p>The grammar of a (By default.)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">            statment        operand(s) </span><br><span class="line">------------------------------------------------</span><br><span class="line">codet ::=</span><br><span class="line">      |     block</span><br><span class="line">      |     decl            op0</span><br><span class="line">      |     decl            op0, op1</span><br><span class="line">      |     decl-block</span><br><span class="line">      |     expression      op0</span><br><span class="line">      |     assign          op0, op1</span><br><span class="line">      |     init            op0, op1</span><br><span class="line">      |     assert          op0</span><br><span class="line">      |     assume</span><br><span class="line">      |     function_call</span><br><span class="line">      |     label           op0</span><br><span class="line">      |     switch_case     op0, op1</span><br><span class="line">      |     for             op0, op1, op2, op3</span><br><span class="line">      |     while           op0, op1</span><br><span class="line">      |     dowhile         op0, op1</span><br><span class="line">      |     switch</span><br><span class="line">      |     break</span><br><span class="line">      |     return</span><br><span class="line">      |     continue</span><br><span class="line">      |     goto</span><br><span class="line">      |     skip</span><br><span class="line">      |     non-deterministic-goto</span><br><span class="line">      |     ifthenelse</span><br><span class="line">      |     atomic_begin</span><br><span class="line">      |     atomic_end</span><br><span class="line">      |     cpp_delete</span><br><span class="line">      |     cpp_delete[]</span><br><span class="line">      |     cpp-catch</span><br><span class="line">      |     throw_decl</span><br><span class="line">      |     throw_decl_end</span><br><span class="line">      |     dead</span><br></pre></td></tr></table></figure><h3 id="Stage-1-Conversion-from-statement-to-goto-instruction">7.1. Stage 1: Conversion from statement to goto-instruction</h3><ul><li>Note that did not cover the case that <code>atomicity-check</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function                  Input (codet)                 Output (codet/instructiont)</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line">convert_block             (block)                       (codet*)</span><br><span class="line">convert_decl              (decl, op0)                   DECL</span><br><span class="line">                          (decl, op0, op1)              DECL ASSIGN</span><br><span class="line">convert_decl_block        (decl-block)                  (codet*)</span><br><span class="line">convert_expression        (expression, op0)             (ifthenelse)</span><br><span class="line">                          (expression, op0)             OTHER</span><br><span class="line">convert_assign            (assign, op0, op1)            ASSIGN</span><br><span class="line">convert_init              (init, op0, op1)              (assign)</span><br><span class="line">convert_assert            (assert, op0)                 ASSERT</span><br><span class="line">convert_assume            (assume, op0)                 ASSUME</span><br><span class="line">convert_function_call     (function_call)               (codet)</span><br><span class="line">convert_label             (label, op0)                  (codet)</span><br><span class="line">convert_switch_case       (switch_case, op0, op1)       (codet)</span><br><span class="line">convert_for               (for, op0, op1, op2, op3)     NO_INSTRUCTION_TYPE SKIP GOTO</span><br><span class="line">                          (for, op0, op1, op2, op3)     NO_INSTRUCTION_TYPE SKIP SKIP GOTO</span><br><span class="line">convert_while             (while, op0, op1)             SKIP GOTO</span><br><span class="line">convert_dowhile           (dowhile, op0, op1)           NO_INSTRUCTION_TYPE SKIP GOTO</span><br><span class="line">convert_switch            (switch)                      NO_INSTRUCTION_TYPE SKIP GOTO*</span><br><span class="line">convert_break             (break)                       GOTO</span><br><span class="line">convert_return</span><br></pre></td></tr></table></figure><ul><li><p><code>block</code>: By <code>goto_convertt::convert_block</code>Convert each expression (<code>exprt</code>) , which is stored as operand (<code>op</code>), to <code>codet</code>.  Each new <code>codet</code> then converts to goto-instruction later.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;        <span class="comment">// block begin</span></span><br><span class="line">  <span class="type">int</span> x; <span class="comment">// op[0]  =&gt;  codet(decl)   </span></span><br><span class="line">  x=<span class="number">1</span>;   <span class="comment">// op[1]  =&gt;  codet(assign)</span></span><br><span class="line">  ...   </span><br><span class="line">&#125;       <span class="comment">// block end</span></span><br></pre></td></tr></table></figure></li><li><p><code>decl</code>: takes <strong>one</strong> or <strong>two</strong> operands and always expects symbol as first operand (<code>op0</code>).</p><ul><li>if <strong>one</strong>, then generates a <code>DECL</code> instruction only.</li><li>if <strong>two</strong>, first the statement breaks up into decl and assignment, then generates a <code>DECL</code> instruction and a <code>ASSIGN</code> instruction.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">// one operand, will be converted to DECL</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// two operand, will be spilted to two sub statement and converted to DECL and ASSIGN</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>decl-block</code>: Semantically like <code>block</code>.</p></li><li><p><code>expression</code>: takes <strong>one</strong> operand</p><ul><li>if  </li><li>else</li></ul></li><li><p><code>assign</code>:  takes <strong>two</strong> operands, denoted as <code>lhs</code>(<code>op0</code>) and <code>rhs</code>(<code>op1</code>)</p><ul><li>d</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">func</span>()      <span class="comment">// function_call </span></span><br><span class="line">x = <span class="keyword">new</span> <span class="built_in">class</span>() <span class="comment">// cpp_new</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>] <span class="comment">// cpp_new[]</span></span><br><span class="line">x = y           <span class="comment">// other cases</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="block-code-statment-to-code-blockt">7.1.1. block code statment to code_blockt</h4><p>  - </p><h3 id="Stage-2-target-generation-and-optimisation">7.2. Stage 2: target generation and optimisation</h3><h3 id="Example">7.3. Example</h3><center><img loading="lazy" src="/posts/d48bdd8/2.svg" width="700"></center><center>Fig 2. C Program Being Converted Into GOTO Code </center><center>source: <a href="http://cprover.diffblue.com/group__goto-programs.html">cprover: goto-conversion</a></center><h2 id="Referrence">8. Referrence</h2><p>The syntax grammar are referred to:</p><ul><li><code>goto_*.h</code>&#x2F; <code>goto_*.cpp</code></li><li><code>symex_*.h</code>&#x2F; <code>symex_*.cpp</code></li><li><code>irep2_*.h</code>&#x2F;<code>irep2_*.cpp</code></li><li><a href="http://cprover.diffblue.com/group__goto-programs.html">cprover: goto-programs</a></li><li><a href="http://cprover.diffblue.com/group__util.html">cprover: util</a></li></ul><p>During this process, instruction can be very similar comparing to original expression, for instance, the code expression \lstinline{assert(x&#x3D;&#x3D;1)} compares to its GOTO instrucitons form  \lstinline{ASSERT x &#x3D;&#x3D; 1}.</p><p>Have breaking change.</p><ol><li>chaifen</li><li>zhuanhua</li></ol>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/d48bdd8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ESBMC-An Efficient SMT-based Software Model Checker</title>
      <link>https://hejueyun.github.io/posts/2f42f06c/</link>
      <guid>https://hejueyun.github.io/posts/2f42f06c/</guid>
      <pubDate>Wed, 20 Apr 2022 20:02:42 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;It(ESBMC) does not require any special annotations in the source code to find such bugs, but it allows users to add their assertions and checks if they hold. In addition, ESBMC implements a k-induction proof rule and can be used to prove the absence of property violations (resp. the validity of user-defined assertions)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它（ESBMC）不需要在源代码中进行任何特殊的注释来发现这种错误，但它允许用户添加他们的断言并检查它们是否成立。此外，ESBMC实现了一个k-归纳证明规则，可以用来证明没有违反属性（即用户定义的断言的有效性）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ESBMC-Architecture&quot;&gt;2. ESBMC Architecture&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/2f42f06c/1.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;One of the significant challenges in software verification is the development and maintenance of an infrastructure that can reliably and efficiently handle real-world programs; it is an issue that only intensifies given the ever-evolving programming language standards.&lt;ul&gt;
&lt;li&gt;新标准发布需要新的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Front-end&quot;&gt;2.1. Front-end&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;an important piece of technology that should facilitate the transition between the &lt;strong&gt;program&lt;/strong&gt; under verification and a &lt;strong&gt;format&lt;/strong&gt; the tool can work upon&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Clang&quot;&gt;2.1.1. Clang&lt;/h4&gt;&lt;p&gt;Clang是LLVM编译器的c-family前端，Clang可能意指三种不同的实体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端（在Clang库中实现）&lt;/li&gt;
&lt;li&gt;编译器驱动程序（在clang命令和Clang驱动程序库中实现）&lt;/li&gt;
&lt;li&gt;实际的编译器（在clang -cc1命令中实现）。clang -cc1中的编译器不仅是由Clang库实现，还广泛地使用其他LLVM库来实现编译器的中端、后端以及集成的汇编器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clang -emit-llvm -c size.c -o size.bc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Introduction">1. Introduction</h2><blockquote><p>It(ESBMC) does not require any special annotations in the source code to find such bugs, but it allows users to add their assertions and checks if they hold. In addition, ESBMC implements a k-induction proof rule and can be used to prove the absence of property violations (resp. the validity of user-defined assertions)</p><ul><li>它（ESBMC）不需要在源代码中进行任何特殊的注释来发现这种错误，但它允许用户添加他们的断言并检查它们是否成立。此外，ESBMC实现了一个k-归纳证明规则，可以用来证明没有违反属性（即用户定义的断言的有效性）</li></ul></blockquote><h2 id="ESBMC-Architecture">2. ESBMC Architecture</h2><center><img loading="lazy" src="/posts/2f42f06c/1.png" width="600"></center><ul><li>One of the significant challenges in software verification is the development and maintenance of an infrastructure that can reliably and efficiently handle real-world programs; it is an issue that only intensifies given the ever-evolving programming language standards.<ul><li>新标准发布需要新的支持</li></ul></li></ul><h3 id="Front-end">2.1. Front-end</h3><ul><li>an important piece of technology that should facilitate the transition between the <strong>program</strong> under verification and a <strong>format</strong> the tool can work upon</li></ul><h4 id="Clang">2.1.1. Clang</h4><p>Clang是LLVM编译器的c-family前端，Clang可能意指三种不同的实体：</p><ul><li>前端（在Clang库中实现）</li><li>编译器驱动程序（在clang命令和Clang驱动程序库中实现）</li><li>实际的编译器（在clang -cc1命令中实现）。clang -cc1中的编译器不仅是由Clang库实现，还广泛地使用其他LLVM库来实现编译器的中端、后端以及集成的汇编器。</li><li><code>clang -emit-llvm -c size.c -o size.bc</code></li></ul><blockquote><p>Using the LLVM bitcode in the verification process <strong>brings some advantages</strong>; the bitcode is highly optimized by LLVM and will simplify the verification, thus reducing costs. <strong>However</strong>, <strong>there are disadvantages to this process</strong>, including <strong>losing context information</strong> (e.g., variable, class and function names are mangled in C++ ), source location information; <strong>in rare cases, optimizations can generate wrong results</strong> . While the latter can be avoided by disabling optimizations (and thus losing one of <strong>this approach’s</strong> advantages), the other two are not easily avoided by software verifiers.</p></blockquote><ul><li>其他前端的不足还是在于会丢失source location information<ul><li>丢失了会怎么样呢？</li></ul></li></ul><h4 id="ESBMC-Front-end">2.1.2. ESBMC Front-end</h4><ul><li>Instead of working on the LLVM bitcode, <strong>ESBMC accesses the AST that generates the bitcode</strong><ul><li>We developed a new front-end <strong>based on clang</strong>. </li><li>We use <strong>clang</strong> to parse the C program, which generates the clang AST, and we <strong>convert it to the ESBMC AST</strong></li></ul></li></ul><h4 id="versus">2.1.3. versus</h4><ul><li>The clang front-end brings several <strong>advantages</strong> to the verification process. <ul><li>First, clang has a powerful static analyzer. It can provide state-of-the-art compiler diagnostics of the program, thus <strong>issuing the same warnings and errors</strong> that one would expect from a conventional compilation. </li><li>Second, <strong>the support for new language features is simplified</strong>. A newAST node converter needs only to be added to the converter class in ESBMC, rather than layering in the feature from flex lexer to type-checker. </li><li>Finally, by choosing the AST instead of the bitcode, <strong>a complete representation of the original program is available, including the original names of every class, function, and variable</strong>.</li></ul></li><li>The <strong>disadvantage</strong> is that ESBMC is <strong>unable to access the optimizations</strong> that LLVM performs on the bitcode</li></ul><h3 id="GOTO-Converter">2.2. GOTO Converter</h3><ul><li><p>This representation is similar to the control flow graph (CFG) representation used by conventional compilers, but we associate program statements with edges. </p><ul><li>In this process, the GOTOprogram is also simplified, and <strong>new property checks and instructions can be added</strong>.</li></ul></li><li><p>The GOTOprogram is a simplified version ofthe program: a branch and a backward GOTO replace for and while loops. It is very similar to a C program, containing assignments, function calls and returns, and location information.</p></li><li><p>Once the GOTO program is generated, the following transformations can be applied, depending on the set of options given to ESBMC:</p><ul><li><strong>Function inlining</strong><ul><li>replaces function calls with the instructions of the called function.</li></ul></li><li><strong>Interval analysis</strong><ul><li>performs an <strong>interval analysis</strong>区间分析 for integer variables</li><li>The intervals are added back into the GOTO program as assumptions</li></ul></li><li><strong>Code transformations</strong><ul><li>introduce new instructions depending on several factors. </li><li>In particular, concurrency instructions can be inserted if the program is multi-threaded, and k-induction specific instructions are introduced if kinduction verification is enabled</li></ul></li><li><strong>Property checks</strong><ul><li>can insert several property checks into the GOTO program, including division by zero checks, integer, and float overflow checks, NaN checks (i.e., whether the result of an operation can be NaN), data race checks, deadlock checks, and atomicity checks. All these properties are encoded as <strong>assertions</strong> in the GOTO program.</li></ul></li></ul></li></ul><h3 id="Symbolic-Engine-Generating-SSA">2.3. Symbolic Engine: Generating SSA</h3><p>static single assignment (SSA)</p><ul><li><p>unwinds解开 the GOTO program from the previous step</p></li><li><p>add further property checks, including <strong>dynamic memory checks</strong> (bounds, memory alignment, offset pointer-free, and double-free) and unwinding assertions</p></li><li><p>Main Goal: <strong>introduce fresh copy for each occurrence</strong></p></li></ul><p>…</p><h3 id="SMT-Solver-SMT-Encoding-of-C-Programs">2.4. SMT Solver: SMT Encoding of C Programs</h3><p>After the SSA set is created, the next step is to encode every (not sliced) assignment in SMT and check for satisfiability. </p><ul><li>We use a notation of constraints C and properties P when encoding the set of SSA. <ul><li>A <strong>constraint</strong> is an <strong>assignment</strong> or an <strong>assumption</strong> in the program. It constrains the value of a variable</li><li>while a <strong>property</strong> is an <strong>assertion</strong> in the program. <strong>This property needs to hold given the set of constraints</strong>.</li></ul></li><li>The constraints and properties are encoded in the form $C∧¬P$: given the set of constraints, <strong>the SMT solver will try to find an assignment to variables</strong> that satisfies the constraints and violates at least one property. <ul><li>SMT求解器将试图找到一个满足约束条件并至少违反一个属性的变量赋值</li></ul></li><li>Finally, if the SMT solver finds a model, ESBMC will generate a program <strong>counterexample</strong>: a set of assignments and the program’s violated property.</li></ul><p>…</p><h2 id="ESBMC’s-Verification-Modes">3. ESBMC’s Verification Modes</h2><h3 id="Bounded-Model-Checking">3.1. Bounded Model Checking</h3><ul><li><p><a href="https://hejueyun.github.io/posts/ade5e95e/">Bounded Model Checking | 烏巢</a></p></li><li><p>A <strong>node</strong> in the <strong>CFG</strong> represents either a (non-) deterministic assignment or a conditional statement, while an edge in the CFG represents a possible change in the program’s control location.</p><ul><li>CFG中的一个节点代表一个（非）确定性的赋值或一个条件语句，而CFG中的一条边代表程序控制位置的可能变化。</li></ul></li><li><p>This graph is built as part of a translation process <strong>from program text to SSA</strong>.</p></li><li><p>A <strong>state transition system</strong>, denoted by M, is defined by a triple $(S, R, s_1)$ where S represents the set of states, $R ⊆ S × S$ represents the set of transitions and $s_1 ⊆ S$ represents the set of initial states.</p></li></ul><hr><blockquote><p>事实证明，程序的模型检查通常是一个难题。 造成这种情况的部分原因是，许多模型检查算法都在努力寻求一种“完整性”形式，<strong>它们要么找到踪迹(trace)，要么返回证明这种踪迹不可能存在的证据。</strong></p><ul><li>trace: shows what statements are executed and in which order.</li></ul><p>由于我们对<strong>生成测试用例</strong>感兴趣，因此我们更喜欢一种不同的方法：可能只有在很长时间执行后才能到达某个目标状态，或者根本无法到达，但是这些信息对我们构建测试用例没有帮助。 出于这个原因，我们引入了一个<strong>执行边界(execution bound)</strong> ，它描述了我们在分析程序时的<strong>深度</strong>。</p><p>使用这种执行边界的模型检查技术称为 <strong>有界模型检查(bounded model checking)</strong> ； 对于给定的边界 n，它们将返回一条跟踪信息或一条说明“无法在 n 步内达到目标状态”的语句。 因此，对于给定的边界，我们总是得到所有可以达到的状态的 <strong>近欠值(underapproximation， 即接近但没达到)</strong> ：我们当然可以在给定的范围内找到那些可以达到的状态，但是我们<strong>可以（may）</strong>(<em>故意地？</em>)错过只有通过更多步骤才能达到的状态。 相反，如果事实上有一种到达该状态的方法，我们将永远<br>不会声称某个状态在某个范围内是不可到达的</p></blockquote><h4 id="symbolic-model-checking-符号模型检测">3.1.1. symbolic model checking 符号模型检测</h4><ul><li>The bounded model checking techniques used by the CPROVER framework are based on <strong>symbolic model checking</strong>, a <strong>family</strong> of model checking techniques that work on <strong>sets of program states</strong> and use advanced tools such as SAT solvers (more on that below) <strong>to calculate the set of reachable states</strong>.</li></ul><center><img loading="lazy" src="/posts/2f42f06c/2.png" width="600"></center><h4 id="How-bounded-model-checking-works">3.1.2. How bounded model checking works</h4><ol><li>Use <strong>bit vector</strong> representation to describe <strong>variables</strong> and <strong>operations on binary number</strong></li><li>transform to <strong>SSA</strong><ol><li>we <strong>might</strong> modify the SSA form (i.e. introducing <code>guard</code>)</li><li>thus finish encoding the behavior of programs as propositional formulas</li></ol></li><li>add <code>ASSERT</code>:  describe the property we want to prove.<ol><li>To do this, we introduce a primitive <code>ASSERT</code>. Let <code>e</code> be some expression; then <code>ASSERT(e)</code> is supposed to do nothing if <code>e</code> evaluates to true, and to abort the program if <code>e</code> evaluates to false.</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Origin</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    result = b;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bringing this into SSA form</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    result<span class="number">.1</span> = b;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result<span class="number">.2</span> = a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Phi</span>(result<span class="number">.1</span>,result<span class="number">.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As a first step, we modify the SSA form slightly by introducing an additional propositional variable C that tracks which branch of the if was taken. We call this variable the code guard variable, or guard for short</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  bit C; <span class="comment">/* Track which branch was taken */</span></span><br><span class="line">  C = a &lt; b;</span><br><span class="line">  <span class="comment">/* if (C) - not needed anymore thanks to SSA */</span></span><br><span class="line">    result<span class="number">.1</span> = b;</span><br><span class="line">  <span class="comment">/* else */</span></span><br><span class="line">    result<span class="number">.2</span> = a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Phi</span>(C,result<span class="number">.1</span>,result<span class="number">.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>The resulting formula would be <blockquote><p>C &#x3D; a&lt;b and R1 &#x3D; B and R2 &#x3D; A and (C ⇒ return &#x3D; R1) and ((not C) ⇒ return &#x3D; R2).</p></blockquote></li></ul><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Origin</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">    result = b;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a;</span><br><span class="line">  <span class="built_in">ASSERT</span>(result &lt;= a); <span class="comment">// Added</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// The corresponding SSA would be </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  bit C; <span class="comment">/* Track which branch was taken */</span></span><br><span class="line">  C = a &lt; b;</span><br><span class="line">  result<span class="number">.1</span> = b;</span><br><span class="line">  result<span class="number">.2</span> = a;</span><br><span class="line">  <span class="built_in">ASSERT</span>(<span class="built_in">Phi</span>(C,result<span class="number">.1</span>,result<span class="number">.2</span>) &lt;= a);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Phi</span>(C,result<span class="number">.1</span>,result<span class="number">.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>We translate <code>ASSERT(Phi(C,result.1,result.2) &lt;= a)</code> into <blockquote><p>Φ(C,result.1,result.2) &lt;&#x3D; a </p></blockquote></li><li>The resulting formula would be <blockquote><p>C &#x3D; a&lt;b and R1 &#x3D; B and R2 &#x3D; A and (C ⇒ R1 &lt;&#x3D; A) and ((not C) ⇒ R2 &lt;&#x3D; A). (C ⇒ return &#x3D; R1) and ((not C) ⇒ return &#x3D; R2)</p></blockquote></li></ul><h3 id="Incremental-Bounded-Model-Checking">3.2. Incremental Bounded Model Checking</h3><ol><li>BMC tools drop completeness (i.e., the ability to prove that a program does not contain a bug) in favor of falsification. They are used mainly to find bugs, as they can only prove the absence of bugs if the whole state space is explored (e.g., all loops have been fully unwound). </li><li>In order to prove a program’s correctness, we need to compute the completeness threshold (CT), which can be smaller than or equal to the maximum number of loop iterations occurring in the program. However, computing CT to stop the BMC procedure and to conclude that no counterexample can be found is as hard as model checking the program </li><li>When running a BMC tool, one usually has to specify a bound k explicitly; this will be used to limit the visited regions of data structures (e.g., arrays) or the number of loop iterations. This limits the state space to be explored during verification, but leaves enough for real errors in applications to be found. </li><li>Since the best value for k is usually not known a priori先验, one must repeatedly run the BMC tool with increasing values of k; every increase of k will increase the number of loop iterations, the recursion depth, and the time and memory requirements. To check whether the value of k is big enough, BMC tools <strong>insert unwinding assertions after each loop</strong>. <strong>Failing these assertions does not mean that the program has a bug, but the verification is incomplete.</strong></li></ol><p><strong>In ESBMC, there are two versions of incremental BMC</strong></p><ol><li>CFG is unwound before the SSA generation by creating copies of the loop body and removing the backward GOTO instruction.<ol><li>The main <strong>difference</strong> between the static incremental BMC algorithm in <strong>ESBMC</strong> and the one described by <strong>Donaldson</strong> is the handling of nested loops.</li><li>In both algorithms, the number of loop unwindings is set globally. However, nested inner loops are unwound first in ESBMC, while in Donaldson’s work outermost loops are unwound first.</li></ol></li><li>algorithm that incrementally unwinds the state transition system by running the symbolic engine with incremental numbers of unwinds.<ol><li>which allows incremental verification in many different configurations.</li><li>Falsification&#x2F; Termination&#x2F; Incremental Verification&#x2F; k-Induction</li></ol></li></ol><h4 id="Loop-unrolling-循环展开">3.2.1. Loop unrolling 循环展开</h4><ul><li>循环展开（Loop unwinding或loop unrolling），是一种牺牲程序的大小来加快程序执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。</li><li>循环展开最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) </span><br><span class="line">   a[i] = a[i] * b + c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环展开2次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">58</span>; i+=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">  a[i] = a[i] * b + c;</span><br><span class="line">  a[i+<span class="number">1</span>] = a[i+<span class="number">1</span>] * b + c;</span><br><span class="line">  a[i+<span class="number">2</span>] = a[i+<span class="number">2</span>] * b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-k-induction-Algorithm">3.3. The k-induction Algorithm</h3><p>…</p><h2 id="参考">4. 参考</h2><ul><li><a href="https://blog.csdn.net/qq_36287943/article/details/109626082">LLVM - 学习笔记一 - zhugl0</a></li><li><a href="http://cprover.diffblue.com/background-concepts.html#BMC_section">cprover: Background Concepts - Bounded model checking</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/2f42f06c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>软件安全备忘录：CERT C Coding Standard笔记</title>
      <link>https://hejueyun.github.io/posts/e8d0ec3/</link>
      <guid>https://hejueyun.github.io/posts/e8d0ec3/</guid>
      <pubDate>Fri, 08 Apr 2022 20:29:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Expressions-EXP&quot;&gt;1. Expressions (EXP)&lt;/h2&gt;&lt;h3 id=&quot;EXP30-C-Do-not-depend-on-the-order-of-evaluation-for-side-effects&quot;&gt;1.1. EXP30-C. Do not depend on the order of evaluation for side effects&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;At specific points during execution, known as &lt;strong&gt;sequence points&lt;/strong&gt;, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* i is modified twice between sequence points */&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i = ++i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* i is read other than to determine the value to be stored */&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a[i++] = i;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;副作用&quot;&gt;1.1.1. 副作用&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在产生一个值的过程中，表达式可能会对环境做出其他改变，这样的改变被称为副作用(side effect)，诸如变量的值被修改，或者输入输出流的数据有所变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;表达式&lt;code&gt;x + 1;&lt;/code&gt;就产生了一个值，但是它没有产生一个副作用&lt;/li&gt;
&lt;li&gt;表达式&lt;code&gt;x = x+ 3;&lt;/code&gt;产生了一个值，同时也会产生一个副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e8d0ec3/1.png&quot; width=&quot;600&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;EXP32-C-Do-not-access-a-volatile-object-through-a-nonvolatile-reference&quot;&gt;1.2. EXP32-C. Do not access a volatile object through a nonvolatile reference&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Expressions-EXP">1. Expressions (EXP)</h2><h3 id="EXP30-C-Do-not-depend-on-the-order-of-evaluation-for-side-effects">1.1. EXP30-C. Do not depend on the order of evaluation for side effects</h3><blockquote><p>At specific points during execution, known as <strong>sequence points</strong>, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i is modified twice between sequence points */</span> </span><br><span class="line">i = ++i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* i is read other than to determine the value to be stored */</span> </span><br><span class="line">a[i++] = i;</span><br></pre></td></tr></table></figure><ul><li>Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior</li></ul><h4 id="副作用">1.1.1. 副作用</h4><blockquote><p>在产生一个值的过程中，表达式可能会对环境做出其他改变，这样的改变被称为副作用(side effect)，诸如变量的值被修改，或者输入输出流的数据有所变化</p></blockquote><ul><li>表达式<code>x + 1;</code>就产生了一个值，但是它没有产生一个副作用</li><li>表达式<code>x = x+ 3;</code>产生了一个值，同时也会产生一个副作用</li></ul><center><img loading="lazy" src="/posts/e8d0ec3/1.png" width="600"></center><h3 id="EXP32-C-Do-not-access-a-volatile-object-through-a-nonvolatile-reference">1.2. EXP32-C. Do not access a volatile object through a nonvolatile reference</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> **ipp; </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> *ip;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i = %d.\n&quot;</span>, i);</span><br><span class="line">  ipp = &amp;ip; <span class="comment">/* May produce a warning diagnostic */</span> </span><br><span class="line">  ipp = (<span class="type">int</span>**) &amp;ip; <span class="comment">/* Constraint violation; may produce a warning diagnostic */</span></span><br><span class="line">  *ipp = &amp;i; <span class="comment">/* Valid */</span> </span><br><span class="line">  <span class="keyword">if</span> (*ip != <span class="number">0</span>) &#123; <span class="comment">/* Valid */</span> </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The assignment <code>ipp = &amp;ip</code> is not safe because it allows the valid code that follows to reference the value of the volatile object <code>i</code> through the non-volatile-qualified reference <code>ip</code></p></blockquote><ul><li>Accessing an object with a volatile-qualified type through a reference with a non-volatile-qualified type is undefined behavior</li></ul><h3 id="EXP33-C-Do-not-read-uninitialized-memory">1.3. EXP33-C. Do not read uninitialized memory</h3><blockquote><p>Although compilers and static analysis tools often detect uses of uninitialized variables when they have access to the source code, diagnosing the problem is difficult or impossible when either the initialization or the use takes place in object code for which the source code is inaccessible. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_negative</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sign;</span><br><span class="line">  <span class="built_in">set_flag</span>(number, &amp;sign); </span><br><span class="line">  <span class="keyword">return</span> sign &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *array = (<span class="type">int</span> *)<span class="built_in">malloc</span>(OLD_SIZE * <span class="built_in">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == array) &#123; </span><br><span class="line">  <span class="comment">/* Handle error */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; OLD_SIZE; ++i) &#123; </span><br><span class="line">  array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>The programmer neglected to account for the case where <code>number</code> is equal to 0. Because the local variable <code>sign</code> is uninitialized when calling <code>set_flag()</code> and is never written to by <code>set_flag()</code>, the comparison operation exhibits undefined behavior when reading sign.</li><li>Reading uninitialized variables is undefined behavior and can result in <strong>unexpected program behavior</strong>. In some cases, these security flaws may allow the <strong>execution of arbitrary code</strong>.</li></ul><h3 id="EXP34-C-Do-not-dereference-null-pointers">1.4. EXP34-C. Do not dereference null pointers</h3><blockquote><p>Dereferencing a null pointer is undefined behavior</p></blockquote><ul><li>Dereferencing a null pointer is undefined behavior, typically <strong>abnormal program termination</strong>. In some situations, however, dereferencing a null pointer can lead to the execution of arbitrary code</li></ul><h3 id="EXP35-C-Do-not-modify-objects-with-temporary-lifetime">1.5. EXP35-C. Do not modify objects with temporary lifetime</h3><blockquote><p>The C11 Standard introduced a new term: <strong>temporary lifetime</strong>. Modifying an object with temporary lifetime is undefined behavior</p><ul><li>the <strong>structure</strong> or <strong>union</strong> contains a member with <strong>array</strong> type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime.</li></ul></blockquote><hr><blockquote><p>This noncompliant code example conforms to the C11 Standard; however, it fails to conform to C99. If compiled with a C99-conforming implementation, this code has undefined behavior <strong>because the sequence point preceding the call to <code>printf()</code> comes between the call and the access by <code>printf()</code> of the string in the returned object</strong></p></blockquote><ul><li>也就是说C99下先后顺序不确定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">char</span> a[<span class="number">8</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> <span class="built_in">salutation</span>(<span class="type">void</span>) &#123; <span class="keyword">struct</span> <span class="title class_">X</span> result = &#123; <span class="string">&quot;Hello&quot;</span> &#125;; <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> <span class="built_in">addressee</span>(<span class="type">void</span>) &#123; <span class="keyword">struct</span> <span class="title class_">X</span> result = &#123; <span class="string">&quot;world&quot;</span> &#125;; <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Noncompliant*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, %s!\n&quot;</span>, <span class="built_in">salutation</span>().a, <span class="built_in">addressee</span>().a); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Compliant*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">X</span> my_salutation = <span class="built_in">salutation</span>(); </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">X</span> my_addressee = <span class="built_in">addressee</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, %s!\n&quot;</span>, my_salutation.a, my_addressee.a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Attempting to modify an array or access it after its lifetime expires may result in erroneous program behavior</li></ul><h3 id="EXP36-C-Do-not-cast-pointers-into-more-strictly-aligned-pointer-types">1.6. EXP36-C. Do not cast pointers into more strictly aligned pointer types</h3><blockquote><p>Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced type. Different alignments are possible for different types of objects. If the type-checking system is overridden by an explicit cast or the pointer is converted to a void pointer (void *) and then to a different type, the alignment of an object may be changed.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="type">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> *ip = (<span class="type">int</span> *)&amp;c; <span class="comment">/* This can lose information */</span> </span><br><span class="line">  <span class="type">char</span> *cp = (<span class="type">char</span> *)ip;</span><br><span class="line">  <span class="comment">/* Will fail on some conforming implementations */</span> </span><br><span class="line">  <span class="built_in">assert</span>(cp == &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = c; </span><br><span class="line">  <span class="type">int</span> *ip = &amp;i;</span><br><span class="line">  <span class="built_in">assert</span>(ip == &amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>the char pointer <code>&amp;c</code> is converted to the more strictly aligned int pointer <code>ip</code>. On some implementations, <code>cp</code> will not match <code>&amp;c</code>.</li><li>Accessing a pointer or an object that is not properly aligned can cause a program to <strong>crash</strong> or give erroneous information, or it can cause <strong>slow pointer accesses</strong> (if the architecture allows misaligned accesses).</li></ul><h4 id="EXP36-C-EX2">1.6.1. EXP36-C-EX2</h4><blockquote><p>If a pointer is known to be correctly aligned to the target type, then a cast to that type is permitted. There are several cases where a pointer is known to be correctly aligned to the target type. The pointer could point to an object declared with a suitable alignment specifier. It could point to an object returned by aligned_alloc(), calloc(), malloc(), or realloc()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Align c to the alignment of an int */</span> </span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">int</span>) <span class="type">char</span> c = <span class="string">&#x27;x&#x27;</span>; </span><br><span class="line">  <span class="type">int</span> *ip = (<span class="type">int</span> *)&amp;c; </span><br><span class="line">  <span class="type">char</span> *cp = (<span class="type">char</span> *)ip;</span><br><span class="line">  <span class="comment">/* Both cp and &amp;c point to equally aligned objects */</span> </span><br><span class="line">  <span class="built_in">assert</span>(cp == &amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXP37-C-Call-functions-with-the-correct-number-and-type-of-arguments">1.7. EXP37-C. Call functions with the correct number and type of arguments</h3><ul><li>Do not call a function with the wrong number or type of arguments.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* In another source file */</span> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">long</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this source file, no f prototype in scope */</span> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(x); <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>((<span class="type">long</span>)x); <span class="comment">//correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Calling a function with incorrect arguments can result in unexpected or unintended program behavior</li></ul><h3 id="EXP39-C-Do-not-access-a-variable-through-a-pointer-of-an-incompatible-type">1.8. EXP39-C. Do not access a variable through a pointer of an incompatible type</h3><ul><li>Modifying a variable through a pointer of an incompatible type (other than unsigned char) can lead to unpredictable results</li><li>Accessing an object by means of any other lvalue expression (other than unsigned char) is undefined behavior</li><li>Optimizing for performance can lead to aliasing errors that can be quite difficult to detect. Furthermore, as in the preceding example, unexpected results can lead to <strong>buffer overflow attacks</strong>, <strong>bypassing security checks</strong>, or unexpected execution.</li></ul><h3 id="EXP40-C-Do-not-modify-constant-objects">1.9. EXP40-C. Do not modify constant objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> **ipp; </span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">42</span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  ipp = &amp;ip; <span class="comment">/* Constraint violation */</span> </span><br><span class="line">  *ipp = &amp;i; <span class="comment">/* Valid */</span> </span><br><span class="line">  *ip = <span class="number">0</span>; <span class="comment">/* Modifies constant i (was 42) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXP42-C-Do-not-compare-padding-data">1.10. EXP42-C. Do not compare padding data</h3><ul><li>There may be unnamed padding within a structure object, but not at its beginning. . . . </li><li>There may be unnamed padding at the end of a structure or union.</li><li>unnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate value even after initialization<ul><li>结构和联合类型的对象的未命名成员不参与初始化。结构体对象的未命名成员在初始化后也有不确定的值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">s</span> &#123; </span><br><span class="line">  <span class="type">char</span> c; </span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">13</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wrong</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> s *left, <span class="type">const</span> <span class="keyword">struct</span> s *right)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">memcmp</span>(left, right, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> s))) &#123; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//correct</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> s *left, <span class="type">const</span> <span class="keyword">struct</span> s *right)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ((left &amp;&amp; right) &amp;&amp; (left-&gt;c == right-&gt;c) </span><br><span class="line">  &amp;&amp; (left-&gt;i == right-&gt;i) </span><br><span class="line">  &amp;&amp; (<span class="number">0</span> == <span class="built_in">memcmp</span>(left-&gt;buffer, right-&gt;buffer, <span class="number">13</span>))) &#123; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>memcmp()</code> is used to compare the contents of two structures, including any padding bytes</li></ul><h4 id="EXP42-C-EX1">1.10.1. EXP42-C-EX1</h4><center><img loading="lazy" src="/posts/e8d0ec3/2.png" width="550"></center><h3 id="EXP43-C-Avoid-undefined-behavior-when-using-restrict-qualified-pointers">1.11. EXP43-C. Avoid undefined behavior when using restrict-qualified pointers</h3><ul><li><p>deleting all instances of the qualifier from a program does not change its meaning (that is, observable behavior).</p></li><li><p>undefined behavior:</p><blockquote><p>A restrict-qualified pointer is assigned a value based on another restricted pointer whose associated block neither began execution before the block associated with this pointer, nor ended before the assignment </p></blockquote></li><li><p><strong><code>restrict</code> says that two pointers cannot point to overlapping重叠的 memory regions. The most common usage is for function arguments.</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *restrict a; </span><br><span class="line"><span class="type">int</span> *restrict b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  c[<span class="number">0</span>] = <span class="number">17</span>; </span><br><span class="line">  c[<span class="number">1</span>] = <span class="number">18</span>;</span><br><span class="line">  a = &amp;c[<span class="number">0</span>]; </span><br><span class="line">  b = &amp;c[<span class="number">1</span>];</span><br><span class="line">  a = b; <span class="comment">/* Undefined behavior */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>The incorrect use of restrict-qualified pointers can result in undefined behavior that might be exploited to cause data <strong>integrity</strong> violations.</li></ul><h3 id="EXP44-C-Do-not-rely-on-side-effects-in-operands-to-sizeof-Alignof-or-Generic">1.12. EXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic</h3><ul><li>Some operators <strong>do not evaluate their operands beyond the type information the operands provide</strong>. When using one of these operators, do not pass an operand that would otherwise yield a side effect since the side effect will not be generated.</li><li>The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. In most cases, the operand is not evaluated. <ul><li>A possible exception is when the type of the operand is a variable length array type（VLA）</li><li>然而in the case of a VLA used in sizeof, have <strong>unspecified results</strong></li><li>所以结论还是不要在sizeof里副作用VLA</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">sizeof</span>(a++);</span><br></pre></td></tr></table></figure><ul><li>expression <code>a++</code> is not evaluated计算</li></ul><h3 id="EXP45-C-Do-not-perform-assignments-in-selection-statements">1.13. EXP45-C. Do not perform assignments in selection statements</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a = b) &#123; </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">/* ... */</span> &#125; <span class="keyword">while</span> (<span class="built_in">foo</span>(), x = y);</span><br></pre></td></tr></table></figure><h4 id="EXP45-C-EX2">1.13.1. EXP45-C-EX2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x = y)) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="EXP46-C-Do-not-use-a-bitwise-operator-with-a-Boolean-like-operand">1.14. EXP46-C. Do not use a bitwise operator with a Boolean-like operand</h3><ul><li>混淆了<code>&amp;</code>和<code>&amp;&amp;</code><ul><li>The expression <code>x &amp; y</code> will perform a bitwise operation on each individual bit in <code>x</code> and <code>y</code>. So if x is <code>1010</code> in binary and y is <code>1100</code> then <code>x &amp; y</code> will evaluate to <code>1000</code>.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">getuid</span>() &amp; <span class="built_in">geteuid</span>() == <span class="number">0</span>)) &#123; <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">getuid</span>() &amp;&amp; <span class="built_in">geteuid</span>() == <span class="number">0</span>)) &#123; <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Risk-Assessment">1.15. Risk Assessment</h3><table><thead><tr><th>Rule</th><th>Severity</th><th>Likelihood</th><th>Remediation Cost</th><th>Priority</th><th>Level</th></tr></thead><tbody><tr><td>EXP30-C</td><td>Medium</td><td>Probable</td><td>Medium</td><td>P8</td><td>L2</td></tr><tr><td>EXP32-C</td><td>Low</td><td>Likely</td><td>Medium</td><td>P6</td><td>L2</td></tr><tr><td>EXP33-C</td><td>High</td><td>Probable</td><td>Medium</td><td>P12</td><td>L1</td></tr><tr><td>EXP34-C</td><td>High</td><td>Likely</td><td>Medium</td><td>P18</td><td>L1</td></tr><tr><td>EXP35-C</td><td>Low</td><td>Probable</td><td>Medium</td><td>P4</td><td>L3</td></tr><tr><td>EXP36-C</td><td>Low</td><td>Probable</td><td>Medium</td><td>P4</td><td>L3</td></tr><tr><td>EXP37-C</td><td>Medium</td><td>Probable</td><td>High</td><td>P4</td><td>L3</td></tr><tr><td>EXP39-C</td><td>Medium</td><td>Unlikely</td><td>High</td><td>P2</td><td>L3</td></tr><tr><td>EXP40-C</td><td>Low</td><td>Unlikely</td><td>Medium</td><td>P2</td><td>L3</td></tr><tr><td>EXP42-C</td><td>Medium</td><td>Probable</td><td>Medium</td><td>P8</td><td>L2</td></tr><tr><td>EXP43-C</td><td>Medium</td><td>Probable</td><td>High</td><td>P4</td><td>L3</td></tr><tr><td>EXP44-C</td><td>Low</td><td>Unlikely</td><td>Low</td><td>P3</td><td>L3</td></tr><tr><td>EXP45-C</td><td>Low</td><td>Likely</td><td>Medium</td><td>P6</td><td>L2</td></tr><tr><td>EXP46-C</td><td>Low</td><td>Likely</td><td>Low</td><td>P9</td><td>L2</td></tr></tbody></table><h2 id="Memory-Mem">2. Memory (Mem)</h2><p>.</p><h2 id="Array-ARR">3. Array (ARR)</h2><p>.</p>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Software-Security/">Software Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/e8d0ec3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>软件安全备忘录：Mem Management</title>
      <link>https://hejueyun.github.io/posts/de2aa2c7/</link>
      <guid>https://hejueyun.github.io/posts/de2aa2c7/</guid>
      <pubDate>Fri, 01 Apr 2022 11:56:49 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;risk-assessment&quot;&gt;1. risk assessment&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CERT C Coding Standard contains a &lt;strong&gt;risk assessment&lt;/strong&gt; section&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Severity-严重性&quot;&gt;1.1. Severity 严重性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How serious are the consequences of the rule being ignored&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Examples of Vulnerabilities&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;low&lt;/td&gt;
&lt;td&gt;Denial-of-service attack, abnormal termination&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;medium&lt;/td&gt;
&lt;td&gt;Data integrity violation, unintentional information disclosure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;high&lt;/td&gt;
&lt;td&gt;Run arbitrary code&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;Likelihood-可能性&quot;&gt;1.2. Likelihood 可能性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How likely is it that a flaw introduced by ignoring the rule can lead to an exploitable vulnerability&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Unlikely&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Probable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;likely&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;Detection-and-Correction-检测和纠正&quot;&gt;1.3. Detection and Correction 检测和纠正&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;How will we cope with detection and correction&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="risk-assessment">1. risk assessment</h2><blockquote><p>CERT C Coding Standard contains a <strong>risk assessment</strong> section</p></blockquote><h3 id="Severity-严重性">1.1. Severity 严重性</h3><ul><li>How serious are the consequences of the rule being ignored</li></ul><table><thead><tr><th>Value</th><th>Meaning</th><th>Examples of Vulnerabilities</th></tr></thead><tbody><tr><td>1</td><td>low</td><td>Denial-of-service attack, abnormal termination</td></tr><tr><td>2</td><td>medium</td><td>Data integrity violation, unintentional information disclosure</td></tr><tr><td>3</td><td>high</td><td>Run arbitrary code</td></tr></tbody></table><h3 id="Likelihood-可能性">1.2. Likelihood 可能性</h3><ul><li>How likely is it that a flaw introduced by ignoring the rule can lead to an exploitable vulnerability</li></ul><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>1</td><td>Unlikely</td></tr><tr><td>2</td><td>Probable</td></tr><tr><td>3</td><td>likely</td></tr></tbody></table><h3 id="Detection-and-Correction-检测和纠正">1.3. Detection and Correction 检测和纠正</h3><ul><li>How will we cope with detection and correction</li></ul><table><thead><tr><th>Value</th><th>Meaning</th><th>Detection</th><th>Correction</th></tr></thead><tbody><tr><td>1</td><td>low</td><td>Automatic(Static and Dynamic Analysis)</td><td>Automatic(Fault Localisation and Repair)</td></tr><tr><td>2</td><td>medium</td><td>Automatic(Static and Dynamic Analysis)</td><td>Manual</td></tr><tr><td>3</td><td>high</td><td>Manual(Code Inspection)</td><td>Manual</td></tr></tbody></table><h3 id="Risk-Management">1.4. Risk Management</h3><ul><li>The three values are then multiplied together for each rule: severity, likelihood and remediation cost<ul><li>10 distinct values are possible: 1, 2, 3, 4, 6, 8, 9, 12, 18, and 27</li></ul></li><li>priority range<ul><li>12 to 27 are Level 1</li><li>6 to 9 are Level 2</li><li>1 to 4 are Level 3</li></ul></li></ul><center><img loading="lazy" src="/posts/de2aa2c7/2.png" width="550"></center><h2 id="CERT-C-Coding-Standard">2. CERT C Coding Standard</h2><h3 id="MEM30-C-Do-not-access-freed-memory">2.1. MEM30-C. Do not access freed memory</h3><p><strong>dangling pointers</strong>悬空指针</p><ul><li>Pointers to memory that has been deallocated<ul><li>Accessing a dangling pointer is undefined behaviour and can result in exploitable vulnerabilities</li></ul></li></ul><p><strong>example</strong></p><ul><li><code>p</code> is freed before <code>p-&gt;next</code> is executed, so that <code>p-&gt;next</code> reads memory that has already been freed</li></ul><p><strong>Risk Assessment</strong></p><ul><li>Reading memory that has been freed<ul><li>abnormal program termination</li><li>denial-of-service attacks</li></ul></li><li>Writing memory<ul><li>execution of arbitrary code</li></ul></li></ul><h3 id="MEM31-C-Free-dynamically-allocated-memory-when-no-longer-needed">2.2. MEM31-C. Free dynamically allocated memory when no longer needed</h3><p><strong>example</strong></p><ul><li>The object allocated by the call to malloc() is not freed before the end of the lifetime of the last pointer</li></ul><center><img loading="lazy" src="/posts/de2aa2c7/3.png" width="550"></center><h3 id="MEM33-C-Allocate-and-copy-structures-containing-a-flexible-array-member-dynamically">2.3. MEM33-C. Allocate and copy structures containing a flexible array member dynamically</h3><blockquote><p>As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply.</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/de2aa2c7/4.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/5.png" width="550"></center><h3 id="MEM34-C-Only-free-memory-allocated-dynamically">2.4. MEM34-C. Only free memory allocated dynamically</h3><ul><li>Freeing memory that is not allocated dynamically can result in heap corruption</li></ul><p><strong>Risk Assessment</strong></p><ul><li>The consequences of this error depend on the implementation<ul><li>they range from nothing to arbitrary code execution if that memory is reused by <code>malloc()</code></li></ul></li></ul><h3 id="MEM35-C-Allocate-sufficient-memory-for-an-object">2.5. MEM35-C. Allocate sufficient memory for an object</h3><ul><li>An insufficient amount of memory can be allocated where sizeof(long) is larger than sizeof(int), which can cause a heap buffer overflow</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/de2aa2c7/6.png" width="550"></center><h3 id="MEM36-C-Do-not-modify-the-alignment-of-objects-by-calling-realloc">2.6. MEM36-C. Do not modify the alignment of objects by calling realloc()</h3><ul><li>Do not invoke realloc() to modify the size of allocated objects that have stricter alignment requirements than those guaranteed by malloc()</li></ul><center><img loading="lazy" src="/posts/de2aa2c7/7.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/8.png" width="550"></center><center><img loading="lazy" src="/posts/de2aa2c7/9.png" width="550"></center><h2 id="Secure-C-Programming">3. Secure C Programming</h2><ol><li>Pointers should not be left uninitialized</li><li>They should be assigned either NULL or the address of a valid item in memory</li><li>When you use free to deallocate dynamically allocated memory, the pointer passed to free is not assigned a new value, so it still points to the memory location where the dynamically allocated memory used to be</li><li>When you free dynamically allocated memory, you should immediately assign the pointer either NULL or a valid address<ol><li>We chose not to do this for local pointer variables that immediately go out of scope after a call to free</li></ol></li><li>Undefined behavior occurs when you attempt to use free to deallocate dynamic memory that was already deallocated—this is known as a “double free vulnerability”</li><li>To ensure that you don’t attempt to deallocate the same memory more than once, immediately set a pointer to NULL after the call to free— attempting to free a NULL pointer has no effect</li><li>Function malloc returns NULL if it’s unable to allocate the requested memory</li><li>You should always ensure that malloc did not return NULL before attempting to use the pointer that stores malloc’s return value</li></ol><h2 id="Tool-Selection-and-Validation">4. Tool Selection and Validation</h2><blockquote><p>Although rule checking can be performed manually, with increasing program size and complexity, it rapidly becomes infeasible. For this reason, the use of static analysis tools is recommended</p><p>When choosing a source code analysis tool, it is clearly desirable that the tool be able to enforce as many of the guidelines on the wiki as possible</p></blockquote><h3 id="Completeness-and-Soundness">4.1. Completeness and Soundness</h3><blockquote><p>It should be recognized that, in general, determining conformance to coding rules and recommendations is computationally undecidable. The precision of static analysis has practical limitations.</p><ul><li>应该认识到，一般来说，确定是否符合编码规则和建议在计算上是无法决定的。静态分析的精确性有实际的限制。</li></ul></blockquote><blockquote><p>For example, the halting theorem of computer science states that programs exist in which exact control flow cannot be determined statically. Consequently, any property dependent on control flow—such as halting—may be indeterminate for some programs. A consequence of undecidability is that it may be impossible for any tool to determine statically whether a given guideline is satisfied in specific circumstances. The widespread presence of such code may also lead to unexpected results from an analysis tool.</p></blockquote><ul><li>the analysis may generate:<ul><li>Flase negatives</li><li>Flase positive</li></ul></li></ul><center><img loading="lazy" src="/posts/de2aa2c7/1.png" width="550"></center><ul><li>An analyzer is considered <strong>sound</strong> with respect to a specific guideline if it cannot give a false-negative result, meaning it finds all violations of the guideline within the entire program</li><li>An analyzer is considered <strong>complete</strong> if it cannot issue false-positive results, or false alarms</li><li>incomplete: <ul><li>You cannot prove everything that in the system is True</li><li>There are some assertion cannot be triggered.</li></ul></li></ul><h4 id="False-Negatives">4.1.1. False Negatives</h4><blockquote><p><strong>Failure to report a real flaw in the code is usually regarded as the most serious analysis error, as it may leave the user with a false sense of security</strong>. Most tools err on the side of caution and consequently generate false positives. </p></blockquote><h4 id="False-Positives">4.1.2. False Positives</h4><blockquote><p><strong>The tool reports a flaw when one does not exist</strong>. False positives may occur because the code is too complex for the tool to perform a complete analysis. The use of features such as function pointers and libraries may make false positives more likely</p></blockquote><h3 id="Taint-Analysis-污点分析">4.2. Taint Analysis 污点分析</h3><ul><li>If the value of an operand or argument may be outside the domain of an operation or function that consumes that value, and the value is derived from any external input to the program (such as a command-line argument, data returned from a system call, or data in shared memory), that value is tainted, and its origin is known as a tainted source.</li></ul><h4 id="Sanitization">4.2.1. Sanitization</h4><p>To remove the taint from a value, the value must be sanitized to ensure that it is in the defined domain of any restricted sink into which it flows.</p><ul><li>Operands and arguments whose domain is a subset of the domain described by their types are called restricted sinks. Any integer operand used in a pointer arithmetic operation is a restricted sink for that operand<ul><li>比如数组越界就算out of domain?</li></ul></li></ul><p>更多参考</p><ul><li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer — Clang 15.0.0git documentation</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Software-Security/">Software Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/de2aa2c7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Bounded Model Checking</title>
      <link>https://hejueyun.github.io/posts/ade5e95e/</link>
      <guid>https://hejueyun.github.io/posts/ade5e95e/</guid>
      <pubDate>Wed, 30 Mar 2022 22:02:54 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Circuit-Satisfiability&quot;&gt;1. Circuit Satisfiability&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ade5e95e/7.png&quot; width=&quot;650&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;problem&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ade5e95e/8.png&quot; width=&quot;650&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;由此引入了Formula Satisfiability&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;SAT&lt;/strong&gt; problem asks whether a given &lt;strong&gt;Boolean formula&lt;/strong&gt; is satisfiable&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;SMT&lt;/strong&gt; decides the satisfiability of &lt;strong&gt;first-order logic formulae&lt;/strong&gt; using the combination of different background theories&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ade5e95e/9.png&quot; width=&quot;450&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;BMC&quot;&gt;2. BMC&lt;/h2&gt;&lt;p&gt;BMC: 有界模型检测&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ade5e95e/4.png&quot; width=&quot;650&quot;&gt;&lt;/center&gt;

&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ade5e95e/10.png&quot; width=&quot;650&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Circuit-Satisfiability">1. Circuit Satisfiability</h2><center><img loading="lazy" src="/posts/ade5e95e/7.png" width="650"></center><ul><li>problem</li></ul><center><img loading="lazy" src="/posts/ade5e95e/8.png" width="650"></center><ul><li>由此引入了Formula Satisfiability<ul><li>The <strong>SAT</strong> problem asks whether a given <strong>Boolean formula</strong> is satisfiable</li><li>The <strong>SMT</strong> decides the satisfiability of <strong>first-order logic formulae</strong> using the combination of different background theories</li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/9.png" width="450"></center><h2 id="BMC">2. BMC</h2><p>BMC: 有界模型检测</p><center><img loading="lazy" src="/posts/ade5e95e/4.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/10.png" width="650"></center><h3 id="MC-vs-BMC">2.1. MC vs BMC</h3><center><img loading="lazy" src="/posts/ade5e95e/5.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/6.png" width="650"></center><ul><li>注意completeness threshold</li></ul><h3 id="example">2.2. example</h3><center><img loading="lazy" src="/posts/ade5e95e/11.jpg" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/12.jpg" width="650"></center><h3 id="Step">2.3. Step</h3><center><img loading="lazy" src="/posts/ade5e95e/13.png" width="650"></center><hr><center><img loading="lazy" src="/posts/ade5e95e/14.JPG" width="350"></center><h2 id="SAT-x2F-SMT-based-BMC-tools-for-C">3. SAT&#x2F;SMT-based BMC tools for C</h2><center><img loading="lazy" src="/posts/ade5e95e/15.png" width="650"></center><h3 id="Typical-features">3.1. Typical features</h3><ul><li><strong>full language support</strong><ul><li>bit-precise operations, structs, arrays, … </li><li>heap-allocated memory </li><li>concurrency</li></ul></li><li><strong>built-in safety checks</strong><ul><li>overflow, div-by-zero, array out-of-bounds indexing, … </li><li>memory safety: nil pointer deref, memory leaks, … </li><li>deadlocks, race conditions</li></ul></li><li><strong>user-specified assertions and error labels</strong></li><li><strong>non-deterministic modelling</strong> <ul><li>nondeterministic assignments </li><li>assume-statements</li></ul></li></ul><h3 id="General-Architecture-and-Approach">3.2. General Architecture and Approach</h3><center><img loading="lazy" src="/posts/ade5e95e/16.png" width="650"></center><p>General approach</p><ol><li>Simplify control flow</li><li>Unwind <strong>all</strong> of the loops (指的是都会被unwind，但unwind多少次还是由bound决定)</li><li>Convert into single static assignment (SSA) form</li><li>Convert into equations and simplify</li><li>(Bit-blast) <blockquote><p>“Bit-blasting”比特爆破 is a technique for <strong>reducing first-order terms and predicates</strong> in the theory of bit-vectors 1 <strong>to propositional logic</strong>. Every bit in each <strong>bit-vector term</strong> is represented by a propositional <strong>literal and clauses</strong> are added that link them.</p></blockquote></li><li>Solve with a SAT&#x2F;SMT solver</li><li>Convert SAT <strong>assignment</strong> into a counterexample</li></ol><h4 id="Control-flow-simplifications">3.2.1. Control flow simplifications</h4><ul><li>remove all side effects<ul><li>e.g., j&#x3D;++i; becomes i &#x3D;i+1; j &#x3D; i;</li></ul></li><li>simplify all control flow structures into core forms<ul><li>e.g., replace for, do while by while</li><li>e.g., replace case by if</li></ul></li><li>make control flow explicit<ul><li>e.g., replace continue, break by goto</li><li>e.g., replace if, while by goto</li></ul></li></ul><h4 id="Loop-unwinding">3.2.2. Loop unwinding</h4><ul><li>all loops are “unwound”<ul><li>i.e., replaced by several guarded copies of the loop body<ul><li>same for backward gotos and recursive functions </li><li>can use different unwinding bounds for different loops</li></ul></li><li>each statement is executed <strong>at most once</strong><ul><li>to check <strong>whether unwinding is sufficient</strong> special “unwinding assertion” claims are added</li></ul></li><li>⇒if a program satisfies all of its <strong>claims</strong> and all <strong>unwinding assertions</strong> then it is correct!</li></ul></li><li>multiple loops<ul><li>use <code>--partial-loops</code> to suppress insertion (?)</li><li>nsound</li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/17.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/18.png" width="650"></center><h4 id="Safety-conditions">3.2.3. Safety conditions</h4><ul><li>Built-in safety checks converted into explicit assertions<ul><li>e.g., array safety: <code>a[i]=...;</code> $\leftrightarrow$ <code>assert(0 &lt;= i &amp;&amp; i &lt; N); a[i]=...;</code></li></ul></li><li>sometimes easier at intermediate representation or formula level<ul><li>e.g., word-aligned pointer access, overflow, …</li></ul></li></ul><h4 id="Transforming-straight-line-programs-into-equations">3.2.4. Transforming straight-line programs into equations</h4><ul><li>each variable is assigned only once<ul><li><code>x=1; y=2;</code> $\leftrightarrow$ <code>x0=1; y0=2&#39;</code></li></ul></li><li>variables are assigned multiple times<ul><li><code>x=1; x=x+1;</code> $\leftrightarrow$ <code>x0=1; x1=x0+1;&#39;</code></li></ul></li><li>in control flow branches (if-statements)<ul><li>for each control flow <strong>join point</strong>连接点, add a new variable with <strong>guarded assignment</strong> as definition<ul><li>also called $ϕ$-function</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/19.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/20.png" width="650"></center><h4 id="Handling-arrays">3.2.5. Handling arrays</h4><ul><li>Arrays can be replaced by individual variables, with a “demux”解码 at each access<ul><li>surprisingly effective (for N&lt;1000) because value of i can often be determined statically<ul><li>due to <strong>constant propagation</strong></li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/21.png" width="650"></center><p><strong>Handling arrays with theories</strong></p><ul><li>Arrays can be seen as ADT (abstract data type, 抽象数据结构) with two operations:<ul><li>read</li><li>write</li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/22.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/23.png" width="650"></center><h4 id="Modeling-with-non-determinism">3.2.6. Modeling with non-determinism</h4><p>Extend C with three modeling features</p><ul><li><code>assert(e)</code>: <strong>aborts</strong> execution when e is false, no-op otherwise<ul><li><code>void assert (_Bool e) &#123; if (!e) exit(); &#125;</code></li></ul></li><li><code>nondet_int()</code>: <strong>returns</strong> non-deterministic非确定（也就是随机？） int-value<ul><li><code>int nondet_int () &#123; int x; return x; &#125;</code></li></ul></li><li><code>assume(e)</code>: <strong>“ignores”</strong> execution when e is false, no-op otherwise<ul><li><code>void assume (_Bool e) &#123; while (!e) ; &#125;</code></li></ul></li></ul><p><strong>General approach</strong></p><ul><li>use C program to set up structure and deterministic computations</li><li>use non-determinism to set up <strong>search space</strong> </li><li>use assumptions to constrain search space</li><li>use failing assertion to start search</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> x=<span class="built_in">nondet_int</span>(),y=<span class="built_in">nondet_int</span>(),z=<span class="built_in">nondet_int</span>(); </span><br><span class="line">  __ESBMC_assume(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; z &gt; <span class="number">0</span>); </span><br><span class="line">  __ESBMC_assume(x &lt; <span class="number">16384</span> &amp;&amp; y &lt; <span class="number">16384</span> &amp;&amp; z &lt; <span class="number">16384</span>); </span><br><span class="line">  <span class="built_in">assert</span>(x*x + y*y != z*z); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BMC-of-Multi-threaded-Software">4. BMC of Multi-threaded Software</h2><ul><li>见<a href="https://hejueyun.github.io/posts/536aff33/">Detection of Software Vulnerabilities: Static Analysis</a></li></ul><h2 id="SAT-vs-SMT">5. SAT vs SMT</h2><center><img loading="lazy" src="/posts/ade5e95e/24.png" width="650"></center><h2 id="SMT-based-BMC">6. SMT-based BMC</h2><ul><li>In SMT-based BMC, ψ is a <strong>quantifier-free</strong> formula in a <strong>decidable</strong> subset of <strong>first-order logic</strong> which is then checked for <strong>satisfiability</strong> by an SMT solver</li><li>SMT-based BMC must consider a number of <strong>issues that are not easily mapped into the theories supported by SMT solvers</strong> （i.e. embedded software）<blockquote><p>In previous work on SMTbased BMC for software only the theories of uninterpreted functions, arrays and linear arithmetic were considered, but no encoding was provided for <strong>ANSI-C constructs</strong> such as <strong>bit-level operations</strong>, <strong>fixedpoint</strong> <strong>arithmetic</strong>, <strong>pointers</strong> (i.e., pointer arithmetic and comparisons) and <strong>unions</strong>.</p></blockquote></li></ul><h3 id="Generation-of-VCs">6.1. Generation of VCs</h3><ul><li><p>VC: verification condition </p><blockquote><p>BMC unrolls the system k times and translates it into a verification condition (VC) $ψ$ such that $ψ$ is satisfiable if and only if $φ$ has a counterexample of depth k or less</p><p>The VC $ψ$ is a quantifier-free formula in a decidable subset of first-order logic, which is then checked for satisfiability by an SMT solver</p></blockquote></li><li><p><strong>model checking problem</strong> is formulated by constructing the following logical formula：$ψ_k&#x3D;I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} γ(s_j, s_{j+1}) \land \lnot φ(s_i)$</p><ul><li>$φ$ is a safety property</li><li>$I$ the set of initial states of $M$</li><li>$γ(s_j, s_{j+1})$ the transition relation of M between time steps $j$ and $j + 1$</li><li>$I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} γ(s_j,s_{j+1})$ <ul><li>represents the executions of M of length i and the original formula can be satisfied if and only if for some $i ≤ k$ there exists a reachable state at time step i in which φ is violated</li></ul></li></ul></li><li><p>If it is <strong>satisfiable</strong>, then the SMT solver provides a satisfying assignment, from which we can extract the values of the program variables to construct a counter-example</p><ul><li>A counter-example for a property φ is a sequence of states $s_0, s_1,…,s_k$ with $s_0 ∈ S_0$, $s_k ∈ S$, and $γ(s_i, s_{i+1})$ for $0 ≤ i &lt; k$.</li></ul></li><li><p>If it is <strong>unsatisfiable</strong>, we can conclude that no error state is reachable in k steps or less</p></li></ul><div class="admonition caution"><p>It is important to note that this approach can be used only to find violations of the property up to the bound k. In order to prove properties we need to compute the completeness threshold (CT), which can be smaller than or equal to the maximum number of loop-iterations occurring in the program (完备性阈值（CT），它可以小于或等于程序中出现的最大循环迭代次数)</p></div><ul><li>也就是有不有界都差不多了</li></ul><p>points</p><ul><li>the encoding techniques that we use to convert the constraints and properties from the ANSI-C programs into the <strong>different background theories of the SMT solvers</strong></li><li>approach to decide the best encoding and solver to be used during the verification process.</li></ul><h2 id="CBMC">7. CBMC</h2><ul><li>CBMC implements BMC for ANSI-C&#x2F;C++ programs using <strong>SAT</strong> solvers<ul><li>process C&#x2F;C++ code using the goto-cc tool</li><li>process the C&#x2F;C++ files and to build an abstract syntax tree (AST) (via internal parser based on Flex&#x2F;Bison)<blockquote><p>The typechecker of CBMC’s front-end annotates this AST with types and generates a symbol table. CBMC’s IRep class then converts the annotated AST into an internal, language-independent format used by the remaining phase of the front-end.</p></blockquote></li></ul></li></ul><h2 id="ESBMC">8. ESBMC</h2><h3 id="Tool-Architecture">8.1. Tool Architecture</h3><h4 id="Frontend">8.1.1. Frontend</h4><ul><li>The <strong>white</strong> boxes (except for the SMT solver) represent the components that we reused from the CBMC model checker without any modification</li></ul><h4 id="Middleware">8.1.2. Middleware</h4><ul><li><p>The <strong>gray</strong> boxes with dashed lines represent the components that we modified in order to:</p><ul><li>generate VCs to check for memory leaks (implemented in GOTO program</li><li>to simplify the unrolled formula (implemented in GOTO symex</li><li>to perform an <strong>up-front analysis</strong>先期分析 in the CFG of the program to determine the best encoding and solver for a particular program (implemented in GOTO symex</li></ul></li><li><p><strong>GOTO program component</strong></p><ul><li>converts the ANSI-C program into a GOTO-program, which simplifies the representation (e.g., replacement of switch and while by if and goto statements)</li><li>and handles the unrolling of the loops and the elimination of recursive functions</li></ul></li><li><p><strong>GOTO symex component</strong></p><ul><li>performs a symbolic simulation of the program</li></ul></li></ul><h4 id="Backend">8.1.3. Backend</h4><ul><li>In the back-end of ESBMC, we build two sets of quantifier-free formulae C (for the constraints) and P (for the properties)<ul><li>C encodes the first part of $ψ_k$ (more precisely, $I(s_0) \land \bigvee_{i&#x3D;0}^k \bigwedge_{j&#x3D;0}^{i-1} γ(s_j, s_{j+1})$ )</li><li>$¬P$ encodes the second part (more precisely, $\bigvee_{i&#x3D;0}^k \lnot φ(s_i)$)</li><li>we check $C \models_{\tau} P$ using an SMT solver<ul><li>If the answer is satisfiable, we have found a violation of the property φ, which is encoded in $ψ_k$. </li><li>If not, the property holds up to the bound k.</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/ade5e95e/2.png" width="650"></center><center><img loading="lazy" src="/posts/ade5e95e/3.png" width="650"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/ESBMC/">ESBMC</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/ade5e95e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-SMT</title>
      <link>https://hejueyun.github.io/posts/39d160ca/</link>
      <guid>https://hejueyun.github.io/posts/39d160ca/</guid>
      <pubDate>Thu, 10 Mar 2022 16:05:21 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论&quot;&gt;1. SAT vs SMT 布尔可满足性问题 vs  可满足性模理论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SMT将SAT推广到涉及 实数 、 整数 和&amp;#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串&lt;/li&gt;
&lt;li&gt;由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/39d160ca/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在命题逻辑公式里面混入了一些一阶逻辑表达式&lt;/li&gt;
&lt;li&gt;具有任意的布尔结构&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SAT solvers are automatic and efficient&lt;/p&gt;
&lt;p&gt;However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. &lt;strong&gt;A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/39d160ca/22.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SMT Solver &amp;#x3D; SAT Solver + Theory Solver&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Solver-vs-Checker&quot;&gt;2. Solver vs Checker&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论">1. SAT vs SMT 布尔可满足性问题 vs  可满足性模理论</h2><ul><li>SMT将SAT推广到涉及 实数 、 整数 和&#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串</li><li>由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)</li></ul><center><img loading="lazy" src="/posts/39d160ca/1.png" width="550"></center><p>SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：</p><ul><li>在命题逻辑公式里面混入了一些一阶逻辑表达式</li><li>具有任意的布尔结构</li></ul><blockquote><p>SAT solvers are automatic and efficient</p><p>However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. <strong>A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines</strong></p></blockquote><center><img loading="lazy" src="/posts/39d160ca/22.png" width="550"></center><hr><ul><li><strong>SMT Solver &#x3D; SAT Solver + Theory Solver</strong></li></ul><h2 id="Solver-vs-Checker">2. Solver vs Checker</h2><ul><li>In model checking, you have a model and a specification (or property), and you check if the model meets the specification.</li><li>In SAT solving, you have a formula and you try to find a satisfying assignment to it.</li></ul><hr><ul><li>To perform model checking a reachability analysis is needed and to do this the program transitions are often executed symbolically</li><li>The solution to the resulting satisfaction problem is created by a solver</li></ul><h2 id="overflow-溢出">3. overflow 溢出</h2><h3 id="arithmetic-overflow-算术溢出">3.1. arithmetic overflow 算术溢出</h3><ul><li>当计算产生出来的结果是非常大的，大于寄存器或存储器所能存储或表示的能力限制</li><li>任何数除以零的计算（Divided by zero）“不是”算术溢出的一种。在数学上只能明显算是不明确的定义（Undefined）；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值</li></ul><h3 id="arithmetic-underflow算术下溢">3.2. arithmetic underflow算术下溢</h3><ul><li>算术下溢也称为浮点数下溢，是指计算机浮点数计算的结果小于可以表示的最小数</li><li>例如，浮点数指数范围为-128至127，一个绝对值小于2−127的浮点数就会造成下溢（假设-128的阶码用于表示负无穷）</li></ul><h2 id="Theory-理论">4. Theory 理论</h2><ul><li>A theory T is a consistent一致的 set of first-order formulas<ul><li><strong>Equality</strong> (also called theory of uninterpreted functions UF</li><li><strong>Linear arithmetic</strong></li><li><strong>Arrays</strong></li><li>…</li></ul></li></ul><h3 id="一致性（consistency">4.1. 一致性（consistency)</h3><ul><li>指一个形式系统中不蕴涵矛盾<ul><li>语义上：当一个命题S是由许多命题组成时，如果所有命题可同时为真，则S是一致的，否则S是不一致的</li><li>语法上：公理系统不能推导出两个相反的结果。亦即不存在命题P，使得P→Q和P→~Q同时成立</li></ul></li></ul><h3 id="Validity-modulo-theories-有效性模式理论">4.2. Validity modulo theories 有效性模式理论</h3><ul><li>$T_1∪T_2∪…∪T_n \models{} ∀\bar{x}F(\bar{x})$</li><li>here each $T_i$ is a first-order theory and $F(\bar{x})$ is a quantifier-free formule</li></ul><center><img loading="lazy" src="/posts/39d160ca/3.png" width="550"></center><ul><li>$\simeq{}$ 大概是指logical equivalence<ul><li>非反常识的，可以用常识来理解</li></ul></li></ul><h3 id="Satisfiability-Modulo-Theories-可满足性模式理论">4.3. Satisfiability Modulo Theories 可满足性模式理论</h3><ul><li>From Validity Modulo Theories to Satisfiability Modulo Theories:</li></ul><center><img loading="lazy" src="/posts/39d160ca/4.png" width="550"></center><h3 id="SMT-solvers">4.4. SMT solvers</h3><center><img loading="lazy" src="/posts/39d160ca/5.png" width="550"></center><h2 id="Theory-of-equality-QF-UF-and-UF">5. Theory of equality (QF_UF and UF)</h2><ul><li>QF是指<code>quantifier-free</code></li></ul><center><img loading="lazy" src="/posts/39d160ca/6.png" width="550"></center><ul><li>Function congruence: 函数同构<ul><li><em>差不多相当于双射？</em></li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/7.png" width="550"></center><p><strong>issue</strong></p><ul><li>Equality axioms are very prolific多产的, resolution will quickly generate many irrelevant clauses.</li><li>Resolving with symmetry axiom we can produce all permutations of left and right sides of all equations. Transitivity axiom can resolve with symmetry axioms and itself producing longer clauses.</li></ul><h3 id="Inference-rules">5.1. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/8.png" width="550"></center><ul><li>Paramodulation: 调节</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/9.png" width="550"></center><ul><li>Idea: Only replace “bigger” terms by “smaller” terms</li><li>注意第七步不是 $f(b)&#x3D;f(b)$ ，不要马虎</li></ul><h3 id="Uninterpreted-function">5.2. Uninterpreted function</h3><ul><li>In mathematical logic, an uninterpreted function or function symbol is one that has no other property than its name and n-ary form. Function symbols are used, together with constants and variables, to form terms.<ul><li>相当于单纯0-ary符号$f$</li></ul></li><li>The theory of uninterpreted functions is also sometimes called the free theory, because it is freely generated, and thus a free object<ul><li>不被量词约束的</li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/10.png" width="550"></center><h2 id="Theory-of-Arrays">6. Theory of Arrays</h2><ul><li>Array signature $Σarray &#x3D;&lt; { select&#x2F;2, store&#x2F;3 } , { \simeq{}} &gt;$</li></ul><h3 id="Axioms公理">6.1. Axioms公理</h3><ul><li>$∀A, I , E [select(store(A, I , E ), I ) \simeq{} E ]$<ul><li>if we store an element in an array and read from the same position then we should obtain the same element</li><li>注意store的返回值是一个新的Array</li></ul></li><li>$∀A, I , J, E [I \not\simeq{} J → select(store(A, I , E ), J) \simeq{} select(A, J)]$<ul><li>if we store an element at position i then at all other positions elements are unchanged</li></ul></li></ul><h2 id="Theory-of-Linear-Arithmetic-（QF-LRA）">7. Theory of Linear Arithmetic （QF_LRA）</h2><h3 id="linear-constraints-线性约束">7.1. linear constraints 线性约束</h3><center><img loading="lazy" src="/posts/39d160ca/11.png" width="550"></center><hr><center><img loading="lazy" src="/posts/39d160ca/12.png" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/15.png" width="550"></center><h3 id="Inference-rules-1">7.2. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/14.png" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/16.png" width="550"></center><h2 id="SMT-solver">8. SMT solver</h2><center><img loading="lazy" src="/posts/39d160ca/13.png" width="550"></center><ul><li>也就是若theory solver最终结果不是 $\bot$ ,那么就是model中的一个值，即为sat</li></ul><h3 id="Abstract-DPLL">8.1. Abstract DPLL</h3><center><img loading="lazy" src="/posts/39d160ca/17.jpg" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/18.jpg" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/19.jpg" width="550"></center><ul><li>可以看到theory unsat的原因是1，2所以可以直接回退</li><li>注意最后一步不是decide所以没有back jump</li></ul><h3 id="minimal-steps">8.2. minimal steps</h3><center><img loading="lazy" src="/posts/39d160ca/21.png" width="550"></center><ul><li>简而言之就是只考虑产生影响的那几步，并写为negation加回Prop</li></ul><center><img loading="lazy" src="/posts/39d160ca/20.jpg" width="550"></center><h2 id="参考">9. 参考</h2><ul><li><a href="https://stackoverflow.com/questions/43908872/smt-sat-solver-vs-model-checker">SMT&#x2F;SAT Solver vs Model Checker - Stack Overflow</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/39d160ca/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
