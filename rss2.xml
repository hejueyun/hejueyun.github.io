<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>烏巢</title>
    <link>https://hejueyun.github.io/</link>
    
    <image>
      <url>https://hejueyun.github.io/icon.png</url>
      <title>烏巢</title>
      <link>https://hejueyun.github.io/</link>
    </image>
    
    <atom:link href="https://hejueyun.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 19 Mar 2022 22:26:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-SMT</title>
      <link>https://hejueyun.github.io/posts/39d160ca/</link>
      <guid>https://hejueyun.github.io/posts/39d160ca/</guid>
      <pubDate>Thu, 10 Mar 2022 16:05:21 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论&quot;&gt;1. SAT vs SMT 布尔可满足性问题 vs  可满足性模理论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SMT将SAT推广到涉及 实数 、 整数 和&amp;#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串&lt;/li&gt;
&lt;li&gt;由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/39d160ca/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在命题逻辑公式里面混入了一些一阶逻辑表达式&lt;/li&gt;
&lt;li&gt;具有任意的布尔结构&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;SAT solvers are automatic and efficient&lt;/p&gt;
&lt;p&gt;However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. &lt;strong&gt;A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SMT Solver &amp;#x3D; SAT Solver + Theory Solver&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Solver-vs-Checker&quot;&gt;2. Solver vs Checker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;In model checking, you have a model and a specification (or property), and you check if the model meets the specification.&lt;/li&gt;
&lt;li&gt;In SAT solving, you have a formula and you try to find a satisfying assignment to it.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="SAT-vs-SMT-布尔可满足性问题-vs-可满足性模理论">1. SAT vs SMT 布尔可满足性问题 vs  可满足性模理论</h2><ul><li>SMT将SAT推广到涉及 实数 、 整数 和&#x2F;或各种 数据结构 （如 列表 、 数组 、 位向量 和 字符串</li><li>由于布尔可满足性已经是 NP 完全的，所以 SMT 问题通常是 NP困难的 ，并且对于许多理论来说它是 不可判定(nondeterministic)</li></ul><center><img loading="lazy" src="/posts/39d160ca/1.png" width="550"></center><p>SMT是指另外一类公式的可满足性判定问题。这一类公式具有两个特点：</p><ul><li>在命题逻辑公式里面混入了一些一阶逻辑表达式</li><li>具有任意的布尔结构</li></ul><blockquote><p>SAT solvers are automatic and efficient</p><p>However, systems are usually designed and modeled at a higher level than the Boolean level and the translation to Boolean logic can be expensive. <strong>A primary goal of research in Satisfiability Modulo Theories (SMT) is to create verification engines that can reason natively at a higher level of abstraction, while still retaining the speed and automation of today’s Boolean engines</strong></p></blockquote><hr><ul><li><strong>SMT Solver &#x3D; SAT Solver + Theory Solver</strong></li></ul><h2 id="Solver-vs-Checker">2. Solver vs Checker</h2><ul><li>In model checking, you have a model and a specification (or property), and you check if the model meets the specification.</li><li>In SAT solving, you have a formula and you try to find a satisfying assignment to it.</li></ul><hr><ul><li>To perform model checking a reachability analysis is needed and to do this the program transitions are often executed symbolically</li><li>The solution to the resulting satisfaction problem is created by a solver</li></ul><h2 id="overflow-溢出">3. overflow 溢出</h2><h3 id="arithmetic-overflow-算术溢出">3.1. arithmetic overflow 算术溢出</h3><ul><li>当计算产生出来的结果是非常大的，大于寄存器或存储器所能存储或表示的能力限制</li><li>任何数除以零的计算（Divided by zero）“不是”算术溢出的一种。在数学上只能明显算是不明确的定义（Undefined）；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值</li></ul><h3 id="arithmetic-underflow算术下溢">3.2. arithmetic underflow算术下溢</h3><ul><li>算术下溢也称为浮点数下溢，是指计算机浮点数计算的结果小于可以表示的最小数</li><li>例如，浮点数指数范围为-128至127，一个绝对值小于2−127的浮点数就会造成下溢（假设-128的阶码用于表示负无穷）</li></ul><h2 id="Theory-理论">4. Theory 理论</h2><ul><li>A theory T is a consistent一致的 set of first-order formulas<ul><li><strong>Equality</strong> (also called theory of uninterpreted functions UF</li><li><strong>Linear arithmetic</strong></li><li><strong>Arrays</strong></li><li>…</li></ul></li></ul><h3 id="一致性（consistency">4.1. 一致性（consistency)</h3><ul><li>指一个形式系统中不蕴涵矛盾<ul><li>语义上：当一个命题S是由许多命题组成时，如果所有命题可同时为真，则S是一致的，否则S是不一致的</li><li>语法上：公理系统不能推导出两个相反的结果。亦即不存在命题P，使得P→Q和P→~Q同时成立</li></ul></li></ul><h3 id="Validity-modulo-theories-有效性模式理论">4.2. Validity modulo theories 有效性模式理论</h3><ul><li>$T_1∪T_2∪…∪T_n \models{} ∀\bar{x}F(\bar{x})$</li><li>here each $T_i$ is a first-order theory and $F(\bar{x})$ is a quantifier-free formule</li></ul><center><img loading="lazy" src="/posts/39d160ca/3.png" width="550"></center><ul><li>$\simeq{}$ 大概是指logical equivalence<ul><li>非反常识的，可以用常识来理解</li></ul></li></ul><h3 id="Satisfiability-Modulo-Theories-可满足性模式理论">4.3. Satisfiability Modulo Theories 可满足性模式理论</h3><ul><li>From Validity Modulo Theories to Satisfiability Modulo Theories:</li></ul><center><img loading="lazy" src="/posts/39d160ca/4.png" width="550"></center><h3 id="SMT-solvers">4.4. SMT solvers</h3><center><img loading="lazy" src="/posts/39d160ca/5.png" width="550"></center><h2 id="Theory-of-equality-QF-UF-and-UF">5. Theory of equality (QF_UF and UF)</h2><ul><li>QF是指<code>quantifier-free</code></li></ul><center><img loading="lazy" src="/posts/39d160ca/6.png" width="550"></center><ul><li>Function congruence: 函数同构<ul><li><em>差不多相当于双射？</em></li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/7.png" width="550"></center><p><strong>issue</strong></p><ul><li>Equality axioms are very prolific多产的, resolution will quickly generate many irrelevant clauses.</li><li>Resolving with symmetry axiom we can produce all permutations of left and right sides of all equations. Transitivity axiom can resolve with symmetry axioms and itself producing longer clauses.</li></ul><h3 id="Inference-rules">5.1. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/8.png" width="550"></center><ul><li>Paramodulation: 调节</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/9.png" width="550"></center><ul><li>Idea: Only replace “bigger” terms by “smaller” terms</li><li>注意第七步不是 $f(b)&#x3D;f(b)$ ，不要马虎</li></ul><h3 id="Uninterpreted-function">5.2. Uninterpreted function</h3><ul><li>In mathematical logic, an uninterpreted function or function symbol is one that has no other property than its name and n-ary form. Function symbols are used, together with constants and variables, to form terms.<ul><li>相当于单纯0-ary符号$f$</li></ul></li><li>The theory of uninterpreted functions is also sometimes called the free theory, because it is freely generated, and thus a free object<ul><li>不被量词约束的</li></ul></li></ul><center><img loading="lazy" src="/posts/39d160ca/10.png" width="550"></center><h2 id="Theory-of-Arrays">6. Theory of Arrays</h2><ul><li>Array signature $Σarray &#x3D;&lt; { select&#x2F;2, store&#x2F;3 } , { \simeq{}} &gt;$</li></ul><h3 id="Axioms公理">6.1. Axioms公理</h3><ul><li>$∀A, I , E [select(store(A, I , E ), I ) \simeq{} E ]$<ul><li>if we store an element in an array and read from the same position then we should obtain the same element</li><li>注意store的返回值是一个新的Array</li></ul></li><li>$∀A, I , J, E [I \not\simeq{} J → select(store(A, I , E ), J) \simeq{} select(A, J)]$<ul><li>if we store an element at position i then at all other positions elements are unchanged</li></ul></li></ul><h2 id="Theory-of-Linear-Arithmetic-（QF-LRA）">7. Theory of Linear Arithmetic （QF_LRA）</h2><h3 id="linear-constraints-线性约束">7.1. linear constraints 线性约束</h3><center><img loading="lazy" src="/posts/39d160ca/11.png" width="550"></center><hr><center><img loading="lazy" src="/posts/39d160ca/12.png" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/15.png" width="550"></center><h3 id="Inference-rules-1">7.2. Inference rules</h3><center><img loading="lazy" src="/posts/39d160ca/14.png" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/16.png" width="550"></center><h2 id="SMT-solver">8. SMT solver</h2><center><img loading="lazy" src="/posts/39d160ca/13.png" width="550"></center><h3 id="Abstract-DPLL">8.1. Abstract DPLL</h3><center><img loading="lazy" src="/posts/39d160ca/17.jpg" width="550"></center><center><img loading="lazy" src="/posts/39d160ca/18.jpg" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/39d160ca/19.jpg" width="550"></center><ul><li>可以看到theory unsat的原因是1，2所以可以直接回退</li><li>注意最后一步不是decide所以没有back jump</li></ul><h3 id="minimal-steps">8.2. minimal steps</h3><center><img loading="lazy" src="/posts/39d160ca/21.png" width="550"></center><ul><li>简而言之就是只考虑产生影响的那几步</li></ul><center><img loading="lazy" src="/posts/39d160ca/20.jpg" width="550"></center><h2 id="参考">9. 参考</h2><ul><li><a href="https://stackoverflow.com/questions/43908872/smt-sat-solver-vs-model-checker">SMT&#x2F;SAT Solver vs Model Checker - Stack Overflow</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/39d160ca/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-归结</title>
      <link>https://hejueyun.github.io/posts/e24b211f/</link>
      <guid>https://hejueyun.github.io/posts/e24b211f/</guid>
      <pubDate>Sun, 06 Mar 2022 21:08:15 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;atom-vs-literal-vs-term&quot;&gt;1. atom vs literal  vs term&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;a: $p$&lt;ul&gt;
&lt;li&gt;在一阶逻辑下得到扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;l: $p$  $\lnot{p}$  &lt;ul&gt;
&lt;li&gt;注意扩展到命题逻辑中时，$P$就可以带上函数和谓词&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In propositional calculus a literal is simply a propositional variable or its negation.&lt;/li&gt;
&lt;li&gt;In predicate calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, ${\displaystyle P(t_{1},\ldots ,t_{n})}$ with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example,  ${\displaystyle \neg Q(f(g(x),y,2),x)}$ is a negative literal with the &lt;strong&gt;constant symbol&lt;/strong&gt; 2, the &lt;strong&gt;variable symbols&lt;/strong&gt; x, y, the &lt;strong&gt;function symbol&lt;/strong&gt;s f, g, and the &lt;strong&gt;predicate symbol&lt;/strong&gt; Q.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;t: $p$  $f^{n}$  $a$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;合一-Unification&quot;&gt;2. 合一 Unification&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Let s and t be two terms (or atoms), A &lt;strong&gt;unifier&lt;/strong&gt; of s and t is a substitition &lt;strong&gt;σ&lt;/strong&gt; that makes the two identical, formally&lt;ul&gt;
&lt;li&gt;sσ &amp;#x3D; tσ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e24b211f/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;最一般的合一-Most-general-unifier&quot;&gt;2.1. 最一般的合一 Most general unifier&lt;/h3&gt;&lt;p&gt;σ is a most general unifier of s and t, denoted mgu(s, t),&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if σ is a unifier of s and t and for any other unifier θ of s and t,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;there is&lt;/strong&gt; a substitution ρ such that&lt;ul&gt;
&lt;li&gt;σρ &amp;#x3D; θ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Unifiers-and-most-general-unifiers-in-general&quot;&gt;2.2. Unifiers and most general unifiers, in general&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/e24b211f/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="atom-vs-literal-vs-term">1. atom vs literal  vs term</h2><ul><li>a: $p$<ul><li>在一阶逻辑下得到扩展</li></ul></li><li>l: $p$  $\lnot{p}$  <ul><li>注意扩展到命题逻辑中时，$P$就可以带上函数和谓词<blockquote><ul><li>In propositional calculus a literal is simply a propositional variable or its negation.</li><li>In predicate calculus a literal is an atomic formula or its negation, where an atomic formula is a predicate symbol applied to some terms, ${\displaystyle P(t_{1},\ldots ,t_{n})}$ with the terms recursively defined starting from constant symbols, variable symbols, and function symbols. For example,  ${\displaystyle \neg Q(f(g(x),y,2),x)}$ is a negative literal with the <strong>constant symbol</strong> 2, the <strong>variable symbols</strong> x, y, the <strong>function symbol</strong>s f, g, and the <strong>predicate symbol</strong> Q.</li></ul></blockquote></li></ul></li><li>t: $p$  $f^{n}$  $a$</li></ul><h2 id="合一-Unification">2. 合一 Unification</h2><ul><li>Let s and t be two terms (or atoms), A <strong>unifier</strong> of s and t is a substitition <strong>σ</strong> that makes the two identical, formally<ul><li>sσ &#x3D; tσ</li></ul></li></ul><center><img loading="lazy" src="/posts/e24b211f/1.png" width="550"></center><h3 id="最一般的合一-Most-general-unifier">2.1. 最一般的合一 Most general unifier</h3><p>σ is a most general unifier of s and t, denoted mgu(s, t),</p><ul><li>if σ is a unifier of s and t and for any other unifier θ of s and t,</li><li><strong>there is</strong> a substitution ρ such that<ul><li>σρ &#x3D; θ</li></ul></li></ul><h3 id="Unifiers-and-most-general-unifiers-in-general">2.2. Unifiers and most general unifiers, in general</h3><center><img loading="lazy" src="/posts/e24b211f/2.png" width="550"></center><ul><li>simultaneous&#x2F;ˌsaɪ.məlˈteɪ.ni.əs&#x2F; 同时的</li></ul><h2 id="unification-algorithm-合一算法求解mgu">3. unification algorithm 合一算法求解mgu</h2><ul><li>Input: An equational system E</li><li>Goal: Determine if E is unifiable, and <strong>if it is, to read off mgu</strong></li><li>Output: Equational system E’ in <strong>solved form</strong>, or ⊥ (for not unifiable)</li><li>Perform the following transformations on the set of equations <strong>as long as any one of them is applicable</strong>:<ul><li>注意一定要用到不能用为止，一般结果会是左式由带有同一变量的右式表达，例如：<ul><li>$x&#x3D;y$</li><li>$z&#x3D;f(y)$</li></ul></li></ul></li></ul><ol><li>Transform t&#x3D;x, where t is not a variable, to x&#x3D;t. 变量换到左侧，非变量换到右边</li><li>Erase the equation x&#x3D;x. 消除相等式</li><li>Let t′&#x3D;t″ be an equation where t′, t″ are not variables. “非变量&#x3D;非变量”的情况<ol><li>If the outermost function symbols of t′ and t″ are not identical, terminate the algorithm and report not unifiable. 如果t′和t″的最外层函数符号不一致，则终止算法，并报告<strong>不可合一</strong></li><li>Otherwise, replace the equation $f(t_1^{‘},…t_k^{‘})&#x3D;f(t_1^{‘’},…t_k^{‘’})$ by the k equations $t_1^{‘}&#x3D;t_1^{‘’},…t_k^{‘}&#x3D;t_k^{‘’}$ . 否则替换</li></ol></li><li>Let x&#x3D;t be an equation such that x has another occurrence in the set. 同一变量多次出现<ol><li>If x occurs in t and x differs from t, terminate the algorithm and report not unifiable</li><li>Otherwise, transform the set by replacing all occurrences of x in other equations by t. 否则，通过将其他方程中所有出现的x替换为t来转换这个集合</li><li>rule 4 also called the <strong>occurs-check</strong></li></ol></li></ol><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/3.png" width="650"></center><ul><li>得到mgu</li></ul><h3 id="⇒-U-unification-rules">3.1. $⇒_{U^-}$unification rules</h3><center><img loading="lazy" src="/posts/e24b211f/4.png" width="550"></center><ul><li>Orientation: 方向</li><li>Trivial: 琐碎（可理解为无价值）</li><li>Disagreement&#x2F;Clash：分歧&#x2F;冲突</li><li>Decomposition：分解</li><li>Occur-check：出现检查（可理解为存在检查）</li><li>Substitution：替换</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/5.png" width="550"></center><h3 id="term-equation">3.2. term equation</h3><ul><li>The unifiability of ${p(f(x)),g(y),p(f(f(a))),g(z)}$ is expressed by the set of term equations<ul><li>${f(x)&#x3D;f(f(a)), g(y)&#x3D;g(z)}$</li></ul></li></ul><h3 id="solved-form">3.3. solved form</h3><ul><li>A set of term equations is in solved form iff:<ul><li>All equations are of the form $x_i &#x3D;t_i$ where x i is a variable.</li><li>Each variable $x_i$ that appears on the left-hand side of an equation does not appear elsewhere in the set.</li></ul></li><li>A set of equations in solved form defines a substitution:<ul><li>${x_1\leftarrow{t_1},…,x_n\leftarrow{t_n}}$</li></ul></li></ul><h2 id="Ordered-resolution-with-selection">4. Ordered resolution with selection</h2><h3 id="Selection-functions">4.1. Selection functions</h3><ul><li>A selection function is a mapping<ul><li>$S : C\rightarrowtail{}$ (multi-)set of occurrences of <strong>negative</strong> literals in C</li></ul></li></ul><center><img loading="lazy" src="/posts/e24b211f/7.png" width="550"></center><h3 id="Maximal-and-strictly-maximal-literals">4.2. Maximal and strictly maximal literals</h3><center><img loading="lazy" src="/posts/e24b211f/6.png" width="550"></center><ul><li>特别注意第三个，要求的是there exist就可，因此类似 $P(f (x)) ∨ P (g(y))$中找最大，就得分情况讨论<ul><li>是否可能相等？</li></ul></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/8.png" width="550"></center><ul><li>A literal L is (strictly) maximal wrt. a general clause C<ul><li>iff ∃ gr. σ s.t. Lσ and $C_σ$ are ground and for all L’ in $C_σ$: $L_σ\geq{L’}$ ($L_σ&gt;{L’}$)</li></ul></li></ul><h2 id="General-resolution-system">5. General resolution system</h2><p>Ordered resolution with selection is parameterised参数化 with:</p><ul><li>a fixed total, well-founded ordering $&gt;$ on ground atoms</li><li>a fixed selection function S</li></ul><h3 id="Resolution-rule">5.1. Resolution rule</h3><center><img loading="lazy" src="/posts/e24b211f/9.png" width="550"></center><ul><li>Note: Renaming variables apart needs to be applied to the premises before applying resolution</li></ul><h3 id="Factoring-rule">5.2. Factoring rule</h3><center><img loading="lazy" src="/posts/e24b211f/10.png" width="550"></center><ul><li>Factors即为: $C∨A$</li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/11.png" width="550"></center><center><img loading="lazy" src="/posts/e24b211f/16.png" width="550"></center><p><strong>注意</strong></p><center><img loading="lazy" src="/posts/e24b211f/17.png" width="550"></center><h3 id="for-propositional-x2F-ground-clauses-回退到命题逻辑">5.3. for propositional&#x2F;ground clauses 回退到命题逻辑</h3><center><img loading="lazy" src="/posts/e24b211f/12.png" width="550"></center><h3 id="Search-spaces-become-smaller">5.4. Search spaces become smaller</h3><center><img loading="lazy" src="/posts/e24b211f/13.png" width="550"></center><h3 id="Properties-of-ordered-resolution-with-selection">5.5. Properties of ordered resolution with selection</h3><center><img loading="lazy" src="/posts/e24b211f/15.png" width="550"></center><p><strong>example</strong></p><center><img loading="lazy" src="/posts/e24b211f/14.png" width="550"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/e24b211f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-程序验证-协议安全分析</title>
      <link>https://hejueyun.github.io/posts/fa02fe64/</link>
      <guid>https://hejueyun.github.io/posts/fa02fe64/</guid>
      <pubDate>Thu, 03 Mar 2022 12:53:42 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;The-Neuman-Stubblebine-key-exchange-protocol&quot;&gt;1. The Neuman-Stubblebine key exchange protocol&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;breaking&quot;&gt;1.1. breaking&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/5.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;The intruder now sends a message to B, and the message will make B believe it’s actually from A. Thus B will start to use the wrong key, i.e. an insecure key. &lt;ul&gt;
&lt;li&gt;入侵者现在向B发送一个信息，这个信息将使B相信它实际上来自A，因此B将开始使用错误的密钥，即一个不安全的密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Verification-of-security-protocols-using-resolution&quot;&gt;2. Verification of security protocols using resolution&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The idea is that the security property says an unsafe state is possible&lt;/li&gt;
&lt;li&gt;Since first-order logic is not &lt;strong&gt;decidable&lt;/strong&gt;, there is however no guarantee that the saturation will terminate when the security property does not hold. Non-termination can therefore indicate the existence of a potential attack on the protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/fa02fe64/3.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Assumptions-in-security-protocol-analysis&quot;&gt;3. Assumptions in security protocol analysis&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="The-Neuman-Stubblebine-key-exchange-protocol">1. The Neuman-Stubblebine key exchange protocol</h2><center><img loading="lazy" src="/posts/fa02fe64/1.png" width="550"></center><center><img loading="lazy" src="/posts/fa02fe64/2.png" width="550"></center><h3 id="breaking">1.1. breaking</h3><center><img loading="lazy" src="/posts/fa02fe64/5.png" width="550"></center><ul><li>The intruder now sends a message to B, and the message will make B believe it’s actually from A. Thus B will start to use the wrong key, i.e. an insecure key. <ul><li>入侵者现在向B发送一个信息，这个信息将使B相信它实际上来自A，因此B将开始使用错误的密钥，即一个不安全的密钥。</li></ul></li></ul><h2 id="Verification-of-security-protocols-using-resolution">2. Verification of security protocols using resolution</h2><ul><li>The idea is that the security property says an unsafe state is possible</li><li>Since first-order logic is not <strong>decidable</strong>, there is however no guarantee that the saturation will terminate when the security property does not hold. Non-termination can therefore indicate the existence of a potential attack on the protocol.</li></ul><center><img loading="lazy" src="/posts/fa02fe64/3.png" width="550"></center><h2 id="Assumptions-in-security-protocol-analysis">3. Assumptions in security protocol analysis</h2><p>What can an intruder do?</p><ul><li>The intruder can capture all messages sent by one participant to another</li><li>It can send a message it has constructed to any other participant</li><li>It can generate new keys, new nonces, timestamps . . .</li><li>It can construct new messages from the ones it has, using legal constructors</li><li>The intruder can decompose分解 tuples from which messages are formed</li><li>It can decrypt encrypted parts, but only if it knows the key I.e. we assume perfect cryptography: an intruder cannot break any keys nor does it know any of the initial keys $K_{at}$ at or $K_{bt}$</li></ul><h2 id="Encoding">4. Encoding</h2><center><img loading="lazy" src="/posts/fa02fe64/4.png" width="550"></center><h3 id="The-capabilities-of-the-intruder入侵者">4.1. The capabilities of the intruder入侵者</h3><center><img loading="lazy" src="/posts/fa02fe64/6.png" width="550"></center><center><img loading="lazy" src="/posts/fa02fe64/7.png" width="550"></center><h2 id="SPASS">5. SPASS</h2><blockquote><p>SPASS is an automated theorem prover for first-order logic with equality. So the input for the prover is a first-order formula in our syntax. </p><ul><li>Running SPASS on such a formula results in the final output SPASS beiseite: <code>Proof found.</code> if the formula is valid, </li><li>SPASS beiseite: <code>Completion found.</code> if the formula is not valid </li><li>and because validity in first-order logic is undecidable, <strong>SPASS may run forever without producing any final result.</strong></li></ul></blockquote><hr><blockquote><p>An SPASS input file consists of three parts, a description part started with list_of_descriptions., a part where the signature is declared starting with list_of_symbols., a part where all axioms are given, starting with list_of_formulae(axioms). and a final part where all conjectures are presented, starting with list_of_formulae(conjectures)</p><p>Then SPASS tries to prove that the conjunction of all axiom formulae implies the disjunction of all conjectures</p></blockquote><h2 id="Saturation">6. Saturation</h2><blockquote><p>Aclause C is a <strong>condensation</strong> of a clause D,if C is a proper (unordered) factor of D that subsumes D</p><p>A set of clauses N is called <strong>saturated</strong> if it is closed under condensation, the deletion of subsumed clauses and any clause generated by an ordered resolution inference from clauses from N is subsumed by some clause in N</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/fa02fe64/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>西行漫记-其六</title>
      <link>https://hejueyun.github.io/posts/2ba8f82c/</link>
      <guid>https://hejueyun.github.io/posts/2ba8f82c/</guid>
      <pubDate>Sat, 26 Feb 2022 22:26:20 GMT</pubDate>
      
      <description>&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Authenticaiton Failed.&quot; data-whm=&quot;Authentication Error.&quot;&gt;
  &lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;a3bc817c3908ae67f704dabface47ef124dac94f6605c34ea7c8fd49515ab6c8&quot;&gt;63a8672ddbb5b9158eb55097173249fad22b496a8876cf71b079381ad234cb95f094e21606daf1717aa32ac9bb46c3ec99a387f812d0a9e5a45bfd529c7b8ed5f86a0a6f45900b64a15b4130bd6ed52d8ef450f58e114d4fe18874ddcc125aa94adc7a4a8723b962b279a3d4fb7200835168fbe214ea68576e259f43343e2c7a777ab0f877cfb6fb4968bbe09478ebb4c8d82d533ea85f08a5195375f39c020dcf3cc513e539010453d4dc45f2948ba6de705108a00df9f7fc634cf34cf86bc985f7ae3ca2e1587e4469e2a695bfe5527047967d1184b513411930c48dbd3b183dbfe7eee873eff520957b049943bd7990c9027c77c010cf1c251f76064497d73aea9ab2a92c884d7e6a130b44100c9333493c6642eb39253827e8e7ee7be21ffa64373cba57238a83b953034350313408910b4f2679f2f08874a410bd240537e5df887e00d303bf15e0484321af3906101f651a5df62e1da0c56825bc53493bbacbdf596d137e27fd97b6c628bac1d18116316522c0f356832bdd769f420308aa8da425e501748296d0620ffcd2d204a6dc5558914c11fd7a1524e4a74f9b204bbd20c161cc1478f443c050f4ba0a2a920b98de1a54ffce1c44fc2f468058f0bb1e886e03126f45b33810e77bf6f346451c74bd304ed8bab57935484589bc2b1a746cb687de37762f1e3b10d6cfd7444ea4341b5bbaa363926e42f063f44b8f46d6605499ae1f341a8c790ae5bd18455a40510f81640659cedde4b9a1fc6db20b8923908bfcf4ae5c13fc518f33bc48541a2a7d3d6fa89d14d5b18660c04253e8df7a62ce6fc0f4ad77bacf3ed63e1debcc332519106136f1b2641e6b830db62a33b2814ade061b05c363610e54b4c33600d8f2a0b2cf0b5403307e91398cbbbb0ce1f3b35c40cf626f9a795e2c058a9888a016c8c300275a53050c70428dc6d716a592ca1dce1d3197c52f6b275d568a2743e0a76310126832d79fdcfc43732d3899a62320175ad5adfe51baf995eab391023ce63c80e7455f778279bae1b6cfa16a1f3fd6064e80b6edb960c9308f82803b28c9816effd3c9f18b7513a3462ff3283e482b374f639c4d371942db68469fbb882df4fba4cb46057f569b75b81dd528d80365daf13cf487e52bc0d872243dbcfa67e2662311be95169f4e3457537866e44a36183036a169aacb02f0364d0d8cd0e140707d5209b2a1af7333465fb987f7b541f65c6cc0fbd606bfe4f0c894625694563e1066468c3eb3621726bd64d23457ecfd39f2a80d573eaaf792330c5f431e88122d3cfa94437d24ab67b6275def89af510353f2a7489517b3c411db28635f7153403306aad70c5e9df7334a7fd589a6a3f75a51a7d6b6f787483545bfa8792edc7b2e4dcfc0fe43266617f408469c97bec089db0698d88bb025bfbd78f55264612f849e271cccf941010f831a58402c52173aa717e8b37950c2a3b460296672b585a2ae788b6f3b7c8090b5607688c4cafd8127c8e4ee6cd27a674759cae2d3491fa85850f8b7a2a6e4bcafe4b7130eb79a9520098f2fb0b47a58bc5befda2d0dff0985f0a5cc7b772d813bba5ef07576a87164e367fc73f2a0bf6835de598f88ecd078a36b94b34b8a357e603cded2557ec4f70929061db31af874a1464d0e0dd987fc578a673d0a337ae4e741be8864ab69bbc3bdebd6cc40f6ca541d2da832b73a9e0a784ec4a2a9881589cf5f1eca7ced187f2d61810e0605850bb28a2e0ddfd6d5fda5f6daf84446297a9ed808180db8985a74dc9bda783c8404a40816f5aa2e46472bfb0910fcbbf951ef6c00918ad218dd9ab2987f761d0925d0ef773c46fe4b7a161cedfc9b45c3ffdeb1de189b73be8fb6b988d56f7a0995999f0142f5cff66e3f48f8ff9aa4fa5d55cae1b3b28982f24b60eb6b2a013d1dbfe24a8ae7d060303846c826d30750266845c421f1cfb6284aaacfb809aa1f8cb2569943fa79b0a62156ce334515f7c49b2b3d7e15e7119bb61de88efddfcdddef82aa1c03a6a406a5558f5a19366ac18a0592f71ca072505313fb73a1170cdf6a366ab5af2c52234c20f20d5aa161384bc13a4181564db10d98fe6cd0df70f7d0b656d4cf22a4452ac33ed23ab0850e97ec391945ea2d35aa57102d3f7c9a52caa07c69252cc294b2917a61a22745bba81d0ab2cf3ab8fe96f5f8b88743444dea132dbb071087860a659b2f898c983e26249acf4e28b490b33a068809d43ee74895d7151833327cf9292c66c06fc66cc9e95586aba56fae820ff58101e2f3e7ccd5822b040cfc1c056b6ef68f8969d3c99f5a30d315b6a034bc88297af5601d1871e16caf265742b3c6a642b19e9f6f6794db94031bf90772091158922f53eec44078767c2b91d0a3209f32579c1a614ee5ecd41649d5e2914539a1b5099d13ea62045953d898e3c3299aa755f8a7d7f66d786f96a0678ba89744e1c1dd8eaed3853524794b50e94d5e42ec7d0c081151729648645308b00e9c95cc05ec5d649abf41b0a3ee729dc47aaffba089a3a7e228db9872879a8ce2750c66da4ab6c4e7062ab5ba7d323a2a07152a76f579c7cde3de94b9ac3a40049a6657917455fb6aeb02b75a7624e0f9bd302f852f98cc5949dbc91698a64c9cc57ad6a9c381ed372f0c3a390c9fe743e3855f7ee27289155bad0ef53c288fee088346517abc31e122e4897ff8fa5ce878ef35d93a1ba0e1a4ce39959c887525c1c1b8067f157686a8f7ac89d55078ec7230c4f62dfe01f6ae148cf3c62e428bc058a2121b8ea479aee258882493a4d5a91b633c6ec15f907ca53b06a3f0d0e05ec37e3a1db600461ce81b5b93ed5f894aa7f2feb1ed509912cdb3efd473444055d0fb07e0b456c6e1ad1bd4abd6ac38b2d01087f8baeffcb7594332834ea8295fa7d4668f0abb95f0242cfcd5953fd3b11b643a4e25b9c5ec13387e99faf24235dfdb215433217508d107c4393a84ca6bc4bd49bb562b77298220918e52e2d88f2a3c5177795aae347a4177f6d4937cacbd5e5c4ecbcc7081181b4bd65e862d818047d7e16712db3b8ec117d6230e832c8c9f590223188ca37d7f49620c3cf0fd771bb277bb4d1ccbbaa4c604248234fcbe3ed2a3cfb01c6ff72184ebaca088ccdb479e3bc41f475386277fbef50af51554d77d319aee4583a3a914df0fcf1461522c583cc55feac3e639133f196a8dc98a2c3d0fb746fe35ff6c87415712b49f144b33dc595c82daef511a693bf77f20537d7856befc651a7fb168cd3712c1bd8fe7018d8bdb296acfbdbac10427ab9b04b9aff10661fb759f66015099dab02de9ea25d9e6899a4ee5f2521f7e2093571ee1228005f4ca42af51d8cac3d507aecc9683a7105e89f467c7d451255b92fc2fe5822b3c3b31ec1d8caa8efdcd124545938a1751f30e3f7307f946ddf0d57c2cc8b4506663fd1f4b86beb3d82364c1ad1c63f22610b425d698806564308e162117445c0cf4f5fdc901ec86268162e776d60b7625189fdbdf9dc92e5655c8ccf2a7370d6bdbf69292964890d64be44c88f7b630e96bbfcd852eb083fd79ca55c7f12a4d378a54b9bfb074d3e916112d5a58cf8d749b5cd74d4007f1aaf349dfe63a400b06a507852c241b1aa296162365e0ad043a47209ae80845e6e4fced64b7f52dd8a9163d896f4bf443d5b199766366013d062a794181fde28ac9331795bc2cc77a5e0b52de3c3c00c099e9d3cb373ef771c69c20aed9255385280c3e42eec53920469ab690c8c6d49158146388b401b3186fd462ac2abd820b57e5e9325d859030d70616b14d2bb991ba7b20883a93425828fc70ae6f8171160be59150b2491816f49d6e832bb6c66f5f513ddbfb0d59f6a045dc88288ca21bba554a7a134fa3&lt;/script&gt;
  &lt;div class=&quot;hbe hbe-content&quot;&gt;
    &lt;div class=&quot;hbe hbe-input hbe-input-default&quot;&gt;
      &lt;input class=&quot;hbe hbe-input-field hbe-input-field-default&quot; type=&quot;password&quot; id=&quot;hbePass&quot;&gt;
      &lt;label class=&quot;hbe hbe-input-label hbe-input-label-default&quot; for=&quot;hbePass&quot;&gt;
        &lt;span class=&quot;hbe hbe-input-label-content hbe-input-label-content-default&quot;&gt;Password Required.&lt;/span&gt;
      &lt;/label&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script data-pjax src=&quot;/lib/hbe.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/hbe.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Authenticaiton Failed." data-whm="Authentication Error.">  <script id="hbeData" type="hbeData" data-hmacdigest="a3bc817c3908ae67f704dabface47ef124dac94f6605c34ea7c8fd49515ab6c8">63a8672ddbb5b9158eb55097173249fad22b496a8876cf71b079381ad234cb95f094e21606daf1717aa32ac9bb46c3ec99a387f812d0a9e5a45bfd529c7b8ed5f86a0a6f45900b64a15b4130bd6ed52d8ef450f58e114d4fe18874ddcc125aa94adc7a4a8723b962b279a3d4fb7200835168fbe214ea68576e259f43343e2c7a777ab0f877cfb6fb4968bbe09478ebb4c8d82d533ea85f08a5195375f39c020dcf3cc513e539010453d4dc45f2948ba6de705108a00df9f7fc634cf34cf86bc985f7ae3ca2e1587e4469e2a695bfe5527047967d1184b513411930c48dbd3b183dbfe7eee873eff520957b049943bd7990c9027c77c010cf1c251f76064497d73aea9ab2a92c884d7e6a130b44100c9333493c6642eb39253827e8e7ee7be21ffa64373cba57238a83b953034350313408910b4f2679f2f08874a410bd240537e5df887e00d303bf15e0484321af3906101f651a5df62e1da0c56825bc53493bbacbdf596d137e27fd97b6c628bac1d18116316522c0f356832bdd769f420308aa8da425e501748296d0620ffcd2d204a6dc5558914c11fd7a1524e4a74f9b204bbd20c161cc1478f443c050f4ba0a2a920b98de1a54ffce1c44fc2f468058f0bb1e886e03126f45b33810e77bf6f346451c74bd304ed8bab57935484589bc2b1a746cb687de37762f1e3b10d6cfd7444ea4341b5bbaa363926e42f063f44b8f46d6605499ae1f341a8c790ae5bd18455a40510f81640659cedde4b9a1fc6db20b8923908bfcf4ae5c13fc518f33bc48541a2a7d3d6fa89d14d5b18660c04253e8df7a62ce6fc0f4ad77bacf3ed63e1debcc332519106136f1b2641e6b830db62a33b2814ade061b05c363610e54b4c33600d8f2a0b2cf0b5403307e91398cbbbb0ce1f3b35c40cf626f9a795e2c058a9888a016c8c300275a53050c70428dc6d716a592ca1dce1d3197c52f6b275d568a2743e0a76310126832d79fdcfc43732d3899a62320175ad5adfe51baf995eab391023ce63c80e7455f778279bae1b6cfa16a1f3fd6064e80b6edb960c9308f82803b28c9816effd3c9f18b7513a3462ff3283e482b374f639c4d371942db68469fbb882df4fba4cb46057f569b75b81dd528d80365daf13cf487e52bc0d872243dbcfa67e2662311be95169f4e3457537866e44a36183036a169aacb02f0364d0d8cd0e140707d5209b2a1af7333465fb987f7b541f65c6cc0fbd606bfe4f0c894625694563e1066468c3eb3621726bd64d23457ecfd39f2a80d573eaaf792330c5f431e88122d3cfa94437d24ab67b6275def89af510353f2a7489517b3c411db28635f7153403306aad70c5e9df7334a7fd589a6a3f75a51a7d6b6f787483545bfa8792edc7b2e4dcfc0fe43266617f408469c97bec089db0698d88bb025bfbd78f55264612f849e271cccf941010f831a58402c52173aa717e8b37950c2a3b460296672b585a2ae788b6f3b7c8090b5607688c4cafd8127c8e4ee6cd27a674759cae2d3491fa85850f8b7a2a6e4bcafe4b7130eb79a9520098f2fb0b47a58bc5befda2d0dff0985f0a5cc7b772d813bba5ef07576a87164e367fc73f2a0bf6835de598f88ecd078a36b94b34b8a357e603cded2557ec4f70929061db31af874a1464d0e0dd987fc578a673d0a337ae4e741be8864ab69bbc3bdebd6cc40f6ca541d2da832b73a9e0a784ec4a2a9881589cf5f1eca7ced187f2d61810e0605850bb28a2e0ddfd6d5fda5f6daf84446297a9ed808180db8985a74dc9bda783c8404a40816f5aa2e46472bfb0910fcbbf951ef6c00918ad218dd9ab2987f761d0925d0ef773c46fe4b7a161cedfc9b45c3ffdeb1de189b73be8fb6b988d56f7a0995999f0142f5cff66e3f48f8ff9aa4fa5d55cae1b3b28982f24b60eb6b2a013d1dbfe24a8ae7d060303846c826d30750266845c421f1cfb6284aaacfb809aa1f8cb2569943fa79b0a62156ce334515f7c49b2b3d7e15e7119bb61de88efddfcdddef82aa1c03a6a406a5558f5a19366ac18a0592f71ca072505313fb73a1170cdf6a366ab5af2c52234c20f20d5aa161384bc13a4181564db10d98fe6cd0df70f7d0b656d4cf22a4452ac33ed23ab0850e97ec391945ea2d35aa57102d3f7c9a52caa07c69252cc294b2917a61a22745bba81d0ab2cf3ab8fe96f5f8b88743444dea132dbb071087860a659b2f898c983e26249acf4e28b490b33a068809d43ee74895d7151833327cf9292c66c06fc66cc9e95586aba56fae820ff58101e2f3e7ccd5822b040cfc1c056b6ef68f8969d3c99f5a30d315b6a034bc88297af5601d1871e16caf265742b3c6a642b19e9f6f6794db94031bf90772091158922f53eec44078767c2b91d0a3209f32579c1a614ee5ecd41649d5e2914539a1b5099d13ea62045953d898e3c3299aa755f8a7d7f66d786f96a0678ba89744e1c1dd8eaed3853524794b50e94d5e42ec7d0c081151729648645308b00e9c95cc05ec5d649abf41b0a3ee729dc47aaffba089a3a7e228db9872879a8ce2750c66da4ab6c4e7062ab5ba7d323a2a07152a76f579c7cde3de94b9ac3a40049a6657917455fb6aeb02b75a7624e0f9bd302f852f98cc5949dbc91698a64c9cc57ad6a9c381ed372f0c3a390c9fe743e3855f7ee27289155bad0ef53c288fee088346517abc31e122e4897ff8fa5ce878ef35d93a1ba0e1a4ce39959c887525c1c1b8067f157686a8f7ac89d55078ec7230c4f62dfe01f6ae148cf3c62e428bc058a2121b8ea479aee258882493a4d5a91b633c6ec15f907ca53b06a3f0d0e05ec37e3a1db600461ce81b5b93ed5f894aa7f2feb1ed509912cdb3efd473444055d0fb07e0b456c6e1ad1bd4abd6ac38b2d01087f8baeffcb7594332834ea8295fa7d4668f0abb95f0242cfcd5953fd3b11b643a4e25b9c5ec13387e99faf24235dfdb215433217508d107c4393a84ca6bc4bd49bb562b77298220918e52e2d88f2a3c5177795aae347a4177f6d4937cacbd5e5c4ecbcc7081181b4bd65e862d818047d7e16712db3b8ec117d6230e832c8c9f590223188ca37d7f49620c3cf0fd771bb277bb4d1ccbbaa4c604248234fcbe3ed2a3cfb01c6ff72184ebaca088ccdb479e3bc41f475386277fbef50af51554d77d319aee4583a3a914df0fcf1461522c583cc55feac3e639133f196a8dc98a2c3d0fb746fe35ff6c87415712b49f144b33dc595c82daef511a693bf77f20537d7856befc651a7fb168cd3712c1bd8fe7018d8bdb296acfbdbac10427ab9b04b9aff10661fb759f66015099dab02de9ea25d9e6899a4ee5f2521f7e2093571ee1228005f4ca42af51d8cac3d507aecc9683a7105e89f467c7d451255b92fc2fe5822b3c3b31ec1d8caa8efdcd124545938a1751f30e3f7307f946ddf0d57c2cc8b4506663fd1f4b86beb3d82364c1ad1c63f22610b425d698806564308e162117445c0cf4f5fdc901ec86268162e776d60b7625189fdbdf9dc92e5655c8ccf2a7370d6bdbf69292964890d64be44c88f7b630e96bbfcd852eb083fd79ca55c7f12a4d378a54b9bfb074d3e916112d5a58cf8d749b5cd74d4007f1aaf349dfe63a400b06a507852c241b1aa296162365e0ad043a47209ae80845e6e4fced64b7f52dd8a9163d896f4bf443d5b199766366013d062a794181fde28ac9331795bc2cc77a5e0b52de3c3c00c099e9d3cb373ef771c69c20aed9255385280c3e42eec53920469ab690c8c6d49158146388b401b3186fd462ac2abd820b57e5e9325d859030d70616b14d2bb991ba7b20883a93425828fc70ae6f8171160be59150b2491816f49d6e832bb6c66f5f513ddbfb0d59f6a045dc88288ca21bba554a7a134fa3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password Required.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/essay/">随笔</category>
      
      
      <category domain="https://hejueyun.github.io/tags/essay/">essay</category>
      
      
      <comments>https://hejueyun.github.io/posts/2ba8f82c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-逻辑编程</title>
      <link>https://hejueyun.github.io/posts/faaea58c/</link>
      <guid>https://hejueyun.github.io/posts/faaea58c/</guid>
      <pubDate>Fri, 25 Feb 2022 22:58:44 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;Resolution was originally developed as a method for automatic theorem proving. Later, it was discovered that a restricted form of resolution can be used for programming a computation. This approach is called logic programming. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;program&lt;/strong&gt; is expressed as &lt;strong&gt;a set of clauses&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;query&lt;/strong&gt; is expressed as &lt;strong&gt;an additional clause&lt;/strong&gt; that can &lt;strong&gt;clash&lt;/strong&gt;冲突 with one or more of the program clauses. &lt;strong&gt;The query is assumed to be the negation of result of the program&lt;/strong&gt;. If a refutation succeeds, the &lt;strong&gt;query&lt;/strong&gt; is not a &lt;strong&gt;logical consequence&lt;/strong&gt; of the program, so its &lt;strong&gt;negation&lt;/strong&gt; must be a &lt;strong&gt;logical consequence&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解析最初是作为一种自动定理证明的方法而开发的。后来，人们发现，一种受限制的决议形式可以用于计算的编程。这种方法被称为逻辑编程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个程序被表达为一组子句&lt;/li&gt;
&lt;li&gt;一个查询被表达为一个额外的子句，可以与一个或多个程序子句发生冲突。查询被认为是对程序结果的否定。如果反驳成功，查询不是程序的逻辑结果，所以它的否定必须是一个逻辑结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;From-Formulas-in-Logic-to-Logic-Programming&quot;&gt;1. From Formulas in Logic to Logic Programming&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;program clauses&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按我的理解就是霍恩子句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;goal clause&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suppose now that we have a set of program clauses and we want to prove that some formula:&lt;ul&gt;
&lt;li&gt;$G_1\land{}…\land{}G_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;is a &lt;strong&gt;logical consequence&lt;/strong&gt; of the set. This can be done by taking the negation of the formula:&lt;ul&gt;
&lt;li&gt;$\lnot{}G_1\lor{}…\lor{}\lnot{}G_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;and refuting it by resolution with the program clauses&lt;blockquote&gt;
&lt;p&gt;The formula $¬ G_1∨⋯∨¬ G_n$ , called a &lt;strong&gt;goal clause&lt;/strong&gt;, consists entirely of negative literals, so it can only clash on the single positive literal of a program clause&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>Resolution was originally developed as a method for automatic theorem proving. Later, it was discovered that a restricted form of resolution can be used for programming a computation. This approach is called logic programming. </p><ul><li>A <strong>program</strong> is expressed as <strong>a set of clauses</strong> </li><li>A <strong>query</strong> is expressed as <strong>an additional clause</strong> that can <strong>clash</strong>冲突 with one or more of the program clauses. <strong>The query is assumed to be the negation of result of the program</strong>. If a refutation succeeds, the <strong>query</strong> is not a <strong>logical consequence</strong> of the program, so its <strong>negation</strong> must be a <strong>logical consequence</strong>.</li></ul><p>解析最初是作为一种自动定理证明的方法而开发的。后来，人们发现，一种受限制的决议形式可以用于计算的编程。这种方法被称为逻辑编程。</p><ul><li>一个程序被表达为一组子句</li><li>一个查询被表达为一个额外的子句，可以与一个或多个程序子句发生冲突。查询被认为是对程序结果的否定。如果反驳成功，查询不是程序的逻辑结果，所以它的否定必须是一个逻辑结果</li></ul></blockquote><h2 id="From-Formulas-in-Logic-to-Logic-Programming">1. From Formulas in Logic to Logic Programming</h2><p><strong>program clauses</strong></p><ul><li>按我的理解就是霍恩子句</li></ul><p><strong>goal clause</strong></p><ul><li>Suppose now that we have a set of program clauses and we want to prove that some formula:<ul><li>$G_1\land{}…\land{}G_n$</li></ul></li><li>is a <strong>logical consequence</strong> of the set. This can be done by taking the negation of the formula:<ul><li>$\lnot{}G_1\lor{}…\lor{}\lnot{}G_n$</li></ul></li><li>and refuting it by resolution with the program clauses<blockquote><p>The formula $¬ G_1∨⋯∨¬ G_n$ , called a <strong>goal clause</strong>, consists entirely of negative literals, so it can only clash on the single positive literal of a program clause</p></blockquote></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/faaea58c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-时序逻辑-语法与语义</title>
      <link>https://hejueyun.github.io/posts/150c47ae/</link>
      <guid>https://hejueyun.github.io/posts/150c47ae/</guid>
      <pubDate>Thu, 24 Feb 2022 13:30:06 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Temporal logic is a formal system for reasoning about time. Temporal logic has found extensive application in computer science, because the behavior of both hardware and software is a function of time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Temporal logics are related to formal systems called modal logics. Modal logics express the distinction between what is necessarily true and what is possibly true. For example, the statement ‘7 is a prime number’ is necessarily true because—given the definitions of the concepts in the statement—the statement is true always and everywhere. In contrast, the statement the head of state of this country is a king is possibly true, because its truth changes from place to place and from time to time. Temporal logic and modal logic are related because ‘always’ is similar to ‘necessarily’ and ‘eventually’ to ‘possibly’.&lt;/p&gt;
&lt;p&gt;时间逻辑与称为模态逻辑的形式系统有关。模态逻辑表达了什么是必然真实和什么是可能真实之间的区别。例如，”7是质数 “这个陈述必然是真实的，因为–考虑到陈述中概念的定义–这个陈述总是真实的，而且无处不在。相比之下，这个国家的国家元首是国王的说法可能是真的，因为它的真理在不同的地方和不同的时间会发生变化。时间逻辑和模态逻辑是相关的，因为 “总是 “类似于 “必然”，”最终 “类似于 “可能”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;时间逻辑与模态逻辑相似，只是&lt;strong&gt;状态&lt;/strong&gt;被认为是指定在某一特定时间点上的真实情况，而&lt;strong&gt;转换&lt;/strong&gt;则定义了时间的流逝&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;PTL&quot;&gt;2. PTL&lt;/h2&gt;&lt;h3 id=&quot;Syntax&quot;&gt;2.1. Syntax&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The syntax of propositional temporal logic (PTL) is defined like the syntax of propositional logic, &lt;strong&gt;except for the addition of two additional unary operators&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;□&lt;/code&gt; , read always&lt;/li&gt;
&lt;li&gt;&lt;code&gt;◊&lt;/code&gt; , read eventually&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$(¬ ◊p)∧(□¬ q)$&lt;ul&gt;
&lt;li&gt;the temporal operators and negation have higher precedence优先权 than the conjunction operator&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;semantic&quot;&gt;2.2. semantic&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Informally, □ is a universal operator meaning ‘&lt;strong&gt;for any time t in the future&lt;/strong&gt;’, while ◊ is an existential operator meaning ‘&lt;strong&gt;for some time t in the future&lt;/strong&gt;’&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;transition-diagram-状态转换图&quot;&gt;2.3. transition diagram 状态转换图&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Introduction">1. Introduction</h2><blockquote><p>Temporal logic is a formal system for reasoning about time. Temporal logic has found extensive application in computer science, because the behavior of both hardware and software is a function of time.</p></blockquote><blockquote><p>Temporal logics are related to formal systems called modal logics. Modal logics express the distinction between what is necessarily true and what is possibly true. For example, the statement ‘7 is a prime number’ is necessarily true because—given the definitions of the concepts in the statement—the statement is true always and everywhere. In contrast, the statement the head of state of this country is a king is possibly true, because its truth changes from place to place and from time to time. Temporal logic and modal logic are related because ‘always’ is similar to ‘necessarily’ and ‘eventually’ to ‘possibly’.</p><p>时间逻辑与称为模态逻辑的形式系统有关。模态逻辑表达了什么是必然真实和什么是可能真实之间的区别。例如，”7是质数 “这个陈述必然是真实的，因为–考虑到陈述中概念的定义–这个陈述总是真实的，而且无处不在。相比之下，这个国家的国家元首是国王的说法可能是真的，因为它的真理在不同的地方和不同的时间会发生变化。时间逻辑和模态逻辑是相关的，因为 “总是 “类似于 “必然”，”最终 “类似于 “可能”。</p></blockquote><ul><li>时间逻辑与模态逻辑相似，只是<strong>状态</strong>被认为是指定在某一特定时间点上的真实情况，而<strong>转换</strong>则定义了时间的流逝</li></ul><h2 id="PTL">2. PTL</h2><h3 id="Syntax">2.1. Syntax</h3><ul><li>The syntax of propositional temporal logic (PTL) is defined like the syntax of propositional logic, <strong>except for the addition of two additional unary operators</strong>:<ul><li><code>□</code> , read always</li><li><code>◊</code> , read eventually</li></ul></li><li>$(¬ ◊p)∧(□¬ q)$<ul><li>the temporal operators and negation have higher precedence优先权 than the conjunction operator</li></ul></li></ul><h3 id="semantic">2.2. semantic</h3><ul><li>Informally, □ is a universal operator meaning ‘<strong>for any time t in the future</strong>’, while ◊ is an existential operator meaning ‘<strong>for some time t in the future</strong>’</li></ul><h3 id="transition-diagram-状态转换图">2.3. transition diagram 状态转换图</h3><ul><li><p><strong>Interpretations</strong> of PTL formulas are based upon state transition diagrams. </p><ul><li>The intuitive直观 meaning is that each state represents a world and <strong>a formula can have different truth values in different worlds</strong>. The transitions represent changes from one world to another.</li></ul></li><li><p>A state transition diagram is a <strong>directed graph</strong>有向图.</p><ul><li>The nodes are states and the edges are transitions. 节点是状态，边是转换</li><li>Each state is labeled with a set of propositional literals such that clashing literals do not appear in any state. 每个状态都标有一个命题字面量的集合，这样冲突的字面量就不会出现在任何状态中</li></ul></li><li><p>A formula that contains a <strong>temporal operator</strong> is interpreted using the transitions between the states</p><ul><li>一个包含时间运算符的公式被解释为使用状态之间的转换</li></ul></li></ul><center><img loading="lazy" src="/posts/150c47ae/2.gif" width="550"></center><center><img loading="lazy" src="/posts/150c47ae/1.gif" width="550"></center><ul><li>If an atom is not shown in the label of a state, it is assumed to be assigned <strong>F</strong>.</li></ul><center><img loading="lazy" src="/posts/150c47ae/3.gif" width="550"></center><center><img loading="lazy" src="/posts/150c47ae/4.gif" width="550"></center><ul><li>$s:P \rightarrow { T,F }$</li><li>A <strong>binary relation</strong> can be considered to be <strong>a mapping from a state to a set of states</strong> $ρ:S→2^{S}$ , so the relational notation $(s_1,s_2)∈ρ$ will usually be written functionally as $s_2∈ρ(s_1)$<ul><li>注意$s_1$和$s_2$顺序关系</li></ul></li></ul><h3 id="truth-value">2.4. truth value</h3><center><img loading="lazy" src="/posts/150c47ae/5.png" width="550"></center><ul><li><p>注意最后一行得notation</p></li><li><p>$ρ(s_0)&#x3D;{s_1,s_2}$. Since $s_1⊨q$ and $s_2⊨q$, it follows that $s_0⊨□q$. By the semantics of $∨$, $s _0⊨□p∨□q$.</p></li><li><p>$s_3∈ρ(s_1)$, but $s_3 \not\models p$ and $s_3 \not\models q$ , so $s_1 \not\models □p$ and $s_1 \not\models □q$ . Therefore, $s_1 \not\models □p \lor □q$</p></li></ul><h3 id="Satisfiability-and-Validity">2.5. Satisfiability and Validity</h3><blockquote><p>The definition of semantic properties in PTL is more complex than it is in propositional or first-order logic, because an interpretation consists of <strong>both states and truth values</strong></p></blockquote><center><img loading="lazy" src="/posts/150c47ae/6.png" width="550"></center><blockquote><p>There are other formulas of PTL that are valid because of properties of temporal logic and not as instances of propositional validities. We will prove the validity of two formulas directly from the semantic definition. The first establishes a duality between □ and ◊, and the second is the distribution of □ over →, similar to the distribution of ∀ over →.</p></blockquote><h4 id="Duality">2.5.1. Duality</h4><ul><li>$⊨□p↔¬ ◊¬ p$</li></ul><h2 id="Models-of-Time">3. Models of Time</h2><blockquote><p><strong>In modal and temporal logics, different logics can be obtained by placing restrictions on the transition relation</strong></p><ul><li>在模态和时间逻辑中，通过对转换关系的限制可以得到不同的逻辑</li></ul></blockquote><ul><li>也就是说True value无关，逻辑是通过transition relation实现的</li></ul><h3 id="Reflexivity">3.1. Reflexivity</h3><ul><li>An interpretation $I&#x3D;(S,ρ)$ is reflexive iff $ρ$ is a reflexive <strong>relation</strong>: for all $s \in S$, $(s,s)∈ρ$, or $s∈ρ(s)$ in functional notation.<ul><li>放在状态图上就是个自己指向自己的圈</li></ul></li></ul><h3 id="Transitivity">3.2. Transitivity</h3><ul><li>An interpretation with a transitive relation is characterized by the formula $□A→□□A$ (or by the formula $◊◊A→◊A$)</li><li>In an interpretation that both is reflexive and transitive, $⊨□A↔□□A$ and $⊨◊A↔◊◊A$.</li></ul><h3 id="Linearity-线性关系">3.3. Linearity 线性关系</h3><ul><li>An interpretation $I&#x3D;(S,ρ)$  is linear if $ρ$ is a <strong>function</strong>, that is, for all $s \in S$, there is at most one $s^{‘} \in S$ such that $s^{‘} ∈ρ(s)$<ul><li>也就是最少没有后续状态，最多一个后续状态</li></ul></li></ul><blockquote><p>It might appear that a linear temporal logic would be limited to expressing properties of <strong>sequential programs</strong> and could not express properties of <strong>concurrent programs</strong>, where each state can have several possible successors depending on the interleaving of the statements of the processes. However, linear temporal logic is successful precisely in the context of concurrent programs because <strong>there is an implicit universal quantification in the definitions</strong></p><p>看起来线性时态逻辑仅限于表达<strong>顺序程序</strong>的属性，而不能表达<strong>并发程序</strong>的属性，因为在并发程序中，每个状态可以有几个可能的后继者，这取决于进程语句的交错情况。然而，线性时间逻辑恰恰在并发程序的背景下是成功的，因为在定义中有一个隐含的普遍量化</p></blockquote><p><strong>example</strong></p><ul><li>a temporal logic formula like $A&#x3D;□◊running$</li><li><strong>In any state, the execution will eventually reach a state in which the computation is running</strong></li><li>The program will be correct if this formula is <strong>true in every possible execution of the program obtained by interleaving the instructions of its processes</strong>. <ul><li>Each <code>interleaving</code>交错 can be considered as a single linear interpretation, so if we prove $\models{_I} A$ for an arbitrary linear interpretation $I$, then the correctness property holds for the program</li></ul></li></ul><h3 id="Discreteness-离散">3.4. Discreteness 离散</h3><blockquote><p>Although the passage of time is often considered to be continuous and expressible by real numbers, the execution of a program is considered to be <strong>a sequence of discrete steps, where each step consists of the execution of a single instruction of the CPU</strong>. Thus it makes sense to express the concept of the next instant in time. To express discrete steps in temporal logic, an additional operator is added</p><ul><li>虽然时间的流逝通常被认为是连续的，可以用实数来表达，但程序的执行被认为是一连串离散的步骤，其中每一步都包括执行CPU的一条指令。因此，<strong>用时间来表达下一个瞬间的概念是有意义的</strong>。为了在时间逻辑中表达离散的步骤，我们增加了一个额外的操作符</li></ul></blockquote><ul><li>The unary operator $\bigcirc$ is called <strong>next</strong></li><li>truth value<ul><li>f $A$ is $\bigcirc A^{‘}$ then $v(A)&#x3D;T$ iff $v(A^{‘})&#x3D;T$ for some $s^{‘}∈ρ(s)$</li><li><em>显然后面的状态想要是T那么前面的状态肯定得是T，但只需要<strong>some</strong>就行</em></li></ul></li><li>注意要$\bigcirc A$为T，只需A指向的state为T，和$A$本身T或F没有关系</li></ul><h4 id="self-dual">3.4.1. self-dual</h4><ul><li>$\bigcirc A \leftrightarrow \lnot \bigcirc \lnot A$</li></ul><blockquote><p>The operator $\bigcirc$ plays a crucial role in the theory of temporal logic and in algorithms for deciding properties like satisfiability, but it is rarely used to express properties of programs. In a concurrent program, not much can be said about what happens next since we don’t know which operation will be executed in the next step. Furthermore, we want a correctness statement to hold regardless of how the interleaving selects a next operation. Therefore, properties are almost invariably expressed in terms of always and eventually, not in terms of next.</p><ul><li>运算符 $\bigcirc◯$ 在时间逻辑理论和决定可满足性等属性的算法中起着关键作用，但它很少被用来表达<strong>程序的属性</strong>。在一个<strong>并发程序</strong>中，对于下一步会发生什么并没有太多可说的，<strong>因为我们不知道下一步会执行哪个操作。此外，我们希望正确性声明总能够成立——不管交错如何选择下一个操作。因此，</strong>属性几乎都是用always和eventually来表达，而不是用next来表达**。</li></ul></blockquote><h2 id="LTL">4. LTL</h2><ul><li><p>In the context of programs, the natural interpretations of temporal logic formulas are discrete, reflexive, transitive and linear. There is another restriction that simplifies the presentation: the transition function must be total so that each state has exactly one next state. An interpretation for a computation that terminates in state s is assumed to have a transition from s to s.</p></li><li><ul><li>在程序的背景下，时间逻辑公式的自然解释是<strong>离散的、反射的、传递的和线性的</strong>。还有一个简化表述的限制：转换函数必须是<strong>完全的</strong>，以便每个状态正好有一个下一个状态 <em>（即<strong>一一对应</strong>）</em> 。一个终止于状态s的计算的解释被假定为有一个从s到s的过渡</li></ul></li><li><p><strong>Linear temporal logic (LTL)</strong> is propositional temporal logic whose interpretations are limited to transitions which are discrete, reflexive, transitive, linear and total.</p></li><li><p>Since there is only one transition out of each state, it need not be explicitly represented, so interpretations in LTL are defined to be paths of states</p><ul><li>也就是原来的状态转换$ρ:S→2^{S}$被省略了</li></ul></li></ul><center><img loading="lazy" src="/posts/150c47ae/7.png" width="550"></center><ul><li><p>Let A be a formula in LTL. A is satisfiable iff there is an interpretation σ for A such that σ⊨A. A is valid iff for all interpretations σ for A, σ⊨A. Notation: ⊨A</p></li><li><p>A formula of the form $\bigcirc A$ or $\lnot \bigcirc A$ is a <strong>next formula</strong>. </p></li><li><p>A formula of the form $◊A$ or $¬ □A$ (‘eventually’ and ‘not always’) is a <strong>future formula</strong>.</p></li><li><p>any substitution instance of a formula in propositional logic is also an LTL formula</p></li><li><p>The method of semantic tableaux is a decision procedure for satisfiability in LTL</p></li></ul><h2 id="Binary-Temporal-Operators">5. Binary Temporal Operators</h2><ul><li>binary operator $\cap$ (read until)<ul><li>The output lines maintain their values until the set-line is asserted</li><li>If A is $A_1 \cap A_2$ then $$v_σ(A)&#x3D;T$ iff $v_{σ_{i}}(A_2)&#x3D;T$ for some $i≥0$ and for all $0≤k&lt;i$,  $v_{σ_k}(A_1)&#x3D;T$</li></ul></li></ul><p><strong>example</strong></p><ul><li>$p \cap q$ is not true in the following interpretation assuming that state $s$ is repeated indefinitely:</li></ul><center><img loading="lazy" src="/posts/150c47ae/8.gif" width="550"></center><ul><li>The Weak Until Operator<ul><li>Sometimes it is convenient to express precedence properties without actually requiring that something eventually occur. $W$ (read weak until) is the same as the operator except that <strong>it is not required that the second formula ever become true</strong></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/150c47ae/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-程序验证-并发程序</title>
      <link>https://hejueyun.github.io/posts/cf619a86/</link>
      <guid>https://hejueyun.github.io/posts/cf619a86/</guid>
      <pubDate>Wed, 23 Feb 2022 01:15:37 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;Verification is routinely used when developing computer hardware and concurrent programs. A sequential program can always be tested and retested, but the nondeterministic nature of hardware and concurrent programs limits the effectiveness of testing as a method to demonstrate that the system is correct. Slight variations in timing, perhaps caused by congestion on a network, mean that two executions of the same program might give different results. Even if a bug is found by testing and then fixed, we have no way of knowing if the next test runs correctly because we fixed the bug or because the execution followed a different scenario, one in which the bug cannot occur.&lt;/p&gt;
&lt;p&gt;在开发计算机硬件和并发程序时，经常会用到验证。一个顺序程序总是可以被测试和重新测试，但硬件和并发程序的非确定性限制了测试作为证明系统正确的方法的有效性。&lt;strong&gt;时间上的微小变化，也许是由网络上的拥堵造成的，意味着同一个程序的两次执行可能会得到不同的结果。即使通过测试发现了一个错误，然后进行了修复，我们也没有办法知道下一次测试的正确运行是因为我们修复了这个错误，还是因为执行了一个不同的场景，在这个场景中，这个错误不会发生&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;顺序程序的验证貌似没有用到时态逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Concurrent-Program-并发程序&quot;&gt;1. Concurrent Program 并发程序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;concurrent program&lt;/strong&gt; is a set of &lt;strong&gt;sequential programs&lt;/strong&gt; together with a set of &lt;strong&gt;global variables&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A concurrent program is a set of &lt;code&gt;processes&lt;/code&gt; ${ p_1,p_2,…,p_n }$, where each &lt;strong&gt;process&lt;/strong&gt; is a &lt;strong&gt;sequential program&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Processes&lt;/strong&gt; are also known as &lt;strong&gt;threads&lt;/strong&gt;; in some contexts, the two terms have different meanings but the difference is not relevant here&lt;ul&gt;
&lt;li&gt;进程与线程在此处无需区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The variables declared in each process are its &lt;code&gt;local variables&lt;/code&gt;; a local variable can be read and written only by the process where it is declared.&lt;/li&gt;
&lt;li&gt;There may be &lt;code&gt;global variables&lt;/code&gt; that can be read and written by all of the processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;state-状态&quot;&gt;1.1. state 状态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The state of a concurrent programs consists of &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;the values of its variables&lt;/strong&gt; (both local and global),&lt;/li&gt;
&lt;li&gt;together with the &lt;strong&gt;location counters&lt;/strong&gt; of its processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cf619a86/2.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cf619a86/3.gif&quot; width=&quot;350&quot;&gt;&lt;/center&gt;

&lt;blockquote&gt;
&lt;p&gt;There are $5×3×3&amp;#x3D;45$ different states, because the variable n can have the values $0, 1, 2, 3, 4$ and there are &lt;strong&gt;three&lt;/strong&gt; labels for &lt;strong&gt;each&lt;/strong&gt; process. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These seems like quite a large number of states for such a simple program, but many of the states (for example, (0,end,end)) will never occur in any computation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>Verification is routinely used when developing computer hardware and concurrent programs. A sequential program can always be tested and retested, but the nondeterministic nature of hardware and concurrent programs limits the effectiveness of testing as a method to demonstrate that the system is correct. Slight variations in timing, perhaps caused by congestion on a network, mean that two executions of the same program might give different results. Even if a bug is found by testing and then fixed, we have no way of knowing if the next test runs correctly because we fixed the bug or because the execution followed a different scenario, one in which the bug cannot occur.</p><p>在开发计算机硬件和并发程序时，经常会用到验证。一个顺序程序总是可以被测试和重新测试，但硬件和并发程序的非确定性限制了测试作为证明系统正确的方法的有效性。<strong>时间上的微小变化，也许是由网络上的拥堵造成的，意味着同一个程序的两次执行可能会得到不同的结果。即使通过测试发现了一个错误，然后进行了修复，我们也没有办法知道下一次测试的正确运行是因为我们修复了这个错误，还是因为执行了一个不同的场景，在这个场景中，这个错误不会发生</strong></p></blockquote><ul><li>顺序程序的验证貌似没有用到时态逻辑</li></ul><h2 id="Concurrent-Program-并发程序">1. Concurrent Program 并发程序</h2><ul><li>A <strong>concurrent program</strong> is a set of <strong>sequential programs</strong> together with a set of <strong>global variables</strong></li><li>A concurrent program is a set of <code>processes</code> ${ p_1,p_2,…,p_n }$, where each <strong>process</strong> is a <strong>sequential program</strong><ul><li><strong>Processes</strong> are also known as <strong>threads</strong>; in some contexts, the two terms have different meanings but the difference is not relevant here<ul><li>进程与线程在此处无需区别</li></ul></li></ul></li><li>The variables declared in each process are its <code>local variables</code>; a local variable can be read and written only by the process where it is declared.</li><li>There may be <code>global variables</code> that can be read and written by all of the processes.</li></ul><h3 id="state-状态">1.1. state 状态</h3><ul><li>The state of a concurrent programs consists of <ul><li><strong>the values of its variables</strong> (both local and global),</li><li>together with the <strong>location counters</strong> of its processes.</li></ul></li></ul><center><img loading="lazy" src="/posts/cf619a86/2.png" width="550"></center><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/cf619a86/3.gif" width="350"></center><blockquote><p>There are $5×3×3&#x3D;45$ different states, because the variable n can have the values $0, 1, 2, 3, 4$ and there are <strong>three</strong> labels for <strong>each</strong> process. </p><ul><li>These seems like quite a large number of states for such a simple program, but many of the states (for example, (0,end,end)) will never occur in any computation.</li></ul></blockquote><ul><li>possible computations:</li></ul><center><img loading="lazy" src="/posts/cf619a86/4.gif" width="350"></center><h3 id="Interleaving-交错">1.2. Interleaving 交错</h3><ul><li>A computation of a concurrent program is obtained by asynchronous interleaving of atomic instructions<ul><li>并发程序的计算是通过原子指令的异步交错得到的</li></ul></li><li>Each statement is executed to completion before the execution of another statement (from the same process or another process) is started<ul><li>these statements are <strong>atomic operations</strong></li></ul></li></ul><center><img loading="lazy" src="/posts/cf619a86/5.png" width="550"></center><center><img loading="lazy" src="/posts/cf619a86/6.png" width="550"></center><h2 id="Formalization-of-Correctness">2. Formalization of Correctness</h2><ul><li><strong>Correctness properties</strong> of concurrent programs can be expressed in <strong>linear temporal logic</strong>. </li><li>There are two types of properties: <ul><li>safety properties that require that <strong>something bad never happens</strong> </li><li>liveness活泼 properties that require that <strong>something good eventually happen</strong>.</li></ul></li></ul><hr><ul><li>Each process consists of a <code>critical section</code> and a <code>non-critical section</code>. <ul><li>A process may stay indefinitely in its non-critical section, or—at any time—it may request to enter its critical section. </li><li>A process that has entered its critical section will eventually leave it</li><li><strong>Mutual exclusion</strong>: It is forbidden for the two processes to be in their critical sections simultaneously.</li><li><strong>Liveness</strong>: If a process attempts to enter its critical section, it will eventually succeed</li></ul></li></ul><h3 id="Peterson’s-algorithm-彼得森算法">2.1. Peterson’s algorithm 彼得森算法</h3><center><img loading="lazy" src="/posts/cf619a86/8.png" width="500"></center><center><img loading="lazy" src="/posts/cf619a86/13.gif" width="500"></center><ul><li>The statement: <code>wait until (!wantq or turn == 2)</code> is a more intuitive way of writing:<ul><li><code>while (!(!wantq or turn == 2)) /* do nothing */</code></li></ul></li><li>The variables <code>wantp</code> and <code>wantq</code> are set to <strong>true</strong> by the processes to indicate that they are trying to enter their critical sections and reset to <strong>false</strong> when they leave their critical sections. </li><li>A trying-process <strong>waits</strong> until the other process is neither trying to enter its critical section nor is it in its critical section (<code>!wantq</code> or <code>!wantp</code>). Since the algorithm is <strong>symmetric</strong>, the variable turn is used to break ties when both processes are trying to enter their critical sections. </li><li>A tie is broken in favor of the first process which set turn. Suppose that process p set turn to 1 and then process q set turn to 2. The expression <code>turn==2</code> will be true and allow process p to enter its critical section.</li></ul><hr><ul><li>The following two LTL formulas express the correctness of Peterson’s algorithm for the critical section problem:</li></ul><center><img loading="lazy" src="/posts/cf619a86/7.gif" width="350"></center><ul><li>cs &#x3D; critical section</li></ul><blockquote><ul><li>Mutual exclusion forbids (always false) a computation from including a state where both processes are in their critical section, </li><li>while liveness requires that (always) if a computation includes a state where a process is trying to enter its critical section then (eventually) the computation will include a state where the process is in its critical section.</li></ul></blockquote><h3 id="progress-axioms">2.2. progress axioms</h3><center><img loading="lazy" src="/posts/cf619a86/9.gif" width="350"></center><h3 id="Invariants-不变量">2.3. Invariants 不变量</h3><ul><li>$r$ is invariant, meaning that $r$ is true initially and remains true in any interpretation</li><li>deduction rule:</li></ul><center><img loading="lazy" src="/posts/cf619a86/14.png" width="350"></center><h2 id="Programs-as-Automata-–-model-checking">3. Programs as Automata – model checking</h2><ul><li>There is a different approach to the verification of the correctness of a program: <strong>generate all possible computations</strong>生成所有可能的计算 and check that the correctness property holds for each of them. Of course, <strong>this is possible only if there are a finite number of states so that each computation is finite or finitely presented</strong>. 所基于的假设<ul><li>For the program for integer square root整数平方根的程序, we could prove its correctness this way for any <strong>specific</strong> value of a, but we could not prove it in <strong>general</strong> for all values of a. </li><li>However, many concurrent algorithms have a finite number of states</li></ul></li><li>This approach to verification is called <code>model checking</code>. <ul><li>A concurrent system is represented by an abstract finite model that ignores details of the computation</li><li>a <strong>correctness property</strong> is expressed as a <strong>formula</strong> (usually in temporal logic) and we wish to show that the <strong>program</strong> is a <strong>model解</strong> of the <strong>formula</strong>, that is, an interpretation in which the formula is true</li></ul></li></ul><h3 id="Modeling-Concurrent-Programs-as-Automata">3.1. Modeling Concurrent Programs as Automata</h3><ul><li><p>Concurrent programs can be modeled as <strong>finite automata</strong>有限自动机</p><ul><li>Each <strong>value of the location counter</strong> is a <strong>state</strong> of one of the automata</li><li>while each <strong>transition</strong> is labeled with the <strong>Boolean condition</strong> that enables it to be taken or with the <strong>assignment statements</strong> that change the values of the variables.</li></ul></li><li><p>相比之下，顺序程序的correctness是通过 <strong>inductive expressions</strong> ${ p }S{ q }$来表示的</p></li><li><p>The abbreviated简略的 version of Peterson’s algorithm</p></li></ul><center><img loading="lazy" src="/posts/cf619a86/10.gif" width="350"></center><ul><li>The <strong>automata</strong> for the individual processes do not define the entire concurrent program. We must combine these automata into one <strong>automaton</strong>(automata的复数形式)</li><li>The states are defined as the Cartesian product of the states of the automata for the individual processes.</li></ul><center><img loading="lazy" src="/posts/cf619a86/11.png" width="550"></center><h3 id="The-State-Space-状态空间">3.2. The State Space 状态空间</h3><blockquote><p>The <strong>reachable states</strong> of a concurrent program are the states that can actually occur in a computation. The state space of the program is a directed graph: </p><ul><li>each reachable state is a <strong>node</strong> </li><li>and there is an <strong>edge</strong> from state $s_1$ to state $s_2$ if some transition of the program which is enabled in $s_1$ moves the state of the computation to $s_2$.</li></ul><p> </p></blockquote><ul><li>State space for Peterson’s algorithm</li></ul><center><img loading="lazy" src="/posts/cf619a86/12.gif" width="450"></center><h2 id="Model-Checking-of-Invariance-Properties">4. Model Checking of Invariance Properties</h2><blockquote><p>We now consider the second meaning of the term model: Is the state space a <strong>model</strong> of a correctness property? Consider the <strong>correctness property</strong> for mutual exclusion in Peterson’s algorithm $A&#x3D;□¬ (csp∧csq)$ . Since the state spacerepresents all the reachable states and all the transitions between them, any interpretation for $A$ must be an infinite path in this directed graph. A quick inspection of the graph shows that all of the ten reachable states satisfy the formula $¬ (csp∧csq)$; therefore, for any interpretation (that is, for any path constructed from these states), $□¬ (csp∧csq)$ is true.</p><hr><p>Once we have written the program and the correctness property, there are <strong>algorithms</strong> to perform the rest of the proof: </p><ul><li>compile the program to a set of automata</li><li>construct the product automaton</li><li>generate the state space </li><li>check the truth of the formula expressing the correctness property at each state.</li></ul></blockquote><h3 id="Algorithms-for-Searching-the-State-Space">4.1. Algorithms for Searching the State Space</h3><ul><li>breadth-first search (BFS)</li><li>depth-first search (DFS)</li></ul><h2 id="Model-Checking-of-Liveness-Properties">5. Model Checking of Liveness Properties</h2><ul><li>Using negation, we have: the correctness property does not hold iff there exists a computation is which ¬ A is true, where: <ul><li>$\lnot A \equiv \lnot □ \lnot (csp \land csq) \equiv ◊ (csp \land csq)$</li></ul></li><li>The model checking algorithm ‘succeeds’ if it finds a computation where ¬ A is true; it succeeds by finding a <code>counterexample</code> proving that the program is incorrect.</li></ul><center><img loading="lazy" src="/posts/cf619a86/15.gif" width="450"></center><ul><li>The states on the stack of a depth first search form a <code>path</code>. If the construction ever tries to generate a state that already exists higher up on the stack, the transition to this node defines a finitely-presented infinite computation like the ones shown above.</li><li>we could generate the entire state space and then check each distinct path to see if it model, but it is more efficient if the checking can be done on-the-fly即时完成 as we did for safety properties. <strong>The key is to transform an LTL formula into an automaton whose computations can be generated at the same time as those of the program.</strong></li></ul><h2 id="Expressing-an-LTL-Formula-as-an-Automaton">6. Expressing an LTL Formula as an Automaton</h2><ul><li>An LTL formula can be algorithmically transformed into an automaton that accepts an input if and only if <strong>the input represents a computation that satisfies the LTL formula</strong>.</li><li>The automaton is a non-deterministic Büchi automaton (NBA), which is the same as a non-deterministic finite automaton (NFA) <strong>except that it reads an infinite string</strong> as its input and its definition of acceptance is changed accordingly</li><li>在计算理论中，<strong>非确定有限状态自动机</strong>或<strong>非确定有限自动机</strong>是对每个状态和输入符号对可以有多个可能的下一个状态的有限状态自动机。这区别于确定有限状态自动机，它的下一个可能状态是唯一确定的</li></ul><center><img loading="lazy" src="/posts/cf619a86/16.gif" width="450"></center><ul><li>the negation of the liveness formula <ul><li>$\lnot □A ≡ \not □(waitp→◊csp) ≡ ◊(waitp \land □ \not csp)$</li></ul></li><li>The intuitive meaning of the formula is that the computation can do anything (expressed as true), but it may nondeterministically decide to enter a state where waitp is true and csp is and remains false from then on. Such a computation falsifies the liveness property.</li><li>In state $s_1$, if csp ever becomes true, there is no transition from the state; as with NFA, <strong>an automaton that cannot continue with its computation is considered to have rejected its input</strong></li></ul><h2 id="Model-Checking-Using-the-Synchronous-Automaton">7. Model Checking Using the Synchronous Automaton</h2><blockquote><p>On-the-fly model checking for an invariance property simply evaluates the correctness property as each new state is generated</p></blockquote><center><img loading="lazy" src="/posts/cf619a86/17.gif" width="450"></center><blockquote><p>When checking a <strong>liveness property</strong> (or a <strong>safety property</strong> expressed in LTL as $□A$), every step of the program automaton—the asynchronous product automaton of the processes—is immediately followed by a step of the NBA corresponding to the LTL formula expressing the negation of the correctness property. The product of the asynchronous automaton and the NBA is called a <strong>synchronous automaton</strong> since the steps of the two automata are synchronized. </p></blockquote><center><img loading="lazy" src="/posts/cf619a86/18.gif" width="450"></center><h3 id="Model-checking-the-liveness-of-Peterson’s-algorithm">7.1. Model checking the liveness of Peterson’s algorithm</h3><center><img loading="lazy" src="/posts/cf619a86/19.gif" width="450"></center><ul><li>Starting from the initial state 1, state 2 is reached and $◊(waitp∧□¬ csp)$ will be true, provided that we can find a reachable MSCC（强连通分量，Strongly connected component）where $¬ csp$ holds in all its states.</li><li>A nested DFS is initiated. Clearly, states 4 and 8 cannot be part of the MSCC since ¬ csp is false in those states</li><li>the computation can continue: $1,2,5,5,…$ and the state 5 with its self-loop forms an MSCC such that $¬ csp$ is false in all its states<ul><li><strong>rejected</strong></li></ul></li><li>Continuing the DFS, we encounter two more states 6 and 9 where waitp is true. We leave it as an exercise to show that the nested DFS will find computations in which ¬ csp holds in all states, but that these computations are also unfair. Therefore, the liveness holds for Peterson’s algorithm</li></ul><h3 id="Fair">7.2. Fair</h3><ul><li>A computation is (weakly) fair if a transition that is always <strong>enabled</strong> is eventually executed in the computation.</li><li>The statement wait <code>until (!wantq or turn == 2)</code> is always <strong>enabled</strong> because <code>turn=2</code>, but it is never taken. Therefore, we reject this counterexample</li></ul><h2 id="Branching-Time-Temporal-Logic">8. Branching-Time Temporal Logic</h2><p>. </p><h2 id="Symbolic-Model-Checking-符号模型检验">9. Symbolic Model Checking 符号模型检验</h2><ul><li>In symbolic model checking, the <strong>states</strong> and <strong>transitions</strong> are not represented explicitly; instead, they are encoded as formulas in <strong>propositional logic</strong><ul><li>在符号模型检查中，状态和转换没有明确表示；相反，它们被编码为命题逻辑的公式</li></ul></li></ul><p><strong>exampl</strong></p><ul><li><p>A state in the state space of Peterson’s algorithm can be represented as a propositional formula using five atomic propositions. </p><ul><li>There are <strong>three</strong> locations in each process, so <strong>two</strong> bits for each process can represent these values ${p_0,p_1,q_0,q_1}$</li></ul><center><img loading="lazy" src="/posts/cf619a86/20.png" width="450"></center><ul><li>The variable turn can take <strong>two</strong> values so <strong>one</strong> bit is sufficient. The atomic proposition t will encode turn: <strong>true</strong> for turn&#x3D;1 and <strong>false</strong> for turn&#x3D;2</li></ul></li><li><p>The initial state of the state space is encoded by the formula:</p><ul><li>$p_0 \land p_1 \land q_0 \land q_1 \land t$</li></ul></li><li><p>To encode the transitions, we need another set of atomic propositions: </p><ul><li>the original set will encode the state <strong>before</strong> the transition </li><li>and the new set (denoted by primes) will encode the <strong>state</strong> after the transition</li></ul></li><li><p>The encoding of the transition from $s_5&#x3D;(waitp,waitq,2)$ to $s_8$ is given by the formula:</p><center><img loading="lazy" src="/posts/cf619a86/21.gif" width="350"></center></li><li><p>There are two ways of proceeding from here</p><ul><li>One is to encode the formulas using <strong>BDDs</strong><ul><li>The algorithms on BDDs can be used to compute the formulas corresponding to new sets of states: union, predecessor, and so on</li></ul></li><li>The other approach to <strong>symbolic model checking</strong> is called <strong>bounded model checking</strong>. <ul><li>Recall that a formula in temporal logic has the finite model property: if a formula is satisfiable then it is satisfied in a finitely-presented model. For an LTL formula, we showed that a model consists of MSCCs that are reachable from the initial state. In fact, by unwinding解开 the MSCCs, we can always find a model that consists of a single cycle reachable from the initial state </li><li>In bounded model checking, a maximum size $k$ for the model is guessed. The <strong>behavior of the program</strong> and the <strong>negation of a correctness property</strong> are expressed as a <strong>propositional formula</strong> obtained by encoding each state that can appear at distance $i$ from the initial state $0≤i≤k$. This formula is the input to a <strong>SAT solver</strong>; if a satisfying interpretation is found, then there is a computation that satisfies the negation of the correctness property is true and the program is not correct.</li></ul></li></ul></li></ul><h3 id="BDD">9.1. BDD</h3><p>( 二元决策图 Binary decision diagram)</p><blockquote><p>A binary decision diagram (BDD) is a data structure for representing the semantics of a formula in propositional logic. A formula is represented by a directed graph and an algorithm is used to reduce the graph.</p></blockquote><hr><blockquote><p>A Boolean function can be represented as a rooted, directed, acyclic graph, which consists of several (<strong>decision</strong>) nodes and two <strong>terminal</strong> nodes. The two terminal nodes are labeled 0 (FALSE) and 1 (TRUE). Each (decision) node ${\displaystyle u}$ is labeled by a Boolean variable ${\displaystyle x_{i}}$ and has two child nodes called <strong>low child</strong> and <strong>high child</strong>. The edge from node ${\displaystyle u}$ to a low (or high) child represents an assignment of the value FALSE (or TRUE, respectively) to variable ${\displaystyle x_{i}}$. Such a BDD is called ‘ordered’ if different variables appear in the same order on all paths from the root. A BDD is said to be ‘<strong>reduced</strong>‘ if the following two rules have been applied to its graph:</p><ul><li>Merge any isomorphic subgraphs.</li><li>Eliminate any node whose two children are isomorphic.</li></ul></blockquote><ul><li>In the figures below, <strong>dotted</strong> lines represent edges to a <strong>low</strong> child, while <strong>solid</strong> lines represent edges to a <strong>high</strong> child.<ul><li>For function ${\displaystyle f(x1,x2,x3)}$, to find ${\displaystyle f(0,1,1)}$, begin at x1, traverse down the dotted line to x2 (since x1 has an assignment to 0), then down two solid lines (since x2 and x3 each have an assignment to one). This leads to the terminal 1, which is the value of ${\displaystyle f(0,1,1)}$</li></ul></li><li>The <strong>binary decision tree</strong> of the left figure can be transformed into a <strong>binary decision diagram</strong> by maximally reducing it according to the two reduction rules. The resulting BDD is shown in the right figure.</li></ul><center><img loading="lazy" src="/posts/cf619a86/22.png" width="550"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/cf619a86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-程序验证-顺序程序</title>
      <link>https://hejueyun.github.io/posts/ab706956/</link>
      <guid>https://hejueyun.github.io/posts/ab706956/</guid>
      <pubDate>Wed, 23 Feb 2022 01:15:14 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Program&quot;&gt;1. Program&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;computer program&lt;/strong&gt; is not very different from a logical formula. It consists of a sequence of &lt;strong&gt;symbols&lt;/strong&gt; constructed according to &lt;strong&gt;formal syntactical rules&lt;/strong&gt; and it has a meaning which is assigned by an &lt;strong&gt;interpretation&lt;/strong&gt; of the elements of the language. In programming, the symbols are called &lt;strong&gt;statements or commands&lt;/strong&gt; and the intended interpretation is the &lt;strong&gt;execution&lt;/strong&gt; of the program on a computer. The syntax of programming languages is specified using formal systems such as BNF, but the semantics is usually informally specified.&lt;/p&gt;
&lt;p&gt;一个计算机程序与一个逻辑公式没有什么不同。它由一连串的符号组成，这些符号是根据正式的句法规则构建的，它有一个意义，这个意义是通过对语言元素的解释而赋予的。在编程中，这些符号被称为语句或命令，预期的解释是程序在计算机上的执行。&lt;strong&gt;编程语言的语法是用BNF这样的形式化系统指定的，但语义通常是非正式地指定的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;考虑一门语言的设计&quot;&gt;1.1. 考虑一门语言的设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A program is a &lt;strong&gt;statement&lt;/strong&gt; S, where statements are defined recursively using the concepts of variables and expressions&lt;ul&gt;
&lt;li&gt;程序本身就是一个抽象的大statement&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/ab706956/6.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;statement&lt;/strong&gt; in a programming language can be considered to be a function that transforms the state of a computation&lt;ul&gt;
&lt;li&gt;编程语言可以被视作状态转换函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Let $S$ be a &lt;strong&gt;program&lt;/strong&gt; with $n$ &lt;strong&gt;variables&lt;/strong&gt; $(x1,…,xn)$. A &lt;strong&gt;state&lt;/strong&gt; $s$ of $S$ consists of an $n+1$-tuple of values $(lc,x_1,…,x_n )$, where $lc$ is the value of the &lt;strong&gt;location counter&lt;/strong&gt;(sometimes called the &lt;strong&gt;instruction pointer&lt;/strong&gt;，存储下一个指令的地址)  and $x_i$ is the value of the variable $xi$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;we aim to verify the program by proving: if the input to the program satisfies the precondition, then the output of the program will satisfy the postcondition&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the variables (x,y) have the values (8,7) in a state, then the result of executing the statement x &amp;#x3D; 2*y+1 is the state in which (x,y)&amp;#x3D;(15,7) and the location counter is incremented&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Program">1. Program</h2><blockquote><p>A <strong>computer program</strong> is not very different from a logical formula. It consists of a sequence of <strong>symbols</strong> constructed according to <strong>formal syntactical rules</strong> and it has a meaning which is assigned by an <strong>interpretation</strong> of the elements of the language. In programming, the symbols are called <strong>statements or commands</strong> and the intended interpretation is the <strong>execution</strong> of the program on a computer. The syntax of programming languages is specified using formal systems such as BNF, but the semantics is usually informally specified.</p><p>一个计算机程序与一个逻辑公式没有什么不同。它由一连串的符号组成，这些符号是根据正式的句法规则构建的，它有一个意义，这个意义是通过对语言元素的解释而赋予的。在编程中，这些符号被称为语句或命令，预期的解释是程序在计算机上的执行。<strong>编程语言的语法是用BNF这样的形式化系统指定的，但语义通常是非正式地指定的</strong></p></blockquote><h3 id="考虑一门语言的设计">1.1. 考虑一门语言的设计</h3><ul><li>A program is a <strong>statement</strong> S, where statements are defined recursively using the concepts of variables and expressions<ul><li>程序本身就是一个抽象的大statement</li></ul></li></ul><center><img loading="lazy" src="/posts/ab706956/6.gif" width="550"></center><ul><li>A <strong>statement</strong> in a programming language can be considered to be a function that transforms the state of a computation<ul><li>编程语言可以被视作状态转换函数</li></ul></li></ul><blockquote><p>Let $S$ be a <strong>program</strong> with $n$ <strong>variables</strong> $(x1,…,xn)$. A <strong>state</strong> $s$ of $S$ consists of an $n+1$-tuple of values $(lc,x_1,…,x_n )$, where $lc$ is the value of the <strong>location counter</strong>(sometimes called the <strong>instruction pointer</strong>，存储下一个指令的地址)  and $x_i$ is the value of the variable $xi$.</p></blockquote><ul><li><strong>we aim to verify the program by proving: if the input to the program satisfies the precondition, then the output of the program will satisfy the postcondition</strong></li></ul><p><strong>example</strong></p><ul><li>If the variables (x,y) have the values (8,7) in a state, then the result of executing the statement x &#x3D; 2*y+1 is the state in which (x,y)&#x3D;(15,7) and the location counter is incremented</li></ul><h2 id="Correctness-Formulas">2. Correctness Formulas</h2><ul><li><p>A <strong>correctness formula</strong> is a triple ${ p } S { q }$ , where $S$ is a program, and $p$ and $q$ are formulas called the precondition and postcondition, respectively. S is <strong>partially correct</strong> with respect to p and q，$⊧ { p } S { q }$,iff</p><ul><li>If $S$ is started in a state where $p$ is true and if the computation of $S$ terminates, then it terminates in a state where $q$ is true</li></ul></li><li><p>correctness formulas also call <strong>inductive expressions</strong></p></li></ul><center><img loading="lazy" src="/posts/ab706956/1.gif" width="550"></center><blockquote><p>只要 P 在 C 执行前的状态下成立，则在执行之后 Q 也成立。注意如果 C 不终止，也就没有”之后”了，所以 Q 在根本上可以是任何语句。实际上，你可以选择 Q 为假来表达 C 不终止。事实上，这种情形叫做 “部分正确（partial correctness）”。如果 C 终止并且在终止时 Q 是真，则表达式被称作 “全部正确性（total correctness）”。终止必须被单独证明。</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/ab706956/7.png" width="550"></center><h3 id="characteristic-predicate">2.1. characteristic predicate</h3><blockquote><p>Let U be the set of all n-tuples of values over some domain(s), and let U′⊆U be a <strong>relation</strong> over U. The n-ary predicat $P_{U′}$ is the <strong>characteristic predicate</strong>特征谓词 of U′ if it is interpreted over the domain U by the relation U′. That is, $v(P_{U′}($x_1$,…,$x_n$))&#x3D;T iff ($x_1$,…,$x_n$)∈U′$.</p></blockquote><ul><li>We can write {(x 1,…,x n )∣(x 1,…,x n )∈U′} as {(x 1,…,x n )∣ $P_{U′}$ }</li><li>即：如果变量都在domain上，则为T</li></ul><h3 id="semantics-of-programming-language">2.2. semantics of programming language</h3><ul><li>编程语言的<strong>语义</strong>是通过指定语言中的每个语句如何将一种状态转化为另一种状态而给出的</li></ul><p><strong>example</strong></p><ul><li>Let S be the statement x &#x3D; 2*y+1. <ul><li>If started in an arbitrary state (x,y), the statement terminates in the state (x′,y′) where x′&#x3D;2y′+1. </li><li>Another way of expressing this is to say that S transforms the set of states {(x,y)∣true} into the set {(x,y)∣x&#x3D;2y+1}.</li><li>The statement S also transforms the set of states {(x,y)∣y≤3} into the set {(x,y)∣(x≤7)∧(y≤3)}, because if y≤3 then 2y+1≤7</li></ul></li></ul><h2 id="Deductive-System-HL-霍尔逻辑">3. Deductive System HL 霍尔逻辑</h2><ul><li>Instead, we will simply take all true formulas in the domain as axioms. For example, (x≥y)→(x+1≥y+1) is true in arithmetic and will be used as an axiom. This is reasonable since we wish to concentrate on the verification that a program S is correct without the complication of verifying arithmetic formulas that are well known.</li></ul><center><img loading="lazy" src="/posts/ab706956/2.png" width="550"></center><p>example</p><center><img loading="lazy" src="/posts/ab706956/3.png" width="550"></center><ul><li>The formula p in the loop rule is called an <strong>invariant</strong>不变量: it describes the behavior of a single execution of the statement S in the body of the while-statement.</li><li>感觉有点类似sed</li></ul><h2 id="Program-Verification">4. Program Verification</h2><center><img loading="lazy" src="/posts/ab706956/8.png" width="650"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/ab706956/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>academic writing-Literature Review</title>
      <link>https://hejueyun.github.io/posts/dd5e4fc6/</link>
      <guid>https://hejueyun.github.io/posts/dd5e4fc6/</guid>
      <pubDate>Tue, 22 Feb 2022 22:23:20 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;What-is-literature&quot;&gt;1. What is literature&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Published written works (publications)&lt;/li&gt;
&lt;li&gt;Unpublished written works&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Why-literature-review&quot;&gt;2. Why literature review&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;First step of research&lt;/li&gt;
&lt;li&gt;Help you obtain background knowledge&lt;/li&gt;
&lt;li&gt;Identify related work to yours&lt;/li&gt;
&lt;li&gt;Understand &lt;strong&gt;the state of the art&lt;/strong&gt;尖端技术 in your project area&lt;/li&gt;
&lt;li&gt;To frame your arguments and research questions based on the state-of-the-art&lt;/li&gt;
&lt;li&gt;Identify knowledge gaps or limitations in your project area&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Where-to-find-publications&quot;&gt;3. Where to find publications&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ACM Digital Library (&lt;a href=&quot;https://dl.acm.org/&quot;&gt;https://dl.acm.org/&lt;/a&gt;) hosts ACM Journals and ACM Conference Proceedings&lt;/li&gt;
&lt;li&gt;IEEE Xplore (&lt;a href=&quot;https://ieeexplore.ieee.org/&quot;&gt;https://ieeexplore.ieee.org/&lt;/a&gt;) hosts IEEE Journals and IEEE Conference Proceedings&lt;/li&gt;
&lt;li&gt;SpringerLink (&lt;a href=&quot;https://link.springer.com/&quot;&gt;https://link.springer.com/&lt;/a&gt;) hosts Springer Journals (including Nature) and Springer Conference Proceedings&lt;/li&gt;
&lt;li&gt;ScienceDirect (&lt;a href=&quot;https://www.sciencedirect.com/&quot;&gt;https://www.sciencedirect.com/&lt;/a&gt;) hosts Elsevier Journals and e-books&lt;/li&gt;
&lt;li&gt;Wiley Online Library (&lt;a href=&quot;https://onlinelibrary.wiley.com/&quot;&gt;https://onlinelibrary.wiley.com/&lt;/a&gt;) hosts Wiley Journals and e-books&lt;/li&gt;
&lt;li&gt;Google Scholar (&lt;a href=&quot;https://scholar.google.com/&quot;&gt;https://scholar.google.com/&lt;/a&gt;) – Web search engine for scholarly literature&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;How-to-do-literature-review&quot;&gt;4. How to do literature review&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Systematic literature review (SLR) methods&lt;ul&gt;
&lt;li&gt;Traditional SLR&lt;/li&gt;
&lt;li&gt;Snowballing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Traditional-SLR&quot;&gt;4.1. Traditional SLR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用由一组关键词组成的搜索字符串&lt;/li&gt;
&lt;li&gt;对每一个已知的数字图书馆进行详尽的搜索&lt;/li&gt;
&lt;li&gt;旨在选择所有相关的论文&lt;/li&gt;
&lt;li&gt;耗费时间，而且作为个人很难做到这一点&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="What-is-literature">1. What is literature</h2><ul><li>Published written works (publications)</li><li>Unpublished written works</li></ul><h2 id="Why-literature-review">2. Why literature review</h2><ul><li>First step of research</li><li>Help you obtain background knowledge</li><li>Identify related work to yours</li><li>Understand <strong>the state of the art</strong>尖端技术 in your project area</li><li>To frame your arguments and research questions based on the state-of-the-art</li><li>Identify knowledge gaps or limitations in your project area</li></ul><h2 id="Where-to-find-publications">3. Where to find publications</h2><ol><li>ACM Digital Library (<a href="https://dl.acm.org/">https://dl.acm.org/</a>) hosts ACM Journals and ACM Conference Proceedings</li><li>IEEE Xplore (<a href="https://ieeexplore.ieee.org/">https://ieeexplore.ieee.org/</a>) hosts IEEE Journals and IEEE Conference Proceedings</li><li>SpringerLink (<a href="https://link.springer.com/">https://link.springer.com/</a>) hosts Springer Journals (including Nature) and Springer Conference Proceedings</li><li>ScienceDirect (<a href="https://www.sciencedirect.com/">https://www.sciencedirect.com/</a>) hosts Elsevier Journals and e-books</li><li>Wiley Online Library (<a href="https://onlinelibrary.wiley.com/">https://onlinelibrary.wiley.com/</a>) hosts Wiley Journals and e-books</li><li>Google Scholar (<a href="https://scholar.google.com/">https://scholar.google.com/</a>) – Web search engine for scholarly literature</li></ol><h2 id="How-to-do-literature-review">4. How to do literature review</h2><ul><li>Systematic literature review (SLR) methods<ul><li>Traditional SLR</li><li>Snowballing</li></ul></li></ul><h3 id="Traditional-SLR">4.1. Traditional SLR</h3><ul><li>使用由一组关键词组成的搜索字符串</li><li>对每一个已知的数字图书馆进行详尽的搜索</li><li>旨在选择所有相关的论文</li><li>耗费时间，而且作为个人很难做到这一点</li></ul><h3 id="Snowballing">4.2. Snowballing</h3><center><img loading="lazy" src="/posts/dd5e4fc6/1.png" width="550"></center><ol><li>Identify the start set<ol><li>Ask your supervisor to suggest 3-5 good quality, relevant papers</li><li>Add 3-5 top cited and relevant papers from Google Scholar search</li></ol></li><li>Perform backward snowballing<ol><li>Go through the <strong>reference list</strong> of each paper in the start set to identify new papers to include</li><li>Exclude papers that do not fulfil the basic criteria such as, for example, language, publication year and type of publication</li><li>Remove papers from the list that have already been examined in the earlier iteration</li><li>Add the remaining papers to the start set</li><li>Repeat from step1 将剩余的论文添加到起始集</li><li>End if you have gone through the reference list of all the papers in the start set</li></ol></li><li>Perform <strong>forward</strong> snowballing<ol><li>For each paper in the start set, identify the papers that cite this paper using Google Scholar 使用谷歌学术找出<strong>引用该论文</strong>的论文</li><li>For each citing paper that is not in the start set, download it from its DL, read, in the order of: 1) abstract, 2) introduction, 3) conclusion or 4) full text to see if it’s relevant to your project</li><li>Repeat from step 1 until you have gone through all the papers in the start set</li></ol></li><li>Iterations<ol><li>Repeat backward snowballing at least once</li><li>Repeat forward snowballing at least once</li><li>Iterate from forward snowballing to backward, to ensure a comprehensive inclusion of good quality, relevant papers</li><li>The results of iterations are the set of the papers for detailed review and <strong>to be included in your dissertation report</strong>.</li></ol></li><li>Manage your references<ol><li>EndNote - for Word</li><li>BibTex - for Overleaf</li><li><strong>Citation and reference styles</strong><ol><li>Numbering system (IEEE style)</li><li>Author and Date system (Harvard style)</li></ol></li></ol></li></ol><h2 id="Critical-tasks-in-literature-review">5. Critical tasks in literature review</h2><p>When reading each reference, you need to systematically perform the following tasks:</p><ul><li>Data extraction 数据提取: Extract useful information (data) from each reference</li><li>Data synthesis 数据综合: Organize the extracted data into categories and subcategories</li><li>Data analysis 数据分析: Interpret the data to make sense of them through:<ul><li>Quantitative analysis 定量分析: use statistics and frequency counts to analyse the data</li><li>Qualitative analysis 定性分析: use descriptions to interpret the data</li><li>Visualisation 可视化: use tables, charts, graphs to represent the data</li></ul></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://hejueyun.github.io/tags/Note/">Note</category>
      
      
      <comments>https://hejueyun.github.io/posts/dd5e4fc6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-项与范式</title>
      <link>https://hejueyun.github.io/posts/bb11e25b/</link>
      <guid>https://hejueyun.github.io/posts/bb11e25b/</guid>
      <pubDate>Fri, 18 Feb 2022 15:27:40 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Terms-项&quot;&gt;1. Terms 项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Variables. &lt;ul&gt;
&lt;li&gt;Any &lt;strong&gt;variable&lt;/strong&gt;, &lt;strong&gt;constant&lt;/strong&gt; or &lt;strong&gt;0-ary function symbol&lt;/strong&gt; is a term.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions. &lt;ul&gt;
&lt;li&gt;Any &lt;strong&gt;expression&lt;/strong&gt; $f(t_1,…,t_n)$ of n arguments (where each argument $t_i$ is a term and $f$ is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms&lt;/p&gt;
&lt;h2 id=&quot;prenex-conjunctive-normal-form-PCNF-前束范式&quot;&gt;2. prenex conjunctive normal form(PCNF) 前束范式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:&lt;ul&gt;
&lt;li&gt;$Q_1x_1…Q_nx_nM$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1⋯Q_nx_n$ is the prefix and $M$ is the matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个公示可以被写为量词在前，随后是被称为母体的无量词部分，则称其为前束范式的，所有经典逻辑公式都逻辑等价于某个前束范式公式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/bb11e25b/7.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;Let A be a closed formula in PCNF whose prefix consists only of universal quantifiers. The clausal form of A consists of the matrix of A written as a set of clauses&lt;/li&gt;
&lt;li&gt;所以上个例子可以写为：&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/bb11e25b/7.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Terms-项">1. Terms 项</h2><ul><li>Variables. <ul><li>Any <strong>variable</strong>, <strong>constant</strong> or <strong>0-ary function symbol</strong> is a term.</li></ul></li><li>Functions. <ul><li>Any <strong>expression</strong> $f(t_1,…,t_n)$ of n arguments (where each argument $t_i$ is a term and $f$ is a function symbol of valence n) is a term. In particular, symbols denoting individual constants are nullary function symbols, and thus are terms.</li></ul></li></ul><p>Only expressions which can be obtained by finitely many applications of rules 1 and 2 are terms</p><h2 id="prenex-conjunctive-normal-form-PCNF-前束范式">2. prenex conjunctive normal form(PCNF) 前束范式</h2><ul><li>A formula is in prenex conjunctive normal form (PCNF) iff it is of the form:<ul><li>$Q_1x_1…Q_nx_nM$</li></ul></li><li>where the $Q_i$ are quantifiers and $M$ is a quantifier-free formula in CNF. The sequence $Q_1x_1⋯Q_nx_n$ is the prefix and $M$ is the matrix</li></ul><blockquote><p>如果一个公示可以被写为量词在前，随后是被称为母体的无量词部分，则称其为前束范式的，所有经典逻辑公式都逻辑等价于某个前束范式公式</p></blockquote><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/7.gif" width="550"></center><ul><li>Let A be a closed formula in PCNF whose prefix consists only of universal quantifiers. The clausal form of A consists of the matrix of A written as a set of clauses</li><li>所以上个例子可以写为：</li></ul><center><img loading="lazy" src="/posts/bb11e25b/7.gif" width="550"></center><h3 id="Skolem’s-Theorem-斯科伦定理">2.1. Skolem’s Theorem 斯科伦定理</h3><ul><li>In propositional logic, every formula is equivalent to one in CNF, but this is not true in first-order logic. However, a formula in first-order logic can be transformed into <strong>one in clausal form</strong> <strong>without modifying its satisfiability</strong>. 在不改变及可满足性的情况下</li><li><strong>Skolem</strong>: Let $A$ be a closed formula. Then there exists a formula $A^′$ in clausal form such that $A≈A^′$</li></ul><h4 id="≈-vs-≡">2.1.1. ≈ vs ≡</h4><blockquote><p>A≈A′ means that A is satisfiable if and only if A′ is satisfiable; that is, there exists a model for A if and only if there exists a model for A′. (may not be the same)</p><p>This is not the same as logically equivalence A≡A′, which means that for all models $I$, $I$  is a model for A if and only if it is a model for A′.</p></blockquote><hr><ul><li>In A&#x3D;∀x∃yp(x,y), the quantifiers can be read: **for all x, produce a value y associated with that x such that the predicate p is true. **</li><li>But our intuitive concept of a function is the same: y&#x3D;f(x) means that given x, f produces a value y associated with x. The existential quantifier can be removed giving A′&#x3D;∀xp(x,f(x)).<ul><li>y&#x3D;f(x)意味着给定x，f产生一个与x相关的值y。可以删除存在量词，给出 $A^′&#x3D;∀xp(x,f(x))$</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/9.jpg" width="550"></center><h3 id="Skolem’s-Algorithm-斯科伦算法">2.2. Skolem’s Algorithm 斯科伦算法</h3><ul><li>目的：将任意(?)一阶逻辑公式转化为clause form</li></ul><center><img loading="lazy" src="/posts/bb11e25b/13.png" width="550"></center><ul><li>例子：$∀x(p(x)\rightarrow{q(x)})\rightarrow{}(∀xp(x)\rightarrow{}∀xq(x))$</li></ul><ol><li>Eliminate all binary Boolean operators other than ∨ and ∧<ol><li>消去除 ∨ 和 ∧ 外的所有二元操作符</li></ol></li><li>Push negation operators inward, collapsing double negation, until they apply to atomic formulas only<ol><li>将否定运算符向内推，折叠双重否定，直到否定运算符只作用于原子式</li></ol></li><li>Extract quantifiers from the matrix. Repeat until all quantifiers appear in the prefix and the matrix is quantifier-free.  <ol><li>从矩阵中提取量词</li><li>重复以上步骤，直到所有的量词都出现在前缀中，并且矩阵无量词</li></ol></li><li>Use the distributive laws to transform the matrix into CNF. The formula is now in PCNF.<ol><li>使用分配律将矩阵转换为CNF。该公式现在是PCNF</li></ol></li><li>For every existential quantifier $∃x$ in A, let $y_1,…,y_n$ be the universally quantified variables preceding $∃x$ and let f be a new n-ary function symbol. <ol><li>Delete $∃x$ and replace every occurrence of x by $f(y_1,…,y_n)$. </li><li>If there are no universal quantifiers preceding ∃x, replace x by a new constant (0-ary function). </li><li>These new function symbols are <strong>Skolem functions</strong> and the process of replacing existential quantifiers by functions is <strong>Skolemization</strong>.</li></ol></li><li>The formula can be written in clausal form by dropping the (universal) quantifiers and writing the matrix as sets of clauses</li></ol><center><img loading="lazy" src="/posts/bb11e25b/10.jpg" width="550"></center><center><img loading="lazy" src="/posts/bb11e25b/11.jpg" width="550"></center><ul><li>注意最后一步大括号以及逗号分别取代的二元符号<ul><li>clause: {L,L,L}代表的是or</li><li>set of clauses:{C,C,C}代表的是and</li></ul></li><li>同时注意有一步是<strong>rename</strong></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/12.jpg" width="550"></center><h3 id="Skolemised-form-斯科伦范式">2.3. Skolemised form 斯科伦范式</h3><ul><li>如果一阶逻辑式的前束范式只有全称量词，则称其为是符合Skolem 范式的</li></ul><h3 id="Properties-of-CNFs-and-clausal-forms">2.4. Properties of CNFs and clausal forms</h3><ul><li>For F be any formula and suppose $F⇒^{∗}_{CNF} F^{‘}$<ul><li>Then $F ≡ F^{‘}$</li></ul></li></ul><h3 id="为什么需要斯科伦范式">2.5. 为什么需要斯科伦范式</h3><center><img loading="lazy" src="/posts/bb11e25b/14.png" width="550"></center><h2 id="Herbrand-Models-埃尔布朗模型">3. Herbrand Models 埃尔布朗模型</h2><blockquote><p><strong>When function symbols are used to form terms</strong>, there is no easy way to describe the set of possible <strong>interpretations</strong>. The domain could be a numerical domain or a domain of data structures or almost anything else. The definition of even one function can choose to assign an arbitrary element of the domain to an arbitrary subset of arguments.</p></blockquote><blockquote><p><strong>Herbrand models</strong>, which are a relatively limited set of interpretations that have the following property: If a set of clauses has a model then it has an Herbrand model.</p></blockquote><ul><li>a formula is satisfiable if and only if its clausal form is satisfiable and A set of clauses S has a model iff it has an Herbrand model.<ul><li>反之亦成立</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/22.png" width="550"></center><h3 id="Herbrand-Universes-for-domain">3.1. Herbrand Universes (for domain)</h3><p>Let Σ &#x3D; (F, P) denote the <strong>signature</strong>标识 of a clause set N</p><ul><li><p>The Herbrand universe is $T_Σ$, i.e., the set of all <strong>ground terms</strong> over Σ</p><ul><li>Suppose N &#x3D; {P(a), ¬P(x) ∨ P(f (x, b))}</li><li>Then F consists of one binary function symbol f and two constants a and b Herbrand universe over Σ:<ul><li>$T_Σ &#x3D; {a, b, f (a, a), f (a, b), f (b, a), f (b, b), f (a, f (a, a)), . . .}$</li></ul></li></ul></li><li><p>If Σ contains non-constant function symbols then TΣ is infinite</p></li><li><p>Important assumption: There is at least one constant in the signature Σ</p><ul><li>Suppose N &#x3D; {P(x), ¬P(x) ∨ P(f (x, y))}. Then include a (fresh) in Σ<ul><li>$T_Σ &#x3D; {a, f (a, a), f (a, f (a, a)), f (f (a, a), f (a, a)), . . .}$</li></ul></li></ul></li><li><p>If there are no constant symbols or 0-ary function symbols in S, i<strong>nitialize the inductive definition</strong> of $H_S$ with an arbitrary constant symbol a. </p></li><li><p>The Herbrand universe is just the set of ground terms that can be formed from symbols in S. Obviously, if S contains a function symbol, the Herbrand universe is infinite since $f(f(…(a)…))∈H_S$</p></li></ul><center><img loading="lazy" src="/posts/bb11e25b/20.gif" width="550"></center><h3 id="Herbrand-Interpretations">3.2. Herbrand Interpretations</h3><p>A Herbrand interpretation, denoted I, is a set of ground atoms over Σ</p><ul><li>$I &#x3D; {A_1, . . . , A_n, . . .}$</li><li>Note: $I |&#x3D; A$ iff $A ∈ I$<ul><li>is equivalent to $I |\neq{} A$ iff $A \notin{} I$</li></ul></li></ul><center><img loading="lazy" src="/posts/bb11e25b/15.png" width="550"></center><ul><li><p>注意此处将对某一公式的解的验证转化为对该公式的埃尔布朗解的验证</p><ul><li>同时注意I不是P(x)的解，并不意味着I就是非P(x)的解！</li></ul></li><li><p>Truth in I of any set N of clauses&#x2F;quantifier-free formulae:</p><center><img loading="lazy" src="/posts/bb11e25b/16.png" width="550"></center></li></ul><p><strong>example</strong></p><center><img loading="lazy" src="/posts/bb11e25b/17.png" width="550"></center><h3 id="all-ground-instances">3.3. all ground instances</h3><center><img loading="lazy" src="/posts/bb11e25b/18.png" width="550"></center><p>Let N be a set of Σ-clauses. Then</p><ul><li><p>N is true in a standard interpretation</p><ul><li>iff N has a Herbrand model (over Σ)</li><li>iff $G_Σ(N)$ has a Herbrand model (over Σ)</li></ul></li><li><p>We use it for model construction required for the completeness proof of the resolution system</p><ul><li>我们用它来构建归结系统的完整性证明所需的解释</li></ul></li></ul><p>Using Herbrand’s theorem to find a model</p><center><img loading="lazy" src="/posts/bb11e25b/19.png" width="550"></center><center><img loading="lazy" src="/posts/bb11e25b/21.png" width="550"></center><hr><h2 id="Formulas-in-number-theory-informal-meaning-in-N">4. Formulas in number theory, informal meaning in $N$</h2><center><img loading="lazy" src="/posts/bb11e25b/1.png" width="550"></center><ul><li>Even：偶数</li></ul><h2 id="Translating-English-into-first-order-logic-formulas">5. Translating English into first-order logic formulas</h2><center><img loading="lazy" src="/posts/bb11e25b/2.png" width="550"></center><h2 id="Substitution-替换">6. Substitution 替换</h2><ul><li><strong>一个function</strong></li><li>$σ : X → TΣ(X)$</li><li>such that the set $Dom(σ) &#x3D;^{def}{x ∈ X | σ(x) \neq{x}}$ is <strong>finite</strong><ul><li>Dom(σ) is the <strong>domain</strong> of σ</li><li>$Cod(σ) &#x3D;^{def} {σ(x) | x ∈ Dom(σ)}$ is the <strong>codomain</strong> of σ</li></ul></li></ul><p>Example</p><ul><li>F &#x3D; P(g(x), y, x)</li><li>F{x&#x2F;a, y&#x2F;f (z)} &#x3D; P(g(a), f (z), a)</li></ul><center><img loading="lazy" src="/posts/bb11e25b/3.png" width="550"></center><p><strong>一般式</strong></p><center><img loading="lazy" src="/posts/bb11e25b/4.png" width="550"></center><h3 id="Modification-of-a-substitution">6.1. Modification of a substitution</h3><center><img loading="lazy" src="/posts/bb11e25b/5.png" width="550"></center><h3 id="Restriction">6.2. Restriction</h3><ol><li>only for a free variable</li><li>The captured variable must be renamed into a “fresh” variable, say x’, F{y&#x2F;x} &#x3D; ∃x’(x’ &gt; x)<ol><li>也就是不能用x换y，导致歧义</li></ol></li></ol><h3 id="substitution-instance">6.3. substitution instance</h3><p><strong>instance就是由substitution所产生的</strong></p><blockquote><p>n. We say that a formula φ is an instance of a formula ψ if there exists a substitution <code>σ</code> for the free variables in ψ such that ψσ is a renamed variant of φ</p></blockquote><ul><li>We say Eσ is formed by applying σ to E, where E is an expression (a term or formula)</li><li>Example σ &#x3D; {x&#x2F;a, y&#x2F;b}<ul><li>P(g(x), y, x)σ &#x3D; P(g(x)σ, yσ, xσ) &#x3D; P(g(xσ), yσ, xσ) &#x3D; P(g(a), b, a)</li></ul></li></ul><h3 id="identity-substitution-一致性替换">6.4. identity substitution 一致性替换</h3><blockquote><p>The identity substitution, which maps every variable to itself, is the neutral element of substitution composition</p><p>一致性替换，将每个变量都映射到自身，是替换组合的中性元素。</p></blockquote><h3 id="Codomain-到达域">6.5. Codomain 到达域</h3><ul><li>到达域（英语：Codomain），或称为陪域、余定义域、上域、终域、共变域、目标集</li><li>一个函数的到达域指的是<strong>至少包含所有</strong>此函数的输出值的一个集合。在函数符号 ${\displaystyle f\colon X\rightarrow Y}$ 中， ${\displaystyle Y}$ 是函数 ${\displaystyle f}$ 的到达域</li><li><strong>不是值域</strong><ul><li>${\displaystyle f}$ 的值域是 ${\displaystyle Y}$ 的一个子集，若 ${\displaystyle f}$ 是一个满射函数，则 ${\displaystyle f}$ 的到达域和值域相等</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/bb11e25b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-演绎</title>
      <link>https://hejueyun.github.io/posts/f450749c/</link>
      <guid>https://hejueyun.github.io/posts/f450749c/</guid>
      <pubDate>Fri, 18 Feb 2022 15:11:01 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Deductive-system&quot;&gt;1. Deductive system&lt;/h2&gt;&lt;h3 id=&quot;G&quot;&gt;1.1. G&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference &lt;strong&gt;for the universal quantifier&lt;/strong&gt;全称量词.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/1.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;H&quot;&gt;1.2. H&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The rules of inference are modus ponens and generalization&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/2.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;The Deduction Rule：&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f450749c/3.gif&quot; width=&quot;550&quot;&gt;&lt;/center&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Deductive-system">1. Deductive system</h2><h3 id="G">1.1. G</h3><ul><li>We extend the deductive systems $G$ and $H$ from propositional logic to first-order logic by adding axioms and rules of inference <strong>for the universal quantifier</strong>全称量词.</li></ul><center><img loading="lazy" src="/posts/f450749c/1.gif" width="550"></center><h3 id="H">1.2. H</h3><ul><li>The rules of inference are modus ponens and generalization</li></ul><center><img loading="lazy" src="/posts/f450749c/2.gif" width="550"></center><ul><li>The Deduction Rule：</li></ul><center><img loading="lazy" src="/posts/f450749c/3.gif" width="550"></center>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/f450749c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-语法与语义</title>
      <link>https://hejueyun.github.io/posts/ed4b45dd/</link>
      <guid>https://hejueyun.github.io/posts/ed4b45dd/</guid>
      <pubDate>Tue, 15 Feb 2022 23:57:35 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;引入&quot;&gt;1. 引入&lt;/h2&gt;&lt;p&gt;命题逻辑对于算术等数学理论的形式化来说，表现力并不充分。一个算术表达式，如$x+2&amp;gt;y-1$，既不是真的，也不是假的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的真假取决于变量x和y的值&lt;/li&gt;
&lt;li&gt;我们需要将运算符+和-的含义形式化，作为将一对数字映射为一个数字的函数&lt;/li&gt;
&lt;li&gt;像&amp;gt;这样的关系运算符必须被形式化为将一对数字映射为真值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;命题逻辑vs一阶逻辑&quot;&gt;2. 命题逻辑vs一阶逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命题逻辑（Propositional Logic） &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形如 ¬P，P∧Q，P∨Q，P → Q ，P↔Q的语句，值为True或者False&lt;/li&gt;
&lt;li&gt;推理规则较简单，往往通过（1.真值表  2.为数不多的推理规则，例如Modus ponesn等几个）&lt;/li&gt;
&lt;li&gt;缺点：不能或者很难表示复杂的语句，不能记录推理过程中的变化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一阶逻辑（First Order Logic），简称FOL&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含的东西有常量（Constant symbol），谓词符号（Predicate symbol），函数符号（Function symbol），变量（Variable），连词（ ∧∨→↔），量词（Quantifiers, ∃∀）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命题逻辑(很少部分人叫它作零阶逻辑). 在命题逻辑里, 每一个字母就代表一个命题, 所以命题逻辑只能表达句子之间的关系, 比如“p&amp;amp;q”, “if p then q”等等的真值如何从p和q的真值中计算出来.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一阶逻辑则引入了两个量词, 即universal quantifier(倒A)和existential quantifier(倒E), 并且加入了一阶谓词和individual variables和individual constants. 这些导致一阶逻辑可以量化individuals in the domain.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比如经典的三段论就可以被一阶逻辑表达 &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For all x, Hx-&amp;gt;Mx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ms&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory&quot;&gt;2.1. vs Propositional Logic vs Set Theory vs Elementary Number Theory&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Propositional Logic&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Equality: no&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Predicate symbols: A1, A2, . . .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constant symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function symbols: none&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Set Theory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Equality: yes&lt;/li&gt;
&lt;li&gt;Predicate symbols: ∈&lt;/li&gt;
&lt;li&gt;Constant symbols: ∅&lt;/li&gt;
&lt;li&gt;Function symbols: none&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="引入">1. 引入</h2><p>命题逻辑对于算术等数学理论的形式化来说，表现力并不充分。一个算术表达式，如$x+2&gt;y-1$，既不是真的，也不是假的。</p><ol><li>它的真假取决于变量x和y的值</li><li>我们需要将运算符+和-的含义形式化，作为将一对数字映射为一个数字的函数</li><li>像&gt;这样的关系运算符必须被形式化为将一对数字映射为真值</li></ol><h2 id="命题逻辑vs一阶逻辑">2. 命题逻辑vs一阶逻辑</h2><ol><li><p>命题逻辑（Propositional Logic） </p><ol><li>形如 ¬P，P∧Q，P∨Q，P → Q ，P↔Q的语句，值为True或者False</li><li>推理规则较简单，往往通过（1.真值表  2.为数不多的推理规则，例如Modus ponesn等几个）</li><li>缺点：不能或者很难表示复杂的语句，不能记录推理过程中的变化</li></ol></li><li><p>一阶逻辑（First Order Logic），简称FOL</p><ol><li>包含的东西有常量（Constant symbol），谓词符号（Predicate symbol），函数符号（Function symbol），变量（Variable），连词（ ∧∨→↔），量词（Quantifiers, ∃∀）</li></ol></li><li><p>命题逻辑(很少部分人叫它作零阶逻辑). 在命题逻辑里, 每一个字母就代表一个命题, 所以命题逻辑只能表达句子之间的关系, 比如“p&amp;q”, “if p then q”等等的真值如何从p和q的真值中计算出来.</p></li><li><p>一阶逻辑则引入了两个量词, 即universal quantifier(倒A)和existential quantifier(倒E), 并且加入了一阶谓词和individual variables和individual constants. 这些导致一阶逻辑可以量化individuals in the domain.</p><ol><li>比如经典的三段论就可以被一阶逻辑表达 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For all x, Hx-&gt;Mx</span><br><span class="line"></span><br><span class="line">Hs</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">Ms</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="vs-Propositional-Logic-vs-Set-Theory-vs-Elementary-Number-Theory">2.1. vs Propositional Logic vs Set Theory vs Elementary Number Theory</h3><p><strong>Propositional Logic</strong></p><ul><li><strong>Equality: no</strong></li><li>Predicate symbols: A1, A2, . . .</li><li><strong>Constant symbols: none</strong></li><li><strong>Function symbols: none</strong></li></ul><p><strong>Set Theory</strong></p><ul><li>Equality: yes</li><li>Predicate symbols: ∈</li><li>Constant symbols: ∅</li><li>Function symbols: none</li></ul><p><strong>Elementary Number Theory</strong>初等数论</p><ul><li>Equality: yes</li><li>Predicate symbols: &lt;</li><li>Constant symbols: 0</li><li>Function symbols: S (successor), +, ×, exp</li></ul><h2 id="集合论vs一阶逻辑">3. 集合论vs一阶逻辑</h2><ul><li>集合论作为公理系统，一阶逻辑作为<strong>推理系统</strong>，共同为数学打下基石</li><li>谈论某一理论时，都需要有<strong>上层语言</strong>（meta-language）作为基础。对于最上层的语言研究一般归于哲学的范畴<ul><li>基于上层语言，我们可以定义<strong>一阶语言</strong>（一阶逻辑的语言），语言中字母表、项、公式的不同可以产生不同的“子语言”。如：初等算术语言，群论语言，<strong>集合论语言</strong></li><li>定义一阶语言的模型，模型对语言做出解释（可以看成是<strong>语义</strong>部分）。譬如对于初等算术语言，有初等算术的标准模型</li><li>一阶语言的推理系统给出了一阶逻辑的语法。不同的推理系统如自然推理系统和 PK 推理系统可以证明是等价的。同时注意到，推理系统可以独立于模型（<strong>语义</strong>）而存在。而推理系统的 soundness 和 completeness 保证了语义与语法的一致性</li></ul></li><li>同阶下，一阶语言的集合论是一阶逻辑的一部分（一阶语言+公式集），但一阶逻辑又不能表达所有的集合论（高阶）</li></ul><h2 id="Syntax">4. Syntax</h2><p><strong>Logical Symbols</strong></p><ul><li>Parentheses: (, )</li><li>Propositional connectives: ¬, ∨, ∧, →, ↔</li><li>Variables: v1, v2, . . .</li><li>Quantifiers: ∀, ∃<ul><li>Quantifiers allow a purely syntactical expression of the statement that the relation represented by a predicate is true for some or all elements of the domain</li><li>量词允许以纯语法的方式来表达谓词所代表的关系对域中的某些或所有元素来说是真的</li></ul></li></ul><p><strong>Parameters</strong></p><ul><li>Equality symbol (optional): &#x3D;</li><li>Predicate谓词 symbols: e.g. p(x), x &gt; y</li><li>Constant symbols: e.g. 0, John, π</li><li>Function symbols: e.g. f(x), x + y, x +[2] y</li></ul><p><strong>注意</strong></p><ul><li>大写P、Q、R等默认位predicate</li><li>小写p、q、r才是函数</li><li>非+predicate有意义，但非+函数没有意义</li></ul><h3 id="Predicate-谓词">4.1. Predicate 谓词</h3><ul><li>Predicates are used to represent <strong>functions</strong> from a domain to truth values<ul><li><strong>谓词</strong>被用来表示从域到真值的<strong>函数</strong></li><li>$p^n$ is called an n-ary predicate</li></ul></li></ul><h3 id="Quantifier-量词">4.2. Quantifier 量词</h3><ul><li>∀ is the universal quantifier and is read <strong>for all</strong>.</li><li>∃ is the existential quantifier and is read <strong>there exists</strong></li><li>A universal or existential formula ∀xA or ∃xA is a <strong>quantified formula</strong></li><li>In many presentations of first-order logic, ∀ is defined in the logic and ∃ is considered to be an abbreviation of ¬ ∀¬</li></ul><h3 id="断言符号？">4.3. 断言符号？</h3><p>断言是容许一个、甚至多个对象，所以对于自然数 $n,j$ 我们约定 $A_{j}^{n}(x_1,x_2,…,x_n)$ 为一阶逻辑的<strong>合法词汇</strong>，它在直观上表示一个有 ${\displaystyle{} n}$ 个”对象”的断言，我们称它为 ${\displaystyle{} n}$ 元断言符号。下标的自然数 ${\displaystyle{} j}$ 只是拿来和其他同为 ${\displaystyle{} n}$ 元的断言符号作区别</p><h3 id="signature-标识">4.4. signature 标识</h3><ul><li><p>在一阶逻辑中的标识(signature)为包含函数常数(function constants)和谓词常数(predicate constants)俩种元素的一个集合</p></li><li><p>例如：$Σ &#x3D; (F, P) &#x3D; ({ a_1,…,a_n, f_1,…, f_k } , { \simeq{}&#x2F;2, P_1,…, P_m } )$</p></li></ul><h3 id="arity-元数">4.5. arity 元数</h3><blockquote><p>函数或运算的元数是指所需的参数或算子的数量。关系的元数则是指其对应之笛卡儿积的维度</p></blockquote><ul><li>一元unary函数、二元…</li><li>Equality is a special predicate symbol of arity 2.</li><li>Constant symbols can also be thought of as functions whose arity is 0.</li></ul><h2 id="Formula">5. Formula</h2><ul><li><del>本质上是n元关系</del></li><li>函数不是</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/3.gif" width="550"></center><h3 id="Atomic-Formulas-原子公式">5.1. Atomic Formulas 原子公式</h3><ul><li>An atomic formula is an expression of the form: $P(t_1, . . . , t_n)$ here P is a predicate symbol of arity n and $t_1,. . . ,t_n$ are terms.</li><li>If the language includes the equality symbol, we consider the equality symbol to be a special predicate of arity 2</li></ul><h3 id="Well-formed-Formulas-合式公式">5.2. Well-formed Formulas 合式公式</h3><ul><li>The set of well-formed formulas is the set of expressions generated from the <strong>atomic</strong> formulas by the operations E¬, E→, and $Q_{i}i$ &#x3D; 1, 2, . . .</li></ul><ol><li>原子公式为公式。(美观起见，在原子公式外面包一层括弧也是公式)</li><li>若 ${\displaystyle {\mathcal {A}}}$ 为公式，则 (${\displaystyle (\neg {\mathcal {A}})}$ 为公式。</li><li>若 ${\displaystyle {\mathcal {A}}}$ 与 ${\displaystyle {\mathcal {B}}}$ 为公式，则 ${\displaystyle ({\mathcal {A}}\Rightarrow {\mathcal {B}})}$ 为公式。</li><li>若 ${\displaystyle {\mathcal {A}}}$ 为公式， ${\displaystyle x}$ 为任意变量，则 ${\displaystyle (\forall x{\mathcal {A}})}$ 为公式。 (美观起见 ${\displaystyle (\forall x){\mathcal {A}}:&#x3D;\forall x{\mathcal {A}}}$ ，也就是里面的量词有无外包括弧都是公式)<br>合式公式只能透过以上四点，于有限步骤内置构出来</li></ol><h3 id="quantified-formula-量化公式">5.3. quantified formula 量化公式</h3><ul><li>A universal or existential formula ∀xA or ∃xA is a quantified formula. </li><li>x is the quantified variable and its scope is the formula A. </li><li>It is not required that x actually appear in the scope of its quantification.</li></ul><hr><ul><li>If a formula has no free variables, it is <strong>closed</strong>. If ${x_1,…,x_n}$ are all the free variables of A, the universal closure of A is $∀x_1 …∀x_n$ A and the existential closure is $∃x_1…∃x_n$ A.</li></ul><p><strong>Example</strong></p><ol><li>p(x,y) has two free variables x and y, ∃yp(x,y) has one free variable x and ∀x∃yp(x,y) is closed. The universal closure of p(x,y) is ∀x∀yp(x,y) and its existential closure is ∃x∃yp(x,y).</li><li>In $∀xp(x)∧q(x)$, the occurrence of x in $p(x)$ is bound and <strong>the occurrence in $q(x)$ is free</strong>. The universal closure is $∀x(∀xp(x)∧q(x))$. <ol><li>Obviously, it would have been better to write the formula as $∀xp(x)∧q(y)$ with y as the free variable; its universal closure is ∀y(∀xp(x)∧q(y)) </li><li>这个其实就是把$∀xp(x)$简写了，实际应该就是$∀x(p(x))$，量词后紧跟的就是作用域(<strong>scope</strong>)</li></ol></li></ol><h4 id="Free-and-Bound-Variables-自由变量和约束变量">5.3.1. Free and Bound Variables 自由变量和约束变量</h4><p>量词所施用的<strong>公式</strong>被称为**量词的范围(scope)**。若变量 ${\displaystyle x}$ 某次出现在 ${\displaystyle \forall x}$ 的范围内，称这样出现的 ${\displaystyle x}$ 为不自由&#x2F;被约束的 ${\displaystyle x}$ (not free&#x2F;bounded)；反过来说，不出现在 ${\displaystyle \forall x}$ 的范围内的某个 ${\displaystyle x}$ 被称为自由的 ${\displaystyle x}$，（<code>∃</code>同理）</p><center><img loading="lazy" src="/posts/ed4b45dd/2.png" width="550"></center><ul><li>（封闭公式、句子）If no variable occurs free in a $wff x$, then $x$ is a sentence</li></ul><hr><ul><li>If α is an <strong>atomic formula</strong>, then <ul><li>x occurs free in α iff x occurs in α.</li><li>x occurs free in (¬α) iff x occurs free in α.</li><li>x occurs free in (α → β) iff x occurs free in α or in β.</li><li>x occurs free in ∀ $v_i$ α iff x occurs free in α and $x\neq{v_i}$</li></ul></li></ul><h3 id="ground-formula-基态公式">5.4. ground formula 基态公式</h3><ul><li>A <strong>ground term</strong> is a term which <strong>does not contain any variables</strong>.</li><li>A <strong>ground atomic formula</strong> is an atomic formula, all of whose terms are ground.</li><li>A <strong>ground literal</strong> is a ground atomic formula or the negation of one.</li><li>A <strong>ground formula</strong> is a <strong>quantifier-free</strong> formula, all of whose <strong>atomic formula are ground</strong>.</li><li>A is a ground instance of a quantifier-free formula A′ iff it can be obtained from A′ by substituting ground terms for the (free) variables in A′</li></ul><blockquote><p>The terms a, f(a,b), g(b,f(a,b)) are ground. p(f(a,b),a) is a ground atomic formula and ¬ p(f(a,b),a) is a ground literal. p(f(x,y),a) is not a ground atomic formula because of the variables x,y</p></blockquote><h2 id="Semantic-Interpretation">6. Semantic: Interpretation</h2><ul><li>In propositional logic, the truth of a formula was determined by a truth assignment over the propositional symbols.</li><li>In first-order logic, we use a <strong>model</strong> (also called a <strong>structure</strong>) to determine the truth of a formula</li></ul><hr><ul><li>In propositional logic, an interpretation is a mapping from atomic propositions to truth values. </li><li>In first-order logic, the analogous concept is a mapping from atomic formulas to truth values.<ul><li>However, atomic formulas contain variables and constants that must be assigned elements of some domain; once that is done, the <strong>predicates</strong> are interpreted as <strong>relations</strong> over the domain.（比如大于小于关系）</li></ul></li></ul><center><img loading="lazy" src="/posts/ed4b45dd/4.png" width="550"></center><h3 id="assignment">6.1. assignment</h3><center><img loading="lazy" src="/posts/ed4b45dd/5.jpg" width="550"></center><h3 id="Closed-Formula-闭公式">6.2. Closed Formula 闭公式</h3><p>Validity and Satisfiability</p><ul><li>Let A be a closed formula of first-order logic<ul><li>A is true in I or I is a <strong>model</strong> for A iff $v_I(A)&#x3D;T$ . Notation: I⊧A.</li><li>A is valid if for all interpretations I, I⊧A. Notation: ⊨A</li><li>A is satisfiable if for some interpretation I, I⊧A.</li><li>A is unsatisfiable if it is not satisfiable.</li><li>A is falsifiable if it is not valid</li></ul></li></ul><p>$∀x∀y(p(x,y)→p(y,x))$</p><ul><li>The formula is satisfiable in an interpretation where p is assigned a symmetric relation like &#x3D;. It is not valid because the formula is falsified in an interpretation that assigns to p a non-symmetric relation like &lt;</li></ul><h3 id="An-Interpretation-for-a-Set-of-Formulas">6.3. An Interpretation for a Set of Formulas</h3><blockquote><p>In propositional logic, the concept of interpretation and the definition of properties such as satisfiability can be extended to sets of formulas. The same holds for first-order logic</p></blockquote><ul><li>Let U&#x3D;{A 1,…} be a set of formulas where {p 1,…,p m } are all the predicates appearing in all A i ∈S and {a 1,…,a k } are all the constants appearing in all A i ∈S. An interpretation $I_v$ for S is as triple:<ul><li>${D,{R_1,…R_n},{d_1,…d_n}}$</li></ul></li><li>where D is a non-empty set called the domain, R i is an $n_i$-ary relation on D that is assigned to the $n_i$-ary predicate p i and d i ∈D is an element of D that is assigned to the constant a i</li></ul><h2 id="Logical-Equivalence">7. Logical Equivalence</h2><ul><li>Let U&#x3D;{A 1,A 2} be a pair of <strong>closed formulas</strong>. A 1 is logically equivalent to A 2 iff $v_{I_{U}}(A_1)&#x3D;v_{I_{U}}(A_2)$ for all interpretations . Notation: $A_1≡A_2$</li></ul><center><img loading="lazy" src="/posts/ed4b45dd/6.jpg" width="550"></center><p>对等duality公式</p><ul><li><p>用于公式化简和转化为范式</p></li><li><p>¬∀x.A ≡ ∃x.¬A</p></li><li><p>¬∃x.A ≡ ∀x.¬A</p></li></ul><center><img loading="lazy" src="/posts/ed4b45dd/7.jpg" width="550"></center><center><img loading="lazy" src="/posts/ed4b45dd/8.jpg" width="550"></center><ul><li>Theorem (Equivalent Replacement Theorem)<ul><li>Suppose A, B, C are first-order formulas and A is a subformula of C</li><li>If A ≡ B, then C(. . . A . . .) ≡ C(. . . B . . .)</li></ul></li></ul><h2 id="语义表">8. 语义表</h2><blockquote><p>语义表的方法对于显示一个公式是不可满足的来说是合理和完整的，但是它不是一个可满足性的决定程序，因为表的分支可能是无限的。当一个tableau被构造出来时，一个普遍量词后面跟着一个存在量词可能会导致一个无限的分支：存在公式被用一个新的常数实例化，然后普遍公式的实例化会导致一个新的存在量词公式的出现，如此无限地下去。有一些公式只在无限域中是可满足的。</p></blockquote><h2 id="参考">9. 参考</h2><ul><li><a href="https://www.zhihu.com/question/40419871/answer/127792613">命题逻辑和一阶逻辑分别是什么？ - 嘉嘉杨的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/22915503/answer/151477106">一阶逻辑和高阶逻辑的区别，能不能具象一点说明？ - ZS Chen的回答 - 知乎</a></li><li><a href="https://www.zhihu.com/question/28776730/answer/702538400">集合论和一阶逻辑的关系是什么？ - Zangwei Zheng的回答 - 知乎</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/ed4b45dd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-命题逻辑-SAT</title>
      <link>https://hejueyun.github.io/posts/f363d9fd/</link>
      <guid>https://hejueyun.github.io/posts/f363d9fd/</guid>
      <pubDate>Tue, 15 Feb 2022 17:31:21 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;SAT-布尔可满足性问题&quot;&gt;1. SAT 布尔可满足性问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可满足性（英语：Satisfiability）是用来解决给定的真值方程式，是否存在一组变量赋值，使问题为可满足。布尔可满足性问题（Boolean satisfiability problem；SAT ）属于&lt;strong&gt;决定性问题&lt;/strong&gt;，也是第一个被证明属于&lt;strong&gt;NP完全&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Properties-of-Clausal-Form&quot;&gt;2. Properties of Clausal Form&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A computer program that searches for a model for a propositional formula is called a SAT Solver. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Let S, S′ be sets of clauses. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S≈S′ denotes that S is satisfiable if and only if S′ is satisfiable. &lt;/li&gt;
&lt;li&gt;It is important to understand that S≈S′ does not imply that S≡S′ (S is &lt;strong&gt;logically equivalent&lt;/strong&gt; to S′)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/f363d9fd/1.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;


&lt;h3 id=&quot;Pure-Literals&quot;&gt;2.1. Pure Literals&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S&lt;/p&gt;
&lt;p&gt;Let S be a set of clauses and let l be a pure literal in S. Let S′ be obtained from S by deleting every clause containing l. Then S≈S′&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也就是删除纯文字不影响及健全性的传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Unit-Clauses&quot;&gt;2.2. Unit Clauses&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Let {l}∈S be a unit clause and let S′ be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then S≈S′.&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="SAT-布尔可满足性问题">1. SAT 布尔可满足性问题</h2><blockquote><p>可满足性（英语：Satisfiability）是用来解决给定的真值方程式，是否存在一组变量赋值，使问题为可满足。布尔可满足性问题（Boolean satisfiability problem；SAT ）属于<strong>决定性问题</strong>，也是第一个被证明属于<strong>NP完全</strong>的问题</p><p>决定性问题，亦称判定问题，（英语：Decision problem）是一个在某些形式系统回答“是”或“否”的问题</p></blockquote><h2 id="Properties-of-Clausal-Form">2. Properties of Clausal Form</h2><blockquote><p>A computer program that searches for a model for a propositional formula is called a SAT Solver. </p></blockquote><blockquote><p>Let S, S′ be sets of clauses. </p><ul><li>S≈S′ denotes that S is satisfiable if and only if S′ is satisfiable. </li><li>It is important to understand that S≈S′ does not imply that S≡S′ (S is <strong>logically equivalent</strong> to S′)</li></ul></blockquote><center><img loading="lazy" src="/posts/f363d9fd/1.jpg" width="550"></center><h3 id="Pure-Literals">2.1. Pure Literals</h3><blockquote><p>Let S be a set of clauses. A pure literal in S is a literal l that appears in at least one clause of S, but its complement l c does not appear in any clause of S</p><p>Let S be a set of clauses and let l be a pure literal in S. Let S′ be obtained from S by deleting every clause containing l. Then S≈S′</p><ul><li>也就是删除纯文字不影响及健全性的传递</li></ul></blockquote><h3 id="Unit-Clauses">2.2. Unit Clauses</h3><blockquote><p>Let {l}∈S be a unit clause and let S′ be obtained from S by deleting every clause containing $l$ and by deleting $l^c$ from every (remaining) clause. Then S≈S′.</p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/2.jpg" width="550"></center><h3 id="Empte-Clauses">2.3. Empte Clauses</h3><ul><li>□ is unsatisfiable<ul><li>根据Unit Clauses的定理显然</li></ul></li></ul><h3 id="Renaming">2.4. Renaming</h3><blockquote><p>Let $S$ be a set of clauses and $U$ a set of atomic propositions. $R_U(S)$, the renaming of S by U, is obtained from S by replacing each literal l on an atomic proposition in U by $l^c$ </p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/3.jpg" width="550"></center><h2 id="Davis-Putnam-Algorithm-戴维斯–普特南算法">3. Davis-Putnam Algorithm 戴维斯–普特南算法</h2><blockquote><p>The Davis-Putnam (DP) algorithm was one of the first algorithms proposed for deciding satisfiability</p><p>戴维斯-普特南（DP）算法是最早提出的用于<strong>决定可满足性</strong>的算法之一</p></blockquote><ul><li><p>Input: A formula A in clausal form.</p></li><li><p>Output: Report that A is satisfiable or unsatisfiable.</p></li><li><p>Perform the following rules <strong>repeatedly</strong>, but the third rule is used only if the first two do not apply</p><ul><li>Unit-literal rule <blockquote><p>If there is a unit clause {l}, delete <strong>all clauses</strong> containing l and delete <strong>all occurrences</strong> of $l^c$ from <strong>all other clauses</strong></p></blockquote></li><li>Pure-literal rule<blockquote><p>If there is a pure literal l, delete all clauses containing l</p></blockquote></li><li>Eliminate a variable by resolution:<blockquote><p>Choose an atom p and perform all possible resolutions on clauses that clash on $p$ and $\bar{p}$. Add these <strong>resolvents</strong>解析器 to the set of clauses and then delete all clauses containing $p$ or $\bar{p}$</p></blockquote></li></ul></li><li><p>Terminate the algorithm under the following conditions:</p><ul><li>If empty clause <code>□</code> is produced, report that the formula is unsatisfiable.</li><li>If no more rules are applicable适用, report that the formula is satisfiable.</li></ul></li></ul><p><strong>Example</strong></p><ul><li>${p, \bar{p}q, \bar{q}r, \bar{r}st}$<blockquote><p>Performing the unit-literal rule on p leads to the creation of a new unit clause q upon which the rule can be applied again. This leads to a new unit clause r and applying the rule results in the singleton set of clauses {st}. Since no more rules are applicable, the set of clauses is satisfiable.</p></blockquote></li></ul><hr><blockquote><p>Repeatedly applying the unit-literal rule until it is no longer applicable is called <strong>unit propagation</strong> or <strong>Boolean constraint propagation（BCP）</strong>. 单位传播或布尔约束传播</p></blockquote><h2 id="Davis-Putnam-Logemann-Loveland-DPLL">4. Davis-Putnam-Logemann-Loveland(DPLL)</h2><ul><li>DPLL is a <strong>decision procedure</strong> for propositional clausal logic</li></ul><p>解决 CNF-SAT 问题</p><blockquote><p>一个朴素的回溯算法会检查所有可能的赋值，直到找到一个解；而 DPLL 算法 则会利用 BCP 来删掉一些不可能满足公式的赋值，缩小搜索树。当遇到冲突时，它会回溯到上一个并非由 BCP 作出的决定，选择另一种可能的值</p><hr><p>Creating all possible resolvents on an atom is very inefficient. The DPLL algorithm improves on the DP algorithm by replacing the variable elimination step with a search for a model of the formula</p><p>The DPLL algorithm recursively <strong>extends a partial interpretation</strong> by <strong>adding an assignment to some atom</strong> that has not yet been assigned a truth value. The current set of clauses is evaluated using the new partial interpretation and simplified by <strong>unit propagation</strong>. If the set of clauses contains a conflict clause, there is no need to continue extending this partial interpretation and the search <strong>backtracks</strong>递归回溯 to try another one</p></blockquote><p>The DPLL algorithm can be summarized in the following pseudocode, where $Φ$ is the <strong>CNF</strong> formula: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Algorithm DPLL</span><br><span class="line">    Input: A set of clauses Φ.</span><br><span class="line">    Output: A truth value indicating whether Φ is satisfiable.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function DPLL(Φ)</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a unit clause &#123;l&#125; <span class="keyword">in</span> Φ do</span><br><span class="line">        Φ ← unit-propagate(l, Φ);</span><br><span class="line">    <span class="keyword">while</span> there <span class="keyword">is</span> a literal l that occurs pure <span class="keyword">in</span> Φ do</span><br><span class="line">        Φ ← pure-literal-assign(l, Φ);</span><br><span class="line">    <span class="keyword">if</span> Φ <span class="keyword">is</span> empty then</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">if</span> Φ contains an empty clause then</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    l ← choose-literal(Φ);</span><br><span class="line">    <span class="keyword">return</span> DPLL(Φ ∧ &#123;l&#125;) <span class="keyword">or</span> DPLL(Φ ∧ &#123;<span class="keyword">not</span>(l)&#125;);</span><br></pre></td></tr></table></figure><ul><li>“←” denotes assignment. For instance, “largest ← item” means that the value of largest changes to the value of item.</li><li>When the formula contains an empty clause, the clause is vacuously false because a disjunction requires at least one member that is true for the overall set to be true</li></ul><hr><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/f363d9fd/4.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/6.jpg" width="650"></center><center><img loading="lazy" src="/posts/f363d9fd/5.jpg" width="650"></center><p><strong>简化版表达</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DPLL:</span><br><span class="line">  Run BCP on the formula.</span><br><span class="line">  If the formula evaluates to <span class="literal">True</span>, <span class="keyword">return</span> <span class="literal">True</span>.</span><br><span class="line">  If the formula evaluates to <span class="literal">False</span>, <span class="keyword">return</span> <span class="literal">False</span>.</span><br><span class="line">  If the formula <span class="keyword">is</span> still Undecided:</span><br><span class="line">    Choose the <span class="built_in">next</span> unassigned variable.</span><br><span class="line">    Return (DPLL <span class="keyword">with</span> that variable <span class="literal">True</span>) || (DPLL <span class="keyword">with</span> that variable <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">DPLL:</span><br><span class="line">  在公式上执行 BCP。</span><br><span class="line">  如果公式的值一定为真，返回真。</span><br><span class="line">  如果公式的值一定为假，返回假。</span><br><span class="line">  如果公式的值仍不确定:</span><br><span class="line">    选择下一个未决定的字面量</span><br><span class="line">    猜测该字面量为真，然后执行 DPLL</span><br><span class="line">    如果 DPLL 的结果为真，返回真</span><br><span class="line">    否则猜测该字面量为假，然后执行 DPLL 并返回结果</span><br></pre></td></tr></table></figure><ul><li>某种程度上看，DDLP &#x3D; Unit Propagation + Decision</li></ul><hr><p><strong>书面写法</strong></p><center><img loading="lazy" src="/posts/f363d9fd/10.jpg" width="650"></center><blockquote><p>Unit Propagation is a <strong>polynomial-time</strong>多项式时间 decision procedure for the <strong>fragment of Horn clauses</strong>.</p></blockquote><center><img loading="lazy" src="/posts/f363d9fd/11.jpg" width="650"></center><ul><li>这也意味着ddlp还要加入<strong>decide</strong>（以及<strong>backtrack</strong>递归回溯）环节使得其可以全面覆盖所有类型的子句</li></ul><center><img loading="lazy" src="/posts/f363d9fd/12.jpg" width="650"></center><p><strong>Example</strong></p><center><img loading="lazy" src="/posts/f363d9fd/13.png" width="650"></center><h2 id="Conflict-Driven-Clause-Learning-CDCL">5. Conflict Driven Clause Learning(CDCL)</h2><ul><li>CDCL&#x3D;DPLL + <strong>Backjumping</strong>后跳 + <strong>Lemma Learning</strong>推理学习</li></ul><blockquote><p>DPLL 有三个缺点。首先，它的决策是朴素（naive）的。其次，它遇到冲突的时候，只知道当前的部分赋值会导致冲突，除此之外学不到任何东西。第三，它每次只会回溯一层，因此会把大量时间浪费在一片必定会失败的搜索空间中</p></blockquote><p><strong>冲突驱动子句学习</strong>的改进：</p><ul><li>冲突来源的子句学习（clause learning from conflicts）</li><li>非时序回溯（non-chronological<code>[ ˌ krɔnə&#39;lɔdʒikəl ]</code> backtracking）</li></ul><center><img loading="lazy" src="/posts/f363d9fd/7.jpg" width="650"></center><ul><li>当CDCL学习一个子句时，它会回溯到该子句的断言层。你可以认为这意味着它回溯到影响所学子句中某一字面量的最新猜测。由于这个子句有$x_1$和$x_5$，而x1是该子句中最新被猜到的一个，所以我们回溯到我们将$x_1$设置为True的时候</li></ul><center><img loading="lazy" src="/posts/f363d9fd/8.jpg" width="650"></center><h3 id="蕴含图">5.1. 蕴含图</h3><ul><li>当 CDCL 遇到冲突时，它会查看已作出的推测，以及从 BCP 得到且最终导致冲突的那些赋值。我们把这些推测和由它们推出的结论画成一个图（graph），称为蕴涵图（implication graph）</li></ul><blockquote><p>蕴含图是一个有向无环图。它的每个顶点代表对一个变量的赋值，此外还有一个代表冲突的特殊顶点。图中的边则表示赋值或冲突的理由；具体来说，如果我们有一个单位子句，并由此推出子句中唯一的那个未知变量的值，就可以从子句中每一个已知的变量对应的顶点连一条边到这个新推导出的变量对应的顶点；推出冲突的情形也类似</p></blockquote><ul><li>一旦 CDCL 学到了一个子句，它就能够回溯超过一层，并把 BCP 立即应用到学到的新子句上。这种利用学到的子句回溯多层的能力就是我们前面说的非时间顺序回溯（non-chronological backtracking）</li></ul><center><img loading="lazy" src="/posts/f363d9fd/9.jpg" width="650"></center><p><strong>clause learning step</strong>:</p><ol><li>c4 is the clause directly responsible for the current conflict. Our partial learned clause is ¬x1 ∨ ¬x6 ∨ ¬x7. </li><li>c3 is the clause responsible for the most recent BCP prior to the conflict, x7 &#x3D; T. Resolving c3 and c4 gives us the partial clause of ¬x1 ∨ ¬x5 ∨ ¬x6. </li><li>c2 is the clause responsible for the next most recent BCP, x6 &#x3D; T. Resolving c2 with our current partial clause gives us ¬x1 ∨ ¬x5.<ol><li>This is our complete learned clause, because there is only one literal at decision level two within it.</li><li>Since x1 has the highest decision level in our new learned clause, we backtrack to that level where we will be able to apply our newly learned clause, c9 &#x3D; ¬x1 ∨ ¬x5</li></ol></li></ol><h3 id="A-note-about-Decision-Heuristics">5.2. A note about Decision Heuristics</h3><blockquote><p>The version of CDCL we implemented in this article does not have any smart <strong>decision heuristics</strong>启发式决策. Better decision heuristics is often the source of breakthroughs SAT Solver performance increases and are very important to modern SAT solvers today. We only examined clause learning and non-chronological backtracking as improvements over DPLL to keep the scope of this project small.</p><p>我们在这篇文章中实现的CDCL版本没有任何智能决策启发式方法。更好的决策启发式往往是SAT求解器性能提高的突破口，对今天的现代SAT求解器非常重要。我们只研究了子句学习和非同步回溯作为对DPLL的改进，以保持这个项目的范围很小。</p></blockquote><h3 id="pseudocode">5.3. pseudocode</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CDCL</span>(<span class="params">ϕ</span>):     // ϕ <span class="keyword">is</span> a CNF formula</span><br><span class="line">   τ←∅</span><br><span class="line">   <span class="keyword">while</span> true:</span><br><span class="line">      τ←unit-propagate(ϕ,τ) // Unit propagation</span><br><span class="line">      <span class="keyword">if</span> τ falsifies a clause:</span><br><span class="line">         <span class="keyword">if</span> at decision level <span class="number">0</span>: <span class="keyword">return</span> unsat</span><br><span class="line">         C←analyze-conflict(ϕ,τ) // Build the learned clause</span><br><span class="line">         ϕ←ϕ∧C // Add it to the formula</span><br><span class="line">         backjump to an earlier decision level according to C</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">all</span> variables have values: <span class="keyword">return</span> sat</span><br><span class="line">         start a new decision level</span><br><span class="line">         choose a literal l such that τ(l) <span class="keyword">is</span> undefined</span><br><span class="line">         τ←τ∪&#123;l&#125; // <span class="string">&quot;Decide&quot;</span> that l <span class="keyword">is</span> true</span><br></pre></td></tr></table></figure><h2 id="Complexity-复杂度">6. Complexity 复杂度</h2><h3 id="P">6.1. P</h3><ul><li>多项式时间复杂性类（Polynomial<code>[ˌpɔli&#39;nəumjəl]</code> time）</li><li>所有P问题都能被经典计算机（非量子计算机）轻松解决</li><li>如果一个问题是P问题，那么它必须满足在多项式时间nc内验证一个算法问题的实例是否<code>有解</code>，<ul><li>n是输入长度</li><li>c是个常数</li></ul></li><li>典型问题：<ul><li>这个数是否是个质数？</li><li>两点之间的最短路径是什么？</li></ul></li></ul><h3 id="np">6.2. np</h3><ul><li>非定常多项式时间复杂性类（Nondeterministic Polynomial time）</li><li>能在多项式时间验证答案<code>正确与否</code>的问题</li><li>算起来不一定快，但对于任何答案我们都可以快速的<strong>验证</strong>这个答案对不对</li></ul><blockquote><p>The method of <strong>truth tables</strong> is a <strong>deterministic</strong> algorithm for deciding both satisfiability and validity in propositional logic. The algorithm is <strong>exponential</strong>, because the size of a formula is polynomial in $n$, the number of variables, while the truth table has $2^n$ rows.</p><p>The method of <strong>semantic tableaux</strong> is a <strong>nondeterministic</strong> algorithm for both satisfiability and validity, because at any stage of the construction, we can choose a leaf to expand and choose a formula in the label of the leaf to which a rule will be applied. Nevertheless, it can be shown that there are families of formulas for which the method of semantic tableaux is <strong>exponential, as are the David-Putnam procedure and resolution</strong></p><p>The problems of deciding <strong>satisfiability</strong> and <strong>validity</strong> in propositional logic are almost certainly intractable: the former is in <strong>np</strong> and the latter in <strong>co-np</strong></p></blockquote><h2 id="Formalising-problems-in-propositional-logic">7. Formalising problems in propositional logic</h2><h3 id="N皇后">7.1. N皇后</h3><center><img loading="lazy" src="/posts/f363d9fd/14.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/15.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/16.png" width="550"></center><h3 id="Encoding-fixed-bit-width-arithmetic">7.2. Encoding fixed bit-width arithmetic</h3><center><img loading="lazy" src="/posts/f363d9fd/17.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/18.png" width="550"></center><h3 id="Linear-in-equalities">7.3. Linear (in)equalities</h3><ul><li>考虑$x + y &#x3D; z$</li></ul><center><img loading="lazy" src="/posts/f363d9fd/19.png" width="550"></center><center><img loading="lazy" src="/posts/f363d9fd/20.png" width="550"></center><ul><li>Linear inequalities</li></ul><center><img loading="lazy" src="/posts/f363d9fd/21.png" width="550"></center><ul><li>Non-linear (in)equalities？</li></ul><h2 id="参考">8. 参考</h2><ul><li><a href="https://cse442-17f.github.io/Conflict-Driven-Clause-Learning/">Conflict Driven Clause Learning</a></li><li><a href="https://zhuanlan.zhihu.com/p/92659252">【试译】冲突驱动子句学习(Conflict Driven Clause Learning) - 知乎</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/f363d9fd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-一阶逻辑-序</title>
      <link>https://hejueyun.github.io/posts/c666161e/</link>
      <guid>https://hejueyun.github.io/posts/c666161e/</guid>
      <pubDate>Sun, 13 Feb 2022 21:39:34 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Orderings-序&quot;&gt;1. Orderings 序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;序是一个关系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A (&lt;strong&gt;strict&lt;/strong&gt;) ordering on a set X is a transitive and irreflexive &lt;strong&gt;binary relation&lt;/strong&gt; on X, here denoted by &lt;code&gt;≻&lt;/code&gt;  （只有严格有序集是要求非自反，即无相等元素的？毕竟相等的话就是multi-set了，并且这个符号也不是$\geq$）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The pair&lt;code&gt; (X, ≻)&lt;/code&gt; is then called &lt;strong&gt;a (strictly) ordered set&lt;/strong&gt;有序集 (感觉有点类似群，只不过群是在集合的基础上定义加乘法，而有序集是在集合的基础上定义了序)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An element x of X is &lt;strong&gt;minimal&lt;/strong&gt; wrt.(with regard to) ≻, if there is no y in X such that &lt;code&gt;x ≻ y&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;minimal&lt;/strong&gt; element x in X is called the &lt;strong&gt;smallest&lt;/strong&gt; (or strictly minimal) element, if for all y ∈ X different from x, y ≻ x.&lt;/li&gt;
&lt;li&gt;Maximal and largest (or strictly maximal) elements are defined analogously(类似的)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;$≺$ for the inverse relation $≻^{−1}$&lt;/li&gt;
&lt;li&gt;x ⪰ y iff either x ≻ y or x &amp;#x3D; y&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In a total ordering if an element is minimal then it is the smallest element.&lt;/li&gt;
&lt;li&gt;In any ordering, the smallest element is unique, if exists&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Strict-partial-order-严格偏序&quot;&gt;1.1. Strict partial order 严格偏序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Irreflexivity: &lt;/li&gt;
&lt;li&gt;Transitivity&lt;/li&gt;
&lt;li&gt;Asymmetry&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Total-order-全序关系&quot;&gt;1.1.1. Total order 全序关系&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;也称linear order线性关系&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/c666161e/2.jpg&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;strict&lt;/strong&gt; total order 则会将reflexive变为irreflexive.&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Orderings-序">1. Orderings 序</h2><p><strong>序是一个关系</strong></p><blockquote><p>A (<strong>strict</strong>) ordering on a set X is a transitive and irreflexive <strong>binary relation</strong> on X, here denoted by <code>≻</code>  （只有严格有序集是要求非自反，即无相等元素的？毕竟相等的话就是multi-set了，并且这个符号也不是$\geq$）</p><ul><li>The pair<code> (X, ≻)</code> is then called <strong>a (strictly) ordered set</strong>有序集 (感觉有点类似群，只不过群是在集合的基础上定义加乘法，而有序集是在集合的基础上定义了序)</li></ul><p>An element x of X is <strong>minimal</strong> wrt.(with regard to) ≻, if there is no y in X such that <code>x ≻ y</code></p><ul><li>A <strong>minimal</strong> element x in X is called the <strong>smallest</strong> (or strictly minimal) element, if for all y ∈ X different from x, y ≻ x.</li><li>Maximal and largest (or strictly maximal) elements are defined analogously(类似的)</li></ul><hr><ul><li>$≺$ for the inverse relation $≻^{−1}$</li><li>x ⪰ y iff either x ≻ y or x &#x3D; y</li></ul></blockquote><ul><li>In a total ordering if an element is minimal then it is the smallest element.</li><li>In any ordering, the smallest element is unique, if exists</li></ul><h3 id="Strict-partial-order-严格偏序">1.1. Strict partial order 严格偏序</h3><ol><li>Irreflexivity: </li><li>Transitivity</li><li>Asymmetry</li></ol><h4 id="Total-order-全序关系">1.1.1. Total order 全序关系</h4><ul><li>也称linear order线性关系</li></ul><center><img loading="lazy" src="/posts/c666161e/2.jpg" width="550"></center><ul><li>A <strong>strict</strong> total order 则会将reflexive变为irreflexive.</li></ul><h3 id="Well-founded-relation-良基关系">1.2. Well-founded relation  良基关系</h3><blockquote><p>A (strict) ordering ≻ over X is called well-founded (or Noetherian or terminating), if there is no infinite decreasing chain x0 ≻ x1 ≻ x2 ≻ . . . of elements xi ∈ X.</p><p><strong><code>(X, ≻)</code> is well-founded iff every non-empty subset Y of X has a minimal element</strong>.</p></blockquote><ul><li>在数学中，类 X 上的一个二元关系 R 被称为是良基的，当且仅当所有 X 的非空子集都有一个 R-极小（注意前提是<strong>有限</strong>有序集）</li></ul><h3 id="Noetherian-Induction-归纳">1.3. Noetherian Induction 归纳</h3><p>Let (X, ≻) be a well-founded ordering, let Q be a property of elements of X.</p><ul><li><strong>If</strong><ul><li>for all x ∈ X the following implication is satisfied<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if Q(y) holds, for all y ∈ X such that x ≻ y,</span><br><span class="line">then Q(x) holds.</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>Then</strong><ul><li>the property Q(x) holds for all x ∈ X</li><li><em>相当于satisfy证valid？</em></li></ul></li></ul><p>Proof：By contradiction反证法</p><blockquote><p>By contradiction.</p><p>Thus, suppose for all x ∈ X the implication above is satisfied, but Q(x) does not hold for all x ∈ X.</p><p>Let A &#x3D; {x ∈ X | Q(x) is false}. Suppose A ̸&#x3D; ∅.</p><p>Since (X, ≻) is well-founded, A has a minimal element x1. Hence for all y ∈ X with x1 ≻ y the property Q(y) holds.</p><p>On the other hand, the implication which is presupposed for this theorem holds in particular also for x1, hence Q(x1) must be true so that x1 cannot belong to A. Contradiction.</p></blockquote><h3 id="Multi-Set-Orderings">1.4. Multi-Set Orderings</h3><p>Let (X, ≻) be an ordering. The multi-set extension $≻_{mul}$ of ≻ to (<strong>finite</strong>) multi-sets over X is defined by</p><ul><li>$S1 ≻_{mul} S2$ ⇐⇒ S1 ̸&#x3D; S2 and ∀x ∈ S2\S1. ∃y ∈ S1\S2. y ≻ x</li></ul><ol><li>Remove common occurrences of elements from S1 and S2. Assume this gives S′&#x3D; S′</li></ol><p>2.Then check that for every element x in S′there is an element y ∈ S′ that is greater than x. Then S1 $≻_mul$ S2.</p><center><img loading="lazy" src="/posts/c666161e/1.jpg" width="550"></center><hr><p>Ordering with one minimal element, but without the smallest element:</p><ul><li>${(0,y)\in {\Bbb{R}}^2: 0&lt;y&lt;1} \cup{} {(1,y)\in {\Bbb{R}}^2: 0\leq y&lt;1}$<ul><li>$(1,0)$ is the one and only one minimal element but not a smallest element</li><li>because it is not related to the elements with $x&#x3D;0$</li></ul></li></ul><h4 id="Properties">1.4.1. Properties</h4><h2 id="Lexicographic-Combination">2. Lexicographic Combination</h2><p>Let (X1, $≻<em>1$), (X2, $≻_2$) be two <strong>orderings</strong>. Lexicographic combination of (X1, ≻1), (X2, ≻2) is an ordering: $≻</em>{lex}&#x3D; ($≻_1$, $≻_2$)lex$ on X1 × X2 such that</p><ul><li>(x1, x2) ≻lex (y1, y2) iff <ul><li>x1 $≻_1$ y1</li><li><strong>or else</strong> x1 &#x3D; y1 and x2 $≻_2$ y2</li></ul></li></ul><h3 id="Properties-1">2.1. Properties</h3><p>Let (X1, $≻_1$), (X2, $≻_2$)) be two orderings. Then</p><ol><li>$≻_lex$ is an ordering.</li><li>if both $≻_1$ and $≻_2$ <strong>well-founded</strong> then $≻_lex$ well-founded.</li><li>if both $≻<em>1$ and $≻_2$ <strong>total</strong> then $≻</em>{lex}$ total.</li></ol><h2 id="ground-literal-and-clause-orderings">3. ground literal and clause orderings</h2><center><img loading="lazy" src="/posts/c666161e/3.png" width="550"></center><ul><li>也就是说命题逻辑中的literal相当于一阶逻辑中的ground literal</li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/c666161e/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-集合论</title>
      <link>https://hejueyun.github.io/posts/301925f/</link>
      <guid>https://hejueyun.github.io/posts/301925f/</guid>
      <pubDate>Thu, 10 Feb 2022 23:11:11 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Sets-集合&quot;&gt;1. Sets 集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;A set is composed of elements . a ∈ S denotes that a is an element of set S&lt;/li&gt;
&lt;li&gt;The set with no elements is the empty set , denoted ∅.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Multi-Sets-多重集&quot;&gt;1.1. Multi-Sets 多重集&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;sets which allow repetition&lt;/li&gt;
&lt;li&gt;$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S&lt;ul&gt;
&lt;li&gt;S &amp;#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then &lt;code&gt;S(a) = 3, S(b) = 2, S(c) = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;denoted: $S: A\rightarrow{Z^{+}}$，A is the underlying set of the multiset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;multi-set S over X is called &lt;strong&gt;finite&lt;/strong&gt;, if &lt;code&gt;&amp;#123; x ∈ X | S(x) &amp;gt; 0&amp;#125;| &amp;lt; ∞&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/5.png&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Set-Operators-集合操作符&quot;&gt;2. Set Operators 集合操作符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S is a subset of T , denoted S ⊆ T , iff every element of S is an element of T , that is, x ∈ S → x ∈ T . S is a proper subset of T , denoted S ⊂ T , iff S ⊆ T and S ≠ T&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union&lt;/strong&gt;联合&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;∪&lt;/code&gt; T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intersection&lt;/strong&gt;交集&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;∩&lt;/code&gt; T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S ∩ T &amp;#x3D;∅ then S and T are disjoint .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difference&lt;/strong&gt;差集&lt;ul&gt;
&lt;li&gt;S &lt;code&gt;−&lt;/code&gt; T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;complement&lt;/strong&gt; 补集&lt;ul&gt;
&lt;li&gt;Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S − T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cartesian product&lt;/strong&gt;笛卡尔积&lt;ul&gt;
&lt;li&gt;Let S and T be sets. S &lt;code&gt;×&lt;/code&gt; T , their Cartesian product , is the set of all pairs ( s , t ) such that s ∈ S and t ∈ T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/301925f/4.gif&quot; width=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Sequences-序列&quot;&gt;3. Sequences 序列&lt;/h2&gt;&lt;p&gt;Let $S$ be a set.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Sets-集合">1. Sets 集合</h2><ul><li>A set is composed of elements . a ∈ S denotes that a is an element of set S</li><li>The set with no elements is the empty set , denoted ∅.</li></ul><h3 id="Multi-Sets-多重集">1.1. Multi-Sets 多重集</h3><ul><li>sets which allow repetition</li><li>$S(x)$ specifies the number of occurrences of the element x (of the base set X) within S<ul><li>S &#x3D; {a, a, a, b, b} is a multi-set over {a, b, c}, then <code>S(a) = 3, S(b) = 2, S(c) = 0</code></li><li>denoted: $S: A\rightarrow{Z^{+}}$，A is the underlying set of the multiset</li></ul></li><li>multi-set S over X is called <strong>finite</strong>, if <code>&#123; x ∈ X | S(x) &gt; 0&#125;| &lt; ∞</code>.</li></ul><center><img loading="lazy" src="/posts/301925f/5.png" width="550px"></center><h2 id="Set-Operators-集合操作符">2. Set Operators 集合操作符</h2><ul><li>Let S and T be sets. S is a subset of T , denoted S ⊆ T , iff every element of S is an element of T , that is, x ∈ S → x ∈ T . S is a proper subset of T , denoted S ⊂ T , iff S ⊆ T and S ≠ T</li><li><strong>Union</strong>联合<ul><li>S <code>∪</code> T , the union of S and T , is the set consisting of those elements which are elements of either S or T (or both).</li></ul></li><li><strong>Intersection</strong>交集<ul><li>S <code>∩</code> T , the intersection of S and T , is the set consisting of those elements which are elements of both S and T . If S ∩ T &#x3D;∅ then S and T are disjoint .</li></ul></li><li><strong>Difference</strong>差集<ul><li>S <code>−</code> T , the difference of S and T , is the set of elements of $S$ that are not elements of $T$</li></ul></li><li><strong>complement</strong> 补集<ul><li>Let S be understood as a universal set; then $\bar{T}$ , the complement of T , is S − T</li></ul></li><li><strong>Cartesian product</strong>笛卡尔积<ul><li>Let S and T be sets. S <code>×</code> T , their Cartesian product , is the set of all pairs ( s , t ) such that s ∈ S and t ∈ T</li></ul></li></ul><center><img loading="lazy" src="/posts/301925f/4.gif" width="550px"></center><h2 id="Sequences-序列">3. Sequences 序列</h2><p>Let $S$ be a set.</p><ul><li>A finite sequence $f$ on $S$ is a function from {0,…, n −1} to $$ . The length of the sequence is n .</li><li>An infinite sequence $f$ on $S$ is a mapping from $N$ to $S$</li></ul><h3 id="tuple-元组">3.1. tuple 元组</h3><ul><li>A finite sequence of length n is an n-tuple</li></ul><h2 id="Relations-and-Functions-关系与函数">4. Relations and Functions 关系与函数</h2><blockquote><p>a relation is a subset of a Cartesian product of sets and a function is a relation with a special property</p><p>关系是集合的笛卡尔积的一个子集，函数是具有特殊属性的关系。</p></blockquote><h3 id="n-ary-relation-n元关系">4.1. n-ary relation n元关系</h3><center><img loading="lazy" src="/posts/301925f/6.png" width="550px"></center><h3 id="Properties-of-Relations-关系的属性">4.2. Properties of Relations 关系的属性</h3><p>Let R be a binary relation on $S^2$ . (Notation: R(x,y) &lt;&#x3D;&gt;  yRx)</p><ul><li>R is reflexive自反 iff R ( x , x ) for all x ∈ S .</li><li>R is symmetric对称 iff R ( $x_1 , x_2$ ) implies R ( $x_1 , x_2$ ).</li><li>Antisymmetric 反对称<ul><li>若对所有的 a 和 b 属于 X，下述语句保持有效，则集合 X 上的二元关系 R 是反对称的：“若 a 关系到 b 且 b 关系到 a，则 a &#x3D; b。” <blockquote><p>注意，<strong>反对称关系不是对称关系（aRb 得到 bRa）的反义</strong>。有些关系既是对称的又是反对称的，比如”等于”（证明：a&#x3D;b推出b&#x3D;a；a&#x3D;b且b&#x3D;a推出a&#x3D;b）；有些关系既不是对称的也不是反对称的，比如”爱上……”（证明：a爱b不能推出b爱a；a爱b且b爱a不能推出a和b是同一个人）</p></blockquote></li></ul></li><li>R is transitive传递 iff R ($x_1 , x_2$ ) and R ( $x_2 , x_3$ ) imply R ( $x_1 , x_3$ ).</li></ul><p>$R^{∗}$ , the <strong>reflexive transitive closure</strong>自反传递闭包 of $R$ , is defined as follows:</p><ul><li>If R ( $x_1 , x_2$ ) then $R^{∗}$ ( $x_1 , x_2$ ).<ul><li>$R\subseteq{R^{*}}$</li></ul></li><li>$R^{∗}$ ( x i , x i ) for all $x_i$ ∈ S .<ul><li>$R^{*}$ is symmetric</li></ul></li><li>$R^{∗}$ ( $x_1 , x_2$ ) and $R^{∗}$ ( $x_2 , x_3$ ) imply $R^{∗}$ ( $x_1 , x_3$ )<ul><li>$R^{*}$ is transitive</li></ul></li></ul><hr><p>Definition. A <strong>transition relation <code>⇒</code></strong> on set S is</p><ul><li><strong>terminating</strong>终止 if there is no infinite s1 ⇒ s2 ⇒ . . . ⇒ sn ⇒ . . ..</li><li><strong>compatible</strong> with an ordering ≻ on S if ⇒⊆≻.<blockquote><p>A transition relation ⇒ is terminating if and only if there is a well-founded ordering ≻ compatible with ⇒</p></blockquote></li></ul><hr><p>symmetric and reflexive but not transitive:</p><ul><li>$R&#x3D;{(a,a),(a,b),(b,a),(b,b),(c,c),(b,c),(c,b)}$<ul><li>满足aRa</li><li>满足aRb→bRa</li><li>不满足aRb,bRc-&gt;cRa</li></ul></li></ul><h3 id="Relation-of-multi-sets">4.3. Relation of multi-sets</h3><p>A and B are multisets in a given universe U, with multiplicity functions $m_a$ and $m_b$</p><ul><li>A is included in B, denoted A ⊆ B, if ${\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.} {\displaystyle m_{A}(x)\leq m_{B}(x)\quad \forall x\in U.}$<br>其余关系定义参考：</li><li>(S1 ∪ S2)(x) &#x3D; S1(x) + S2(x)</li><li>(S1 ∩ S2)(x) &#x3D; min{S1(x), S2(x)}</li><li>(S1\S2)(x) &#x3D; S1(x) − S2(x)</li></ul><h3 id="Functions-函数">4.4. Functions 函数</h3><center><img loading="lazy" src="/posts/301925f/1.jpg" width="550px"></center><ul><li>$x_n$相当于y值</li><li>domain：陪域 range: 值域</li><li>total: 全函数 partial: 部分函数</li></ul><center><img loading="lazy" src="/posts/301925f/3.jpg" width="550px"></center><ul><li>injective单射：指将不同的变量映射到不同的值的函数。</li><li>surjective满射：指陪域等于值域的函数。即：对陪域中任意元素，都存在至少一个定义域中的元素与之对应。</li><li>bijective双射（也称一一对应或一一映射 one-to-one and onto）：既是单射又是满射的函数</li></ul><center><img loading="lazy" src="/posts/301925f/2.png" width="550px"></center><h2 id="Cardinality-势">5. Cardinality 势</h2><ul><li>The cardinality<code>/ˈkɑː.dɪnˈæl.ə.ti/</code> of a set is the <strong>number</strong> of elements in the set</li><li>如果存在着从集合A到集合B的双射，那么集合A与集合B等势，记为A~B</li></ul><h3 id="powerset-幂集">5.1. powerset 幂集</h3><ul><li>The powerset of a set S , denoted $2^S$ , is the set of all subsets of S <ul><li>由该集合全部子集为元素构成的集合</li></ul></li><li>Let S be a finite set of cardinality n ; then the cardinality of its powerset is $2^n$</li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/301925f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-命题逻辑-归结</title>
      <link>https://hejueyun.github.io/posts/f59d8546/</link>
      <guid>https://hejueyun.github.io/posts/f59d8546/</guid>
      <pubDate>Wed, 09 Feb 2022 23:09:30 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;The method of resolution is an efficient method for &lt;strong&gt;searching for a proof&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Reasoning-Methods&quot;&gt;1. Reasoning Methods&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Resolution&lt;/li&gt;
&lt;li&gt;DPLL&amp;#x2F;CDCL&lt;/li&gt;
&lt;li&gt;Tableaux&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A refutational reasoning反驳性推理 method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either “satisfiable”, “unsatisfiable” or “don’t know”&lt;/p&gt;
&lt;h3 id=&quot;soundness&quot;&gt;1.1. soundness&lt;/h3&gt;&lt;p&gt;Consider &lt;strong&gt;a set of formulas&lt;/strong&gt; Φ (usually called a &lt;strong&gt;fragment&lt;/strong&gt;).&lt;br&gt;A reasoning method &lt;strong&gt;RM&lt;/strong&gt; is sound for Φ if for any set S ⊆ Φ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if RM(S) is “satisfiable” then there is an interpretation satisfying all formulas in S&lt;/li&gt;
&lt;li&gt;if RM(S) is “unsatisfiable” then there is no interpretation satisfying all formulas in S.&lt;/li&gt;
&lt;li&gt;A trivial琐碎 RM which on all inputs returns “don’t know” is a sound reasoning method&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Completeness&quot;&gt;1.2. Completeness&lt;/h3&gt;&lt;p&gt;A reasoning method RM is &lt;strong&gt;(refutationally) complete&lt;/strong&gt; for Φ if for any set&lt;br&gt;S ⊆ Φ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if S is unsatisfiable then RM(S) is terminating and returns “unsatisfiable”&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>The method of resolution is an efficient method for <strong>searching for a proof</strong>.</p></blockquote><h2 id="Reasoning-Methods">1. Reasoning Methods</h2><ul><li>Resolution</li><li>DPLL&#x2F;CDCL</li><li>Tableaux</li></ul><p>A refutational reasoning反驳性推理 method (or just reasoning method RM) is an algorithm (not necessarily terminating) which given as an input a set of formulas S outputs either “satisfiable”, “unsatisfiable” or “don’t know”</p><h3 id="soundness">1.1. soundness</h3><p>Consider <strong>a set of formulas</strong> Φ (usually called a <strong>fragment</strong>).<br>A reasoning method <strong>RM</strong> is sound for Φ if for any set S ⊆ Φ:</p><ul><li>if RM(S) is “satisfiable” then there is an interpretation satisfying all formulas in S</li><li>if RM(S) is “unsatisfiable” then there is no interpretation satisfying all formulas in S.</li><li>A trivial琐碎 RM which on all inputs returns “don’t know” is a sound reasoning method</li></ul><h3 id="Completeness">1.2. Completeness</h3><p>A reasoning method RM is <strong>(refutationally) complete</strong> for Φ if for any set<br>S ⊆ Φ:</p><ul><li>if S is unsatisfiable then RM(S) is terminating and returns “unsatisfiable”</li></ul><h3 id="Trivialism-琐碎论">1.3. Trivialism 琐碎论</h3><ul><li>琐碎论是一承认所有语句（也称为命题）为真并且所有“P与非P”形式的矛盾句都为真的逻辑理论</li><li>P当且仅当P为真</li></ul><h2 id="Clause-子句">2. Clause 子句</h2><p>Clause: a disjunction析取 $L_1 ∨ . . . ∨ L_n$, n ≥ 0 of literals.</p><ul><li>A clause can be seen as a mulit-set of literals ${L_1, . . . , L_n}$</li><li><strong>Empty clause</strong>, denoted by <code>⊥: n = 0 </code>(also denoted as <code>□</code>, the empty clause is false in every interpretation)</li><li><strong>Unit clause</strong>单位子句: n &#x3D; 1<ul><li>A clause is unit under a partial assignment when that assignment makes every literal in the clause unsatisfied but leaves a single literal undecided</li><li>如果一个子句中，除了一个未决定的字面量，所有字面量都已经确定为假，我们就称这个子句为“单位子句”</li></ul></li><li><strong>Trivial Clauses</strong><ul><li>clause if trivial if it contains a pair of clashing冲突的 literals. </li><li>Since a trivial clause is valid ($p∨¬ p ≡ T$), <strong>it can be removed from a set of clauses without changing the truth value of the formula</strong>.</li></ul></li><li>A formula is considered to be an implicit conjunction of its clauses</li><li>The formula that is the empty set of clauses is denoted by ∅.</li></ul><center><img loading="lazy" src="/posts/f59d8546/1.png" width="550"></center><ul><li><p>也就是公式形式vs集合形式</p></li><li><p>Clausal form of a formula A: a set of clauses which is satisfiable if and only if A is satisfiable.</p></li><li><p>Clausal form of a set S of formulas: a set of clauses which is satisfiable if and only if so is S.</p></li></ul><h3 id="Horn-Clauses-霍恩子句">2.1. Horn Clauses 霍恩子句</h3><p>霍恩子句（Horn Clause）是带有最多一个肯定文字的子句</p><ul><li>一个霍恩子句的例子：${\displaystyle \neg p\lor \neg q\vee \cdots \vee \neg t\vee u}$ </li><li>它可以被等价地写为：${\displaystyle (p\wedge q\wedge \cdots \wedge t)\rightarrow u}$</li></ul><h3 id="Definitional-Clausal-Form-Transformation">2.2. Definitional Clausal Form Transformation</h3><center><img loading="lazy" src="/posts/f59d8546/5.png" width="550"></center><ol><li>Take all subformulas that are not literals</li><li>Introduce names for these formulas. Note we do not introduce names for literals.</li><li>Introduce definitions.</li><li>Convert resulting formulas into CNF using the standard transformation</li></ol><h2 id="Conjunctive-Normal-Form-合取范式">3. Conjunctive Normal Form 合取范式</h2><blockquote><p>写成合取范式的公式由一些子句（clause）相<strong>与（AND, $\lor$()）</strong>而成；子句则是由字面量（literal）相<strong>或（OR, $\land{}$)</strong> 而成；每个字面量就是一个变量，或者由变量 <strong>取非($\lnot{}$)</strong> 得到</p><ul><li>由于这样的公式只是一些子句“与”起来，为使<strong>公式</strong>满足，每个<strong>子句</strong>也都必须得到满足；</li><li>由于每个子句只是一些字面量“或”起来，只要满足了一个<strong>字面量</strong>就满足了整个<strong>子句</strong></li></ul></blockquote><p>A formula is in conjunctive normal form (CNF) iff it is a conjunction of disjunctions of <strong>字面量literals</strong></p><ul><li>在布尔逻辑中，如果一个公式是<strong>子句clause</strong>的合取(conjucntion)</li></ul><center><img loading="lazy" src="/posts/f59d8546/2.png" width="550"></center><ul><li>Every formula in propositional logic can be transformed into an equivalent formula in CNF</li></ul><center><img loading="lazy" src="/posts/f59d8546/3.png" width="550"></center><ul><li>A formula is in 3CNF iff it is in CNF and each disjunction has exactly three literals.</li></ul><p>推导例子</p><center><img loading="lazy" src="/posts/f59d8546/4.png" width="550"></center><ul><li>cnf cannot avoid exponential blowup<ul><li>Approach: relax requirement of equivalence preserving to equisatisfiability preserving</li><li>也就是重命名（比如n&#x3D;$p_1\leftrightarrow{p_2}$）</li></ul></li></ul><h2 id="Resolution-Rule-归结原理">4. Resolution Rule 归结原理</h2><p>Propositional Resolution inference system BR, consists of the following inference rules</p><center><img loading="lazy" src="/posts/f59d8546/6.png" width="550"></center><p>example</p><center><img loading="lazy" src="/posts/f59d8546/7.png" width="550"></center><h3 id="Tree-vs-Linear">4.1. Tree vs Linear</h3><center><img loading="lazy" src="/posts/f59d8546/9.png" width="550"></center><h2 id="inference-推理">5. inference 推理</h2><center><img loading="lazy" src="/posts/f59d8546/8.png" width="550"></center><ul><li>premises前提: known or assumed to be true</li><li>conclusion结论</li><li>An inference rule <code>R</code> is a set of inferences.</li><li>An inference system, (or a calculus演算) <code>I</code> is a set of inference rules.</li></ul><h3 id="sound">5.1. sound</h3><ul><li>An inference system is sound if all its inference rules are sound</li><li>If an inference system $I$ is sound then for any set of formulas S:<ul><li>$S ⊢_I ⊥$ implies $S ⊨ ⊥$</li></ul></li></ul><h3 id="completeness">5.2. completeness</h3><ul><li>An inference system $I$ is refutationally complete if for any set of formulas S we have<ul><li>$S ⊨ ⊥$ implies $S ⊢_I ⊥$</li></ul></li></ul><h2 id="Simplification-rules-化简规则">6. Simplification rules 化简规则</h2><blockquote><p>to remove clauses in the saturation process without affecting neither soundness nor completeness</p></blockquote><h3 id="derived-and-saturated">6.1. derived and saturated</h3><ul><li>⊥ is <strong>derived</strong> &#x3D;&#x3D; $⊥ ∈ S_n$ for some n</li><li>no new clauses can be derived from S and ⊥ ̸∈ S, then S is <strong>saturated</strong>; in this case S is satisfiable</li></ul><h3 id="Rule-Tautology-elimination-TE">6.2. Rule: Tautology elimination (TE)</h3><ul><li><code>S ⇒ S \ &#123;C&#125;</code> <ul><li>where C is a tautology (⊨ C)</li></ul></li></ul><h3 id="Rule-Subsumption-Elimination-SE">6.3. Rule: Subsumption Elimination (SE)</h3><ul><li><p>A clause C <strong>subsumes</strong>归入 a clause D if C ⊂ D</p></li><li><p><code>S ⇒ S \ &#123;D&#125;</code></p><ul><li>where there is C ∈ S such that C ⊂ D</li></ul></li></ul><center><img loading="lazy" src="/posts/f59d8546/10.png" width="550"></center><ul><li>We say a clause C to is in a <strong>set-reduced</strong> form if every literal occurs no more than once in C. A clause C in a set-reduced from can be seen as <strong>a set of literals</strong> (rather than <strong>a multi-set</strong>).</li><li>BR with eager (BF) and (SE) is a <strong>decision procedure</strong> for propositional logic</li></ul><h2 id="Inference-vs-Deductive-vs-Resolutuion-推论vs演绎vs归结">7. Inference vs Deductive vs Resolutuion 推论vs演绎vs归结</h2><ul><li>We use reasons or reasoning to form inferences which are basically conclusions drawn from propositions or assumptions that are supposed to be true.<ul><li><strong>推论</strong>是从假定为真实的命题(<strong>前提</strong>)得出的<strong>结论</strong></li></ul></li><li>Deduction is a general-to-specific form of reasoning that goes from known truths to specific instances. It starts with a hypothesis and examines the possibilities within that hypothesis to reach a conclusion. Example, in chemistry deducing a chemical equation basis two or more agents.<ul><li><strong>演绎</strong>是一种从一般到具体的推理形式，从已知真理到具体实例</li><li>它从一个假设开始，研究该假设中的各种可能性以得出结论</li></ul></li><li>resolution is <strong>a rule of inference</strong> leading to a <strong>refutation complete theorem-proving technique</strong> for sentences in propositional logic and first-order logic<ul><li><strong>归结</strong>是一种反向证明的方法，是对于命题逻辑和一阶逻辑中的句子的<strong>推理规则</strong></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/f59d8546/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-命题逻辑-演绎</title>
      <link>https://hejueyun.github.io/posts/ec86b407/</link>
      <guid>https://hejueyun.github.io/posts/ec86b407/</guid>
      <pubDate>Mon, 07 Feb 2022 16:16:19 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;形式语言&quot;&gt;1. 形式语言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;语言按照语法分类大致可分为自然语言与形式语言两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;自然语言（Natural Language）就是人类讲的语言，比如汉语、英语等。此类语言不是人为设计的语言，而是自然进化而成的。&lt;/p&gt;
&lt;p&gt;形式语言（Formal Language）是为了满足特定的应用而人为设计的语言。例如数学使用的数字与运算符号、化学使用的分子式。编程语言同样也是一种形式语言，是专门用来表达计算过程的形式语言。&lt;/p&gt;
&lt;p&gt;形式语言有严格的语法（Syntax）规则。语法规则是由符号（Token）与结构（Structure）的规则组成。&lt;/p&gt;
&lt;p&gt;Token 相当于自然语言中的单词与标点、数学式中的数字与运算符。例如 6 &amp;#x3D; 3 + 3$，之所以无法构成一个等式，是因为 $ 符号并不属于合法的 Token 符号。&lt;/p&gt;
&lt;p&gt;结构则是指 Token 的排列方式， 如 3 &amp;#x3D; + 3 虽然加号与等号均为核发的 Token 运算符，但是存在一定的结构错误。&lt;/p&gt;
&lt;p&gt;关于 Token 的规则称为词法（Lexical）规则。而关于结构的规则称为语法（Semantic）规则。&lt;/p&gt;
&lt;p&gt;当阅读一个自然语言句子或是形式语言句子时，首先要明白词法规则（Token），然后需要弄清楚句子的语法结构（如学习阅读外语句子时）。分析句子结构的过程就是解析（Parse）的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;自动机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Deductive-Proof&quot;&gt;2. Deductive Proof&lt;/h2&gt;&lt;p&gt;The deductive systems studiedwere developed in an attempt to formalize mathematical reasoning.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所研究的演绎系统是为了使数学推理正规化而开发的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引入演绎证明方法的意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The set of axioms may be infinite&lt;/li&gt;
&lt;li&gt;Very few logics have decision procedures like propositional logic&lt;/li&gt;
&lt;li&gt;A decision procedure may not give insight into the relationship between the axioms and the theorem&lt;/li&gt;
&lt;li&gt;A decision procedure produces a ‘yes&amp;#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas). Clearly, the millions of mathematical theorems in existence could not have been inferred directly from axioms&lt;ul&gt;
&lt;li&gt;A decision procedure produces a ‘yes&amp;#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="形式语言">1. 形式语言</h2><blockquote><p>语言按照语法分类大致可分为自然语言与形式语言两种。</p></blockquote><blockquote><p>自然语言（Natural Language）就是人类讲的语言，比如汉语、英语等。此类语言不是人为设计的语言，而是自然进化而成的。</p><p>形式语言（Formal Language）是为了满足特定的应用而人为设计的语言。例如数学使用的数字与运算符号、化学使用的分子式。编程语言同样也是一种形式语言，是专门用来表达计算过程的形式语言。</p><p>形式语言有严格的语法（Syntax）规则。语法规则是由符号（Token）与结构（Structure）的规则组成。</p><p>Token 相当于自然语言中的单词与标点、数学式中的数字与运算符。例如 6 &#x3D; 3 + 3$，之所以无法构成一个等式，是因为 $ 符号并不属于合法的 Token 符号。</p><p>结构则是指 Token 的排列方式， 如 3 &#x3D; + 3 虽然加号与等号均为核发的 Token 运算符，但是存在一定的结构错误。</p><p>关于 Token 的规则称为词法（Lexical）规则。而关于结构的规则称为语法（Semantic）规则。</p><p>当阅读一个自然语言句子或是形式语言句子时，首先要明白词法规则（Token），然后需要弄清楚句子的语法结构（如学习阅读外语句子时）。分析句子结构的过程就是解析（Parse）的过程</p></blockquote><p>例如</p><ul><li>正则表达式</li><li>自动机</li></ul><h2 id="Deductive-Proof">2. Deductive Proof</h2><p>The deductive systems studiedwere developed in an attempt to formalize mathematical reasoning.</p><ul><li>所研究的演绎系统是为了使数学推理正规化而开发的。</li></ul><p>引入演绎证明方法的意义</p><ul><li>The set of axioms may be infinite</li><li>Very few logics have decision procedures like propositional logic</li><li>A decision procedure may not give insight into the relationship between the axioms and the theorem</li><li>A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas). Clearly, the millions of mathematical theorems in existence could not have been inferred directly from axioms<ul><li>A decision procedure produces a ‘yes&#x2F;no’ answer, so it is difficult to recognize intermediate results (lemmas)</li></ul></li></ul><p>type</p><ul><li>The second one <strong>$H$</strong> will be familiar because it is a formalization of step-by-step proofs in mathematics: It contains a set of <strong>three</strong> axioms and <strong>one</strong> rule of inference; proofs are constructed as a sequence of formulas, each of which is either an axiom (or a formula that has been previously proved) or a derivation of a formula from previous formulas in the sequence using the rule of inference.</li><li>The system <strong>$G$</strong> will be less familiar because it has one axiom and many rules of inference, but we present it first because it is almost trivial to prove the soundness and completeness of $G$ from its relationship with semantic tableaux</li></ul><h3 id="deductive-system-演绎系统">2.1. deductive system 演绎系统</h3><ul><li>A deductive system is <strong>a set of formulas called axioms</strong> and <strong>a set of rules of inference</strong>.<ul><li><strong>公理axioms</strong>是用来推导其他命题的起点。和<strong>定理Theorem</strong>不同，一个公理（除非有冗余的）不能被其他公理推导出来，否则它就不是起点本身</li><li>A proof in a deductive system is a sequence of formulas $S&#x3D;{A_1,…,A_n}$ such that each formula A i is either an axiom or it can be inferred from <strong>previous formulas</strong> of the sequence $A_{j_1},…A_{j_n}$, where $j_1&lt;⋯&lt;j_k &lt;i$, using a rule of inference. For $A_n$ , the last formula in the sequence, we say that $A_n$ is a <strong>theorem</strong>定理, the sequence S is a proof of $A_n$ , and $A_n$ is <strong>provable</strong>, denoted $⊢A_n$ . If ⊢A, then A <strong>may be used like an axiom</strong> in a <strong>subsequent proof</strong>.<blockquote><p>In proof theory, the turnstile is used to denote “provability” or “derivability”. For example, if T is a formal theory and S is a particular sentence in the language of the theory then T⊢S means that S is provable from T</p></blockquote></li></ul></li><li>if T, then S</li></ul><blockquote><p>一个 <strong>矢列</strong> 是一个二元组 (Γ,∆)，记为 Γ ⊢ ∆，这里 Γ,∆ 为命题的 有穷集合（可为空），称 Γ 为前件，∆ 为后件.命题逻辑的自然推理系统 G′ 由以下公理和规则组成，Γ,∆,Λ,Θ 表示任何命题有穷集合，A,B 表示任何命题，<strong>Γ,A,∆为集合 Γ ∪ {A} ∪ ∆ 的简写</strong>.</p><ul><li>规则的上矢列S1,S2 被称为前提，下矢列S 被称为结论.G′ 中规则被称为推<br>理规则，规则中被作用的命题被称为主命题，而不变的命题被称为辅命题.</li><li>每个公理和规则是模式（schema），它们可有无穷多个实例.</li></ul></blockquote><center><img loading="lazy" src="/posts/ec86b407/2.png" width="550px"></center><p>sequent序贯</p><ul><li>If U and V are (possibly empty) sets of formulas, then U⇒V is a sequent</li></ul><h3 id="演绎vs归纳">2.2. 演绎vs归纳</h3><ul><li>参考：<a href="https://zhuanlan.zhihu.com/p/98979189">初等几何笔记：希尔伯特的公理体系—第 1 章 破晓：在欧几里得之前 - 遇见数学的文章 - 知乎</a></li></ul><h2 id="Gentzen-System">3. Gentzen System</h2><p><strong>相继式演算</strong>（<strong>Sequent calculus</strong>，又译矢列演算、矢列式演算、序贯演算）</p><ul><li><strong>An axiom of $G$ is a set of literals U containing a complementary pair</strong>. Rule of inference are used to infer a set of formulas U from one or two other sets of formulas U 1 and U 2; there are two types of rules</li><li>Let ${α_1,α_2}\subseteq{U_1}$ and let $U_1’&#x3D;U_1-{α_1,α_2}$. Then $U&#x3D;U_1’\cup{α}$  can be inferred</li><li>Let ${β_1}⊆U_1$, ${β_2}⊆U_2$ and let $U_1’&#x3D;U_1-{β_1}$, $U_2’&#x3D;U_2-{β_2}$. Then $U&#x3D;U_1’\cup{U_2’}\cup$ can be inferred.</li></ul><center><img loading="lazy" src="/posts/ec86b407/3.gif" width="550px"></center><ul><li><p>The set or sets of formulas $U_1,U_2$ are the premises前提 and set of formulas U that is inferred is the conclusion结论</p></li><li><p>A set of formulas $U$ that is an axiom or a conclusion is said <strong>to be proved</strong>, denoted <code>⊢U</code></p><ul><li>这个符号因为名叫turnstile闸机</li></ul></li><li><p>$⊢A$</p><ul><li>I know A is true</li><li>A is a theorem in the system</li></ul></li><li><p>$P⊢Q$</p><ul><li>From P, I know that Q</li><li>Q is derivable from P in the system 衍生</li><li>P is provable from Q 证明</li></ul></li><li><p>The following notation is used for <strong>rules of inference</strong>:</p></li></ul><center><img loading="lazy" src="/posts/ec86b407/1.gif" width="550px"></center><ul><li>Prove ⊢(p∨q)→(q∨p) in G</li></ul><center><img loading="lazy" src="/posts/ec86b407/4.gif" width="550px"></center><h3 id="vs-Semantic-Tableaux">3.1. vs Semantic Tableaux</h3><ul><li>上下翻转</li></ul><center><img loading="lazy" src="/posts/ec86b407/5.gif" width="550px"></center><ul><li>Let A be a formula in propositional logic. Then ⊢A in $G$  if and only if there is a closed semantic tableau for ¬ A.<ul><li>当且仅当语义树叶子结点全部时互补文字集时，公式才可证</li></ul></li></ul><h3 id="⊨-vs-⊢-（蕴含-vs-可证）">3.2. ⊨ vs ⊢ （蕴含 vs 可证）</h3><p>⊨A if and only if ⊢A in $G$.</p><ul><li>A为真当且仅当A可证<blockquote><p>A is valid iff ¬ A is unsatisfiable iff there is a closed semantic tableau for ¬ A iff there is a proof of A in $G$</p></blockquote></li></ul><center><img loading="lazy" src="/posts/ec86b407/6.jpg" width="550px"></center><p><em>想像文氏图有助于理解，下图为蕴含</em></p><center><img loading="lazy" src="/posts/ec86b407/9.png" width="550px"></center><ul><li>Soundness：若 Γ ⊢ ∆ 在 G′ 中可证，则 Γ ⊢ ∆ 有效</li><li>completeness：若 Γ ⊢ ∆ 有效，则 Γ ⊢ ∆ 在 G′ 中可证.这就是 G′ 的完全性</li></ul><h3 id="⊨-vs-⊢-vs-→">3.3. ⊨ vs ⊢ vs →</h3><ul><li>$a⊢b&#x3D; ⊢a\rightarrow{b}$</li><li>$a⊢b&#x3D; ⊨a\rightarrow{b}$</li></ul><blockquote><p>注意<code>⊧</code>不是<strong>该语言</strong>中的符号，而是在上层语言 (meta-language) 中.在上层语言中，人们也需要用联结词如 iff，not，and，or，imply 等</p><p>上层语言是一种用于描述另一种语言的语言</p></blockquote><h2 id="Hilbert-System">4. Hilbert System</h2><blockquote><p>In Gentzen systems there is one axiom and many rules of inference, while in a Hilbert system there are several axioms but only one rule of inference. </p><p>在Gentzen系统中，有一个公理和许多推理规则，而在Hilbert系统中，有几个公理但只有一个推理规则</p></blockquote><ul><li>axioms：</li></ul><center><img loading="lazy" src="/posts/ec86b407/8.gif" width="550px"></center><ul><li>rule of inference： <strong>modus ponens</strong>辩证法<ul><li>the formula B can be inferred from A and A→B</li></ul></li></ul><center><img loading="lazy" src="/posts/ec86b407/7.gif" width="550px"></center><ul><li>实际上就是**Binary Resolution(BR)**归结的特例</li></ul><center><img loading="lazy" src="/posts/ec86b407/10.jpg" width="450px"></center><h2 id="相继式演绎-vs-希尔伯特演绎">5. 相继式演绎 vs 希尔伯特演绎</h2><blockquote><p>Both the deductive systems  and  are sound and complete. Completeness of  follows directly from the completeness of the method of semantic tableaux as a decision procedure for satisfiability and validity in propositional logic. However, the method of semantic tableaux is not very efficient.</p></blockquote><h2 id="参考">6. 参考</h2><ul><li><a href="https://yaojianqun.com/index.php/2021/04/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80/">形式语言 - 留白</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/ec86b407/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机数理逻辑-命题逻辑-语法与语义</title>
      <link>https://hejueyun.github.io/posts/cacbbbdb/</link>
      <guid>https://hejueyun.github.io/posts/cacbbbdb/</guid>
      <pubDate>Sat, 05 Feb 2022 23:01:28 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Introduction&quot;&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;Logic formalizes valid methods of reasoning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逻辑将有效的推理方法正规化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比如syllogism&amp;#x2F;ˈsɪləˌdʒɪz(ə)m&amp;#x2F;三段论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;atomic&lt;code&gt;/əˈtɒm.ɪk/&lt;/code&gt; proposition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statements that have no internal structure&lt;/li&gt;
&lt;li&gt;原子命题是没有内部结构的语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cannot be further decomposed&lt;/code&gt; and &lt;code&gt;can be assigned a truth value of true or false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;often shortened to &lt;strong&gt;atoms&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;define the legal structure of formulas in propositional logic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;semantics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the meaning of formulas&lt;ul&gt;
&lt;li&gt;T or F&lt;/li&gt;
&lt;li&gt;Another notation is &lt;code&gt;⊤&lt;/code&gt; for true and &lt;code&gt;⊥&lt;/code&gt; for false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A proof is a deduction of a formula from a set of formulas called &lt;strong&gt;axioms&lt;/strong&gt; using rules of inference.&lt;/li&gt;
&lt;li&gt;证明是&lt;strong&gt;利用推理规则&lt;/strong&gt;从一组称为&lt;strong&gt;公理&lt;/strong&gt;的公式中推导出一个&lt;strong&gt;公式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Propositional logic is central to the design of computer hardware because hardware is usually designed with components having two voltage levels that are arbitrarily assigned the symbols 0 and 1. Circuits&lt;code&gt;/ˈsərkət/&lt;/code&gt; are described by idealized elements called logic gates&lt;/p&gt;
&lt;p&gt;命题逻辑是计算机硬件设计的核心，因为硬件的设计通常有两个电压电平，被任意分配为符号0和1。电路由称为逻辑门的理想化元素描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cacbbbdb/15.png&quot; wid=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h2 id=&quot;Propositional-Formulas命题公式&quot;&gt;2. Propositional Formulas命题公式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;expression&lt;/strong&gt; 表达式&lt;ul&gt;
&lt;li&gt;denoted the computation of a value from other values&lt;/li&gt;
&lt;li&gt;表示从其他数值中计算出一个数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In propositional logic, the term formula is used instead&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;atomic propositions &lt;ul&gt;
&lt;li&gt;An unbounded set of symbols P&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boolean operators&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;subformulas&quot;&gt;2.1. subformulas&lt;/h3&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/cacbbbdb/22.jpg&quot; wid=&quot;550px&quot;&gt;&lt;/center&gt;

&lt;h3 id=&quot;Formulas-as-Trees&quot;&gt;2.2. Formulas as Trees&lt;/h3&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Introduction">1. Introduction</h2><p>Logic formalizes valid methods of reasoning</p><ul><li><p>逻辑将有效的推理方法正规化</p></li><li><p>比如syllogism&#x2F;ˈsɪləˌdʒɪz(ə)m&#x2F;三段论</p></li><li><p><strong>atomic<code>/əˈtɒm.ɪk/</code> proposition</strong></p><ul><li>statements that have no internal structure</li><li>原子命题是没有内部结构的语句</li><li><code>cannot be further decomposed</code> and <code>can be assigned a truth value of true or false</code></li><li>often shortened to <strong>atoms</strong></li></ul></li><li><p><strong>syntax</strong></p><ul><li>define the legal structure of formulas in propositional logic</li></ul></li><li><p><strong>semantics</strong></p><ul><li>the meaning of formulas<ul><li>T or F</li><li>Another notation is <code>⊤</code> for true and <code>⊥</code> for false</li></ul></li></ul></li><li><p><strong>Proof</strong></p><ul><li>A proof is a deduction of a formula from a set of formulas called <strong>axioms</strong> using rules of inference.</li><li>证明是<strong>利用推理规则</strong>从一组称为<strong>公理</strong>的公式中推导出一个<strong>公式</strong></li></ul></li></ul><blockquote><p>Propositional logic is central to the design of computer hardware because hardware is usually designed with components having two voltage levels that are arbitrarily assigned the symbols 0 and 1. Circuits<code>/ˈsərkət/</code> are described by idealized elements called logic gates</p><p>命题逻辑是计算机硬件设计的核心，因为硬件的设计通常有两个电压电平，被任意分配为符号0和1。电路由称为逻辑门的理想化元素描述</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/15.png" wid="550px"></center><h2 id="Propositional-Formulas命题公式">2. Propositional Formulas命题公式</h2><ul><li><strong>expression</strong> 表达式<ul><li>denoted the computation of a value from other values</li><li>表示从其他数值中计算出一个数值</li><li><strong>In propositional logic, the term formula is used instead</strong></li></ul></li><li>atomic propositions <ul><li>An unbounded set of symbols P</li></ul></li><li>Boolean operators</li></ul><h3 id="subformulas">2.1. subformulas</h3><center><img loading="lazy" src="/posts/cacbbbdb/22.jpg" wid="550px"></center><h3 id="Formulas-as-Trees">2.2. Formulas as Trees</h3><center><img loading="lazy" src="/posts/cacbbbdb/1.gif" wid="550px"></center><ul><li>unary<code>/ˈjuːnəri/</code> operator 单目运算符 vs binary operators 双目运算符</li><li>implication 实质条件 <strong>实质</strong>蕴涵 <ul><li>理解为assignment</li><li>若A，则B (要么A为假 要么B为真（或二者同时成立）)</li><li>A $\rightarrow$ B &#x3D;&#x3D; $¬A∨B$ 相当于只是一个简写denote</li><li>区别于<strong>语义</strong>蕴含<code>⊨</code></li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/21.png" wid="550px"></center><ul><li>nor和nand就是在or和and之后再取一次反</li></ul><p>命题逻辑中的公式可以是一棵递归定义的树（defined recursively）</p><ul><li>一个公式是由一个原子命题标记（labeled）的叶子。</li><li>一个公式是一个由¬标记的节点，它的一个子节点是一个公式</li><li>一个公式是一个由二元运算符之一标记的节点，同时两个子节点自身也是公式</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/2.gif" wid="550px"></center><h3 id="Formulas-as-Strings">2.3. Formulas as Strings</h3><p>命题逻辑中的公式也可以是字符串</p><ul><li>The string associated with a formula is obtained by an <strong>inorder traversal</strong><code>/trəˈvərs(ə)l/</code><br> of the tree</li><li>一个公式的字符串表示是通过对树的<strong>中序遍历</strong>得到的<ul><li>先左子树，后根结点，最后右子树</li></ul></li><li>ambiguity <code>/æmbɪˈɡjuːɪti/</code> 模糊性</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/16.png" wid="550px"></center><h3 id="Resolving-Ambiguity-in-the-String-Representation">2.4. Resolving Ambiguity in the String Representation</h3><p><strong>parentheses</strong><code>/pəˈrenθəsiːz/</code> 圆括号</p><ul><li>The simplest way to avoid ambiguity is to use parenthesesto maintain the structure of the tree when the string is constructed.</li><li>避免歧义的最简单方法是在构建字符串时使用<strong>圆括号</strong>来保持树的结构</li><li>缺点：verbose冗长 and hard to read and write</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/3.gif" wid="550px"></center><p><strong>Precedence<code>/ˈpresɪdəns/</code></strong> 优先级</p><ul><li>define precedence and associativity conventions among the operators as is done in arithmetic, so that we immediately recognize <code>a∗b∗c+d∗e</code> as <code>(((a∗b)∗c)+(d∗e))</code><ul><li>解决模棱两可的公式的第二种方法是在运算符之间定义优先级和关联性约定，就像在算术中所做的那样，这样我们就可以立即将<code>a∗b∗c+d∗e</code>识别为<code>(((a∗b)∗c)+(d∗e))</code></li></ul></li><li>Parentheses are used only if needed to indicate an order different from that imposed by the rules for precedence and associativity<ul><li>只有在需要表示与优先权和关联性规则所规定的顺序不同时，才使用括号</li></ul></li><li>precedence from high to low</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/4.gif" wid="550px"></center><p><strong>Polish Notation</strong> 波兰式（前缀表示法）和 <strong>reverse Polish notation</strong> 逆波兰式（后缀表示法）</p><blockquote><p>波兰表达式和逆波兰表达式有个好处，就算将圆括号去掉也没有歧义</p><p>逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入 栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值</p></blockquote><ul><li>用于简化命题逻辑</li><li><strong>先序遍历</strong> preorder<ul><li>表达式<code>a*(b+c)-e/f</code><ul><li>中序遍历，就是日常用的表达式写法。对于加法和减法需要加括号。</li><li>用前序遍历，对应前缀表达式：<code>-*a+bc/ef</code></li><li>用后序遍历，对应后缀表达式：<code>abc+*ef/-</code></li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/5.svg" wid="550px"></center><h3 id="Structural-induction-结构归纳法">2.5. Structural induction 结构归纳法</h3><blockquote><p>Structural induction is used to prove that a property holds for all formulas. This form of induction is similar to the familiar numerical induction that is used to prove that a property holds for all natural numbers</p><p>结构归纳法被用来证明一个属性对所有公式都成立。这种形式的归纳法类似于我们熟悉的数字归纳法，后者是用来证明一个属性对所有自然数都成立的</p></blockquote><p>To show that a property holds for all formulas $A\in{F}$ :</p><ol><li>Prove that the property holds all atoms $p$.</li><li>Assume that the property holds for a formula $A$ and prove that the property holds for $¬A$.</li><li>Assume that the property holds for formulas $A_1$ and $A_2$ and prove that the property holds for $A_1 op A_2$, for each of the binary operators.</li></ol><blockquote><p> so a proof that a property holds for all formulas can be done using structural induction with the base case and only two <strong>inductive</strong> steps. 一个初始例子和两个归纳步骤</p></blockquote><h2 id="Interpretations-解释">3. Interpretations 解释</h2><p>一个<strong>函数</strong></p><ul><li>An interpretation for A is a total function $I_A:P_A \rightarrow{ { T,F } }$ that <strong>assigns</strong> one of the truth values T or F to every atom in $P_A$, $P_A$ 是 $A$ 的原子命题子集，$A$ 是公式集合 $F$ 中的一个</li><li>An interpretation is a mapping of atomic propositions to the values {T,F}. <ul><li>换句话说解释$I_A$就是“计算并返回A的真值”的函数</li></ul></li></ul><p>true value</p><blockquote><p>a truth value, sometimes called a logical value, is a value indicating the relation of a proposition to truth</p><p>真理值，有时也被称为逻辑值，是一个表明命题与真理关系的数值。</p></blockquote><ul><li>真值表Truth Tables<ul><li>拆分为subformula</li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/8.gif" wid="550px"></center><hr><center><img loading="lazy" src="/posts/cacbbbdb/6.gif" wid="550px"></center><p>设 A 为命题，v 为赋值.</p><ol><li>v 满足 A，记为 v ⊧ A，指 ˆv(A) &#x3D; T；</li><li>A 为永真式 (tautology)，记为 ⊧ A，指对任何 v 有 ˆv(A) &#x3D; T；</li><li>A 可满足指有 v 使 v ⊧ A；</li><li>设 Γ 为命题集，A 为 Γ 的语义结论，记为 Γ ⊧ A，指对所有 v，若对任何 B ∈ Γ 有 ˆv(B) &#x3D; T 则 ˆv(A) &#x3D; T.</li></ol><center><img loading="lazy" src="/posts/cacbbbdb/17.png" wid="550px"></center><h3 id="partial-interpretation">3.1. partial interpretation</h3><ul><li>A partial interpretation for A is a partial function $I_A:P_A\rightarrow{}{T,F}$ that assigns one of the truth values T or F to some of the atoms in $P_A$</li></ul><h3 id="Model">3.2. Model</h3><ul><li>If a formula is true under an interpretation, then that interpretation is called a model of that formula<ul><li>如果一个公式在某个解释下是真的，那么这个解释就被称为该公式的模型</li></ul></li></ul><h3 id="The-Relationship-Between-↔-and-≡">3.3. The Relationship Between ↔ and ≡</h3><ul><li>Equivalence, <code>↔</code>, is a Boolean operator in propositional logic and can appear in formulas of the logic</li><li>Logical equivalence, <code>≡</code>, is <strong>not a Boolean operator</strong>; instead, is a notation for a <strong>property</strong> of pairs of formulas in propositional logic. </li><li>$A_1$≡$A_2$ iff $A_1$↔$A_$2 is true in every interpretation.</li></ul><h3 id="Substitution">3.4. Substitution</h3><p>A is a <strong>subformula</strong> of B if A is a subtree of B. </p><ul><li>If A is not the same as B, it is a <strong>proper subformula</strong> of B.</li></ul><p>B{A←A′}, the substitution of A′ for A in B(在B中用A’代替A), is the formula obtained by replacing all occurrences of the subtree for A in B by A′</p><ul><li>Let A be a subformula of B and let A′ be a formula such that A≡A′. Then B≡B{A←A′}</li></ul><h3 id="law-常用公式与定律">3.5. law 常用公式与定律</h3><ul><li><p>⇔&#x2F;↔ 等价符号</p><ul><li>相当于if and only if</li><li>A ↔ B ≡ (A → B) ∧ (B → A)</li></ul></li><li><p>Idempotent<code>/ˌīdemˈpōt(ə)nt/</code> Law幂等律</p><ul><li>A⇔A∨A</li><li>A⇔A∧A</li></ul></li><li><p>commutative law交换律</p><ul><li>The binary Boolean operators are commutative, <strong>except for implication</strong>.</li><li>A∨B⇔B∨A</li><li>A∧B⇔B∧A</li><li>A↑B⇔B↑A</li></ul></li><li><p>associative law结合律</p><ul><li>(A∨B)∨C⇔A∨(B∨C)</li><li>(A∧B)∧C⇔A∧(B∧C)</li></ul></li><li><p>Distributive law分配律</p><ul><li>A∨(B∧C)⇔(A∨B)∧(A∨C)</li><li>A∧(B∨C)⇔(A∧B)∨(A∧C)</li></ul></li></ul><center><img loading="lazy" src="/posts/cacbbbdb/23.jpg" wid="550px"></center><h2 id="Satisfiability-Validity-and-Consequence">4. Satisfiability, Validity and Consequence</h2><ul><li>A is satisfiable可满足的 iff $v_I(A)&#x3D;T$ for some interpretation . <ul><li>A satisfying interpretation is a model for A.</li></ul></li><li>A is valid有效的, denoted <code>⊨</code>A, iff $v_I(A)&#x3D;T$ for <strong>all</strong> interpretations .<ul><li>A valid propositional formula is also called a tautology永真式（重言式）.</li></ul></li><li>A is unsatisfiable不可满足的 iff it is not satisfiable, that is, if $v_I(A)&#x3D;F$ for all interpretations</li><li>A is falsifiable可证伪的, denoted $\models$ 加上一个左斜杠<code>/</code>, iff it is not valid, that is, if $v_I(A)&#x3D;F$ for some interpretation</li></ul><p>T&#x3D;True F&#x3D;False</p><center><img loading="lazy" src="/posts/cacbbbdb/7.gif" wid="550px"></center><ul><li>A is valid if and only if ¬ A is unsatisfiable. A is satisfiable if and only if ¬ A is falsifiable.</li></ul><hr><p>符号之间的联系</p><ul><li><p>A formula A is valid if and only if ¬A is unsatisfiable.</p><ul><li>⊨ A iff ¬A ⊨ ⊥</li></ul></li><li><p>A formula A is satisfiable if and only if ¬A is not valid.</p></li><li><p>A formula A is valid if and only if A is equivalent to ⊤.</p></li><li><p>Formulas A and B are equivalent if and only if the formula A ↔ B is valid.</p></li><li><p>Propositional satisfiability is NP-complete NP完全（计算复杂度相关）.</p></li><li><p>Propositional validity is coNP-complete.</p></li></ul><h3 id="decision-procedure决定程序">4.1. decision procedure决定程序</h3><ul><li>Let $U\subseteq{F}$ be a set of formulas. An algorithm is a decision procedure for $U$ if given an arbitrary formula $A\in{F}$ , it terminates and returns the answer yes if $A\in{U}$ and the answer no if $A\notin{U}$ .</li><li>If $U$ is the set of satisfiable formulas, a decision procedure for  is called a decision procedure for satisfiability, and similarly for validity <ul><li>如果U是可满足公式的集合，那么一个可满足性的决策程序被称为可满足性的决策程序，同样地，有效性的决策程序也是如此。</li></ul></li><li>A reasoning method RM is a decision procedure for Φ if RM is <strong>sound</strong>, <strong>refutationally complete</strong> and <strong>terminating</strong> for Φ.</li><li>The truth table method is a decision procedure for propositional logic</li></ul><h3 id="Logical-Consequence-蕴涵（结论）">4.2. Logical Consequence 蕴涵（结论）</h3><ul><li>Let U be a set of formulas and A a formula. A is a logical consequence of U, denoted U⊨A, iff every model of U is a model of A<ul><li>集合A蕴涵集合B，当且仅当在其中A中所有句子都为真的所有模型中，在B中的所有句子也是真的</li></ul></li><li>Let <code>A=(p∨r)∧(¬ q∨¬ r)</code>. Then A is a logical consequence of {p,¬ q}, denoted {p,¬ q}⊨A</li></ul><blockquote><p>To see whether a formula F2 is a logical consequence of a formula F1, write out their <strong>joint truth table</strong>. Find the rows in which F1 is true; those are essentially the models that satisfy F1. Check to see whether F2 is also true in all of those rows&#x2F;models; if it is, then every model that satisfies F1 automatically satisfies F2, and F2 is therefore a logical consequence of F1. </p><p>要看一个公式F2是否是公式F1的逻辑结果，请写出它们的联合真值表。找出F1为真的那几行；这些基本上是满足F1的模型。检查F2是否在所有这些行&#x2F;模型中也是真的；如果是，那么每个满足F1的模型都自动满足F2，因此F2是F1的逻辑结果</p></blockquote><blockquote><p>蕴含是讨论“命题和命题之间的真值传递关系的”</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/9.png" wid="550px"></center><ul><li>U⊨A iff ⊨ $⋀_iA_i→A$</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/19.png" wid="550px"></center><blockquote><p>注意<code>⊨</code>不是该语言中的符号，而是在上层语言 (meta-language) 中.在上层语言中，人们也需要用联结词如 iff，not，and，or，imply 等</p></blockquote><h3 id="Logical-Equivalence-逻辑等价性">4.3. Logical Equivalence 逻辑等价性</h3><center><img loading="lazy" src="/posts/cacbbbdb/19.png" wid="550px"></center><h2 id="Semantic-Tableauxta·blowz-语义表">5. Semantic Tableauxta·blowz 语义表</h2><blockquote><p>While truth tables can be used as a decision procedure for the satisfiability or validity of formulas of propositional logic, semantic tableaux are usually much more efficient. In a semantic tableau, a tree is constructed during a search for a model of a formula; the construction is based upon the structure of the formula. A semantic tableau is closed if the formula is unsatisfiable and open if it is satisfiable.</p></blockquote><ul><li>单数形式tableau<code>(/tæˈbloʊ)</code></li><li>an efficient <strong>decision procedure</strong> for <strong>satisfiability</strong> (and by duality <strong>validity</strong>) in <strong>propositional logic</strong></li><li>An analytic tableau is a tree structure computed for a logical formula, having at each node a subformula of the original formula to be proved or refuted. Computation constructs this tree and uses it to prove or refute the whole formula<ul><li>一个分析表是为一个逻辑公式计算的树状结构，在每个节点上都有一个要证明或反驳的原公式的子公式。通过计算构建了这棵树，并使用它来证明或反驳整个公式。</li></ul></li></ul><p>Literal文字 （vs atoms）</p><ul><li>A literal is an <strong>atom</strong> or <strong>the negation of an atom</strong>. An atom is a <strong>positive literal</strong> and the negation of an atom is a <strong>negative literal</strong>. </li><li>For any atom p, {p,¬ p} is a complementary互补的 pair of literals.</li><li>A set of literals is satisfiable if and only if it does not contain a complementary pair of literals.<ul><li>对于A&#x3D;p∧(¬ q∨¬ p)，当且仅当集合{p,¬ p}和{p,¬ q}中至少有一个不包含互补的一对文字时，A是可满足的。显然，只有第二个集合不包含一对互补的文字</li></ul></li></ul><p>Decomposing Formulas into Sets of Literals</p><ul><li>$A&#x3D;p\land{(\lnot{q}\lor{\lnot{p}})}$ &#x3D;&gt; literal&#x3D;{p,¬ q}</li></ul><p>求解规则</p><ol><li>拆分</li></ol><center><img loading="lazy" src="/posts/cacbbbdb/10.png" wid="550px"></center><ol start="2"><li>A set of literals is satisfiable if and only if it does not contain a complementary pair of literals<ol><li>一个文字集是可满足的，当且仅当它不包含一对互补的文字的时候</li><li>在上面的例子中{p,¬ p}因此被排除</li></ol></li></ol><blockquote><p>（另一个例子）Both sets of literals {p,¬ p,¬ q} and {q,¬ p,¬ q} contain complementary pairs, so by Theorem 2.60, both set of literals are unsatisfiable. We conclude that it is impossible to find a model for B; in other words, B is unsatisfiable</p></blockquote><h3 id="Construction-of-Semantic-Tableaux">5.1. Construction of Semantic Tableaux</h3><blockquote><p>The initial formula labels the root of the tree; each node has one or two child nodes depending on how a formula labeling the node is decomposed. The leaves are labeled by the sets of literals. A leaf labeled by a set of literals containing a complementary pair of literals is marked ×, while a leaf labeled by a set not containing a complementary pair is marked ⊙</p><ul><li>初始公式标注为树的根部；</li><li>每个节点有一个或两个子节点，取决于标注节点的公式是如何分解的。</li><li>叶子是由文字集标记的。由包含互补对的文字集标注的叶子被标记为<code>×</code>（也就是closed），而由不包含互补对的文字集标注的叶子被标记为<code>⊙</code>(也就是open)</li></ul></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/11.gif" wid="550px"></center><ul><li>The tableau construction is not unique; here is another tableau for B</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/12.gif" wid="550px"></center><ul><li>α-formulas are conjunctive and are satisfiable only if both subformulas $α_1$ and $α_2$ are satisfied </li><li>β-formulas are disjunctive and are satisfied even if only one of the subformulas $β_1$ or $β_2$ is satisfiable</li></ul><blockquote><p>The formula p∧q is classified as an α-formula because it is true if and only if both p and q are true. The formula ¬ (p∧q) is classified as a β-formula. It is logically equivalent to ¬ p∨¬ q and is true if and only if either ¬ p is true or ¬ q is true.</p></blockquote><center><img loading="lazy" src="/posts/cacbbbdb/13.gif" wid="550px"></center><p>构建语义表的算法</p><center><img loading="lazy" src="/posts/cacbbbdb/14.png" wid="550px"></center><ul><li>A <strong>completed tableau</strong> is closed if all its leaves are marked closed. Otherwise (if some leaf is marked open), it is open</li></ul><h2 id="Soundness-and-Completeness-可靠性和完备性">6. Soundness and Completeness 可靠性和完备性</h2><ul><li>We need to prove that the algorithm for semantic tableaux is sound and complete as a decision procedure for satisfiability</li><li>** Soundness means that you cannot prove anything that’s wrong. Completeness means that you can prove anything that’s right**<blockquote><ul><li>Soundness is the property of only being able to prove “true” things.</li><li>Completeness is the property of being able to prove all true things.<br>So a given logical system is sound if and only if the inference rules of the system admit only valid formulas. Or another way, if we start with valid premises, the inference rules do not allow an invalid conclusion to be drawn.</li></ul><p>A system is complete if and only if all valid formula can be derived from the axioms and the inference rules. So there are no valid formula that we can’t prove</p></blockquote></li></ul><h3 id="Soundness">6.1. Soundness</h3><p>The theorem to be proved is: if the tableau  for a formula A closes, then A is unsatisfiable.</p><ul><li>if $T_n$, the subtree rooted at node n of $T$, closes then the set of formulas U(n) labeling n is unsatisfiable</li></ul><h3 id="Completeness">6.2. Completeness</h3><p>if A is unsatisfiable then every tableau for A closes</p><ul><li>let A&#x3D;p∨(q∧¬ q)</li></ul><center><img loading="lazy" src="/posts/cacbbbdb/20.gif" wid="550px"></center><blockquote><p>The open branch of the tableau terminates in a leaf labeled with the singleton set of literals ${p}$. We can conclude that any model for A must define $I(p)&#x3D;T$. However, an interpretation for A must also define an assignment to q and the leaf gives us no guidance as to which value to choose for $I(q)$. But it is obvious that it doesn’t matter what value is assigned to q; in either case, the interpretation will be a model of A</p></blockquote><h3 id="Refutation-completeness-反向的完备性">6.3. Refutation completeness 反向的完备性</h3><ul><li>A formal system S is refutation-complete if it is able to derive false from every unsatisfiable set of formulas</li></ul><h2 id="formula-in-propositonal-logic">7. formula in propositonal logic</h2><p>一种说法</p><blockquote><p>In propositional logic there are no formulæ. There are only atomic and compound propositions.</p></blockquote><ul><li>The atomic propositions are the propositional variables, often written as A,B,C,etc</li><li>Compound propositions are formed using atomic propositions and logical connectives. These connectives include things like not, implies, and, or, etc.<blockquote><p>It is only in first order logic that we need the notion of formulæ. This is because in first order logic, we don’t only consider propositions but also ‘objects’ and predicates on ‘objects’. First Order logic includes a sub-language to express these ‘objects’ and operations on these ‘objects’.</p></blockquote></li></ul><p>符合教材的说法是</p><ul><li>公式可以正确的，也可以是<strong>错误的</strong>（在语法与语义上？）</li><li>但命题一定是一个格式正确的公式 ，在命题逻辑中，这意味着它既是由逻辑在句法上定义的，又具有用于其语义评估的真值表。<ul><li>语法定义了哪些符号串构成合法的公式（就语言而言是合法的程序）</li><li>而语义定义了合法公式的含义（合法程序的计算）<ul><li>语义表时检测公式是否为真的有效的决策程</li></ul></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Automated-Reasoning/">Automated Reasoning</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/cacbbbdb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>软件安全备忘录：Fundamentals</title>
      <link>https://hejueyun.github.io/posts/a3244b40/</link>
      <guid>https://hejueyun.github.io/posts/a3244b40/</guid>
      <pubDate>Mon, 31 Jan 2022 20:12:07 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Main-Goal&quot;&gt;1. Main Goal&lt;/h2&gt;&lt;p&gt;Verified trustworthy software systems 经过验证的值得信赖的软件系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reliability&lt;/li&gt;
&lt;li&gt;Availability&lt;/li&gt;
&lt;li&gt;Safty&lt;/li&gt;
&lt;li&gt;Resilience 复原能力&lt;ul&gt;
&lt;li&gt;in timely response to events&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Standard-Notions-of-Security-安全的标准概念&quot;&gt;2. Standard Notions of Security 安全的标准概念&lt;/h2&gt;&lt;p&gt;Safety vs Security&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safety: &lt;code&gt;any input&lt;/code&gt; &amp;#x3D;&amp;gt; &lt;code&gt;desired output&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Secruity: &lt;code&gt;bad input&lt;/code&gt; &amp;#x3D;&amp;gt; &lt;code&gt;bad output&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;wrong input does not cause failure or crashes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;most sofeware system do not have precise准确 explict明确 security objectives&lt;/p&gt;
&lt;h2 id=&quot;Software-Security-Problems&quot;&gt;3. Software Security Problems&lt;/h2&gt;&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/a3244b40/1.png&quot; width=&quot;550&quot;&gt;&lt;/center&gt;

&lt;p&gt;Why are there security vulnerabilities?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Main-Goal">1. Main Goal</h2><p>Verified trustworthy software systems 经过验证的值得信赖的软件系统</p><ul><li>Reliability</li><li>Availability</li><li>Safty</li><li>Resilience 复原能力<ul><li>in timely response to events</li></ul></li></ul><h2 id="Standard-Notions-of-Security-安全的标准概念">2. Standard Notions of Security 安全的标准概念</h2><p>Safety vs Security</p><ul><li>Safety: <code>any input</code> &#x3D;&gt; <code>desired output</code></li><li>Secruity: <code>bad input</code> &#x3D;&gt; <code>bad output</code><ul><li>wrong input does not cause failure or crashes</li></ul></li></ul><p>most sofeware system do not have precise准确 explict明确 security objectives</p><h2 id="Software-Security-Problems">3. Software Security Problems</h2><center><img loading="lazy" src="/posts/a3244b40/1.png" width="550"></center><p>Why are there security vulnerabilities?</p><ul><li>Limited number of <strong>courses</strong> in computer security<br>– Programming <strong>textbooks</strong> do not emphasize security<br>– Limited number of security <strong>audits</strong><br>– <strong>Programmers</strong> are focused on implementing features<br>– Security is <strong>expensive</strong> and takes <strong>time</strong></li></ul><p>cve</p><ul><li>Common Vulnerabilities and Exposures 公共漏洞和暴露 <blockquote><p>公共漏洞和暴露又称通用漏洞披露、常见漏洞与披露，是一个与信息安全有关的数据库，收集各种信息安全弱点及漏洞并给予编号以便于公众查阅。此数据库现由美国非营利组织MITRE所属的National Cybersecurity FFRDC所营运维护</p></blockquote></li></ul><h3 id="Critical-Software-Vulnerabilitie">3.1. Critical Software Vulnerabilitie</h3><ul><li><strong>Null pointer dereference</strong><ul><li>dereference 解引用<ul><li>“*”（即星号），是一个单项操作符（即有一个操作数）</li><li>它对一个指针变量进行操作，并返回一个指针地址的值</li></ul></li></ul></li></ul><center><img loading="lazy" src="/posts/a3244b40/2.png" width="550"></center><ul><li><strong>Double free</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/3.png" width="550"></center><ul><li><strong>Unchecked Return Value to NULL Pointer Dereference</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/4.png" width="550"></center><ul><li>Division by zero</li><li>Missing free</li><li>Use after free</li><li>APIs rule based checking</li><li><strong>Race Condition Vulnerability</strong> 竞争条件漏洞</li><li>Structured output generation vulnerabilitie<ul><li>SQL Injection</li></ul></li><li>XSS</li><li>XXE <ul><li>XML External Entity (XXE) </li><li>XXE occurs when XML input (incl. an external entity) is processed by a weakly configured XML parser</li><li>XXE might lead to the disclosure披露 of confidential data</li></ul></li></ul><center><img loading="lazy" src="/posts/a3244b40/5.png" width="550"></center><ul><li>DoS</li></ul><h2 id="testing-and-verification-techniques-–-two-approaches">4. testing and verification techniques – two approaches</h2><h3 id="proof-by-induction-数学归纳法">4.1. proof by induction 数学归纳法</h3><ul><li>base step</li><li>inductice step</li></ul><h3 id="Temporal-Logic-Model-Checking-时态逻辑模型检查">4.2. Temporal Logic Model Checking 时态逻辑模型检查</h3><p>2 branches of verification</p><ul><li><p>deductive 演绎式</p></li><li><p>Model checking</p><ul><li>可以automatic</li></ul></li><li><p>Verification procedure is algorithmic rather than deductive in nature</p><ul><li>验证程序是算法性的，而不是演绎性的</li></ul></li><li><p>The assertions written as formulas in propositional temporal logice</p></li></ul><p><code>Model checking</code></p><ul><li>an automatic verification technique for <strong>finite state concurrent systems</strong>并发系统<ul><li>模型检查是一种<strong>有限状态并发系统</strong>的自动验证技术<h4 id="Advantages">4.2.1. Advantages</h4></li></ul></li><li><strong>No proofs</strong>(Algorithmic rather than Deductive)</li><li><strong>Fast</strong> (compared to other rigorous methods such as theorem proving) 与其他严格的方法相比，如定理证明</li><li>Diagnostic <strong>counterexamples</strong> 诊断性反例</li><li>No problem with <strong>partial specifications</strong> 部分规格</li><li>Logics can easily express many <strong>concurrency properties</strong> 逻辑学可以很容易地表达许多并发性属性</li></ul><h4 id="LTL-Linear-Time-Logic">4.2.2. LTL - Linear Time Logic</h4><ul><li>Atomic Propositions 原子命题</li><li>Temporal operators 时间运算符</li></ul><center><img loading="lazy" src="/posts/a3244b40/6.png" width="550"></center><center><img loading="lazy" src="/posts/a3244b40/7.png" width="550"></center><h4 id="Model-Checking-Problem">4.2.3. Model Checking Problem</h4><p><strong>example</strong></p><center><img loading="lazy" src="/posts/a3244b40/8.png" width="550"></center><p><strong>formalization</strong></p><ul><li><code>M</code><ul><li>Let M be a state-transition graph</li></ul></li><li><code>f</code><ul><li>Let ƒ be an assertion or specification in temporal logic</li></ul></li><li><code>s</code><ul><li>Find all states s of M such that M, s satisfies ƒ</li></ul></li></ul><p><strong>state-transition graph</strong></p><center><img loading="lazy" src="/posts/a3244b40/11.png" width="550"></center><p><strong>Complexity</strong></p><ul><li><strong>singly exponential</strong> in size of specification 与规格大小呈单指数关系</li><li><strong>linear</strong> in size of state-transition graph 与状态转换图的大小呈线性关系</li></ul><h3 id="Bounded-Model-Checking-BMC-有界模型检查">4.3. Bounded Model Checking(BMC) 有界模型检查</h3><ul><li><strong>Basic idea: check negation of given property up to given depth</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/9.png" width="550"></center><ul><li>counterexample: 反例</li></ul><blockquote><p>有界模型检测的主要过程是:先把要验证的系统或模型<strong>构造为有限状态自动机</strong>(finite state machine,简称FSM),通过 FSM <strong>状态间的转移来模拟系统或模型运行</strong>;要验证的<strong>规范说明用时序逻辑</strong> LTL(linear-time temporal logic)进行说明(如 G(p),F(p));设定<strong>边界上界</strong> K;FSM <strong>状态间的转移关</strong>系和 LTL <strong>逻辑规范否定的 NNF</strong>(negation normal form)公式通过逻辑与构成 <strong>BMC 转换公式</strong>;把 BMC 转换公式<strong>编码成 SAT 实例</strong>,通过 SAT 工具求解.若有解,则找到反例（_即原系统存在bug？_）;反之,若不可满足,则表明要验证的系统或模型运行到 K 阶段时,是安全的、没有错误的</p></blockquote><ul><li>K 阶段相当于SMT的重复k次？</li></ul><h4 id="扩展到SMT">4.3.1. 扩展到SMT</h4><ul><li>SMT decides the satisfiability of <strong>first-order logic</strong> formulae using the combination of different background theories</li></ul><center><img loading="lazy" src="/posts/a3244b40/12.png" width="550"></center><h4 id="Steps-for-Software-BMC">4.3.2. Steps for Software BMC</h4><center><img loading="lazy" src="/posts/a3244b40/13.png" width="550"></center><p><strong>example 1</strong></p><center><img loading="lazy" src="/posts/a3244b40/14.png" width="500"></center><center><img loading="lazy" src="/posts/a3244b40/15.png" width="500"></center><center><img loading="lazy" src="/posts/a3244b40/16.png" width="500"></center><center><img loading="lazy" src="/posts/a3244b40/17.png" width="500"></center><p><strong>example 2</strong></p><center><img loading="lazy" src="/posts/a3244b40/18.png" width="500"></center><blockquote><p>When getPassword is called, the location of the code to run when getPassword completes (the if statement) is put into a special location in memory called the stack. The top of the stack is pointed to by the internal stack pointer register (sp for short). When getPassword is called, the top of the stack contains the address of the if statement. The first thing that happens after getPassword is called is that sp is decreased by 4 to make room for the 4-character array buf (which is also stored on the stack). Next, the call to gets writes input characters into memory starting with the location pointed to by sp. When getPassword is finished, sp is increased by 4, reclaiming the memory occupied by buf, and then the instruction pointer register (ip for short) is loaded with the location pointed to by sp. We wish to determine whether it is possible to set ip to a value that we choose instead of the location of the if statement.</p><ul><li>当getPassword被调用时，当getPassword完成时要运行的代码的位置（if语句）被放入内存中的一个特殊位置，称为堆栈。堆栈的顶部由内部堆栈指针寄存器（简称sp）来指出。当getPassword被调用时，堆栈的顶部包含if语句的地址。调用getPassword后发生的第一件事是sp减少4，以便为4个字符的数组buf（它也存储在堆栈中）腾出空间。接下来，对get的调用从sp指向的位置开始将输入字符写入内存。当getPassword完成后，sp增加4，回收buf占用的内存，然后指令指针寄存器（简称ip）被加载到sp指向的位置</li></ul></blockquote><blockquote><p>We use a couple of encoding tricks here. First is something called static single assignment (SSA). SSA represents the same variable at different times by using different names for the different times. For example, the stack pointer is represented initially by sp0, and then later by sp1, and then finally by sp2. As the variable changes, the relationship between its previous value and new value is captured with a formula that relates them. For example, the expression sp1 &#x3D; BVSUB(8,sp0,0bin100) tells us that the new value of sp is equal to the old value minus 4 (the first parameter of 8 is used to specify the bit-width of the operation).</p><ul><li>我们在这里使用了几个编码技巧。首先是称为静态单一赋值（SSA）的东西。SSA通过在不同的时间使用不同的名字来表示同一个变量。例如，堆栈指针最初用sp0表示，后来用sp1，最后用sp2。随着变量的变化，它的前值和新值之间的关系用一个公式来捕捉，将它们联系起来。例如，表达式sp1 &#x3D; BVSUB(8,sp0,0bin100)告诉我们sp的新值等于旧值减去4（第一个参数8用来指定操作的位宽）。</li></ul></blockquote><blockquote><p>Another trick is loop unrolling. We have modelled the call to gets as a series of 5 writes to memory. This corresponds to an input of 5 characters, meaning that a loop that reads a single character would get executed 5 times. How do we know how many times to unroll the loop? In general, we don’t, but in practice we can start small and try more and more loop unrollings until we find a satisfying assignment or give up. For this example, if we use 4 or fewer unrollings, the solver returns unsat. However, with 5 characters, the result is sat. In particular, with an input of 5 characters, the last character of the input will become the new value of ip.</p><ul><li>另一个技巧是循环解卷。我们把对gets的调用模拟成一系列对内存的5次写入。这对应于5个字符的输入，意味着一个读取单个字符的循环将被执行5次。我们怎么知道要展开多少次循环呢？一般来说，我们不知道，但在实践中，我们可以从小处开始，尝试越来越多的循环展开，直到找到一个满意的赋值或放弃。对于这个例子，如果我们使用4个或更少的unrollings，求解器会返回unsat。然而，如果使用5个字符，结果是sat。特别是，在输入5个字符的情况下，输入的最后一个字符将成为ip的新值</li></ul></blockquote><h3 id="Context-Bounded-Model-Checking-基于上下文的模型检测">4.4. Context-Bounded Model Checking 基于上下文的模型检测</h3><ul><li>Idea: iteratively generate all possible interleavings交织 and call the BMC procedure on each interleaving</li><li>combines: <ul><li><strong>symbolic</strong> model checking: on each individual interleaving</li><li><strong>explicit state</strong> model checking: explore all interleavings</li><li>symbolic state hashing</li><li>monotonic partial order reduction that combines dynamic POR with symbolic state space exploration</li></ul></li></ul><h3 id="Lazy-Exploration-of-the-Reachability-Tree">4.5. Lazy Exploration of the Reachability Tree</h3><center><img loading="lazy" src="/posts/a3244b40/20.png" width="600"></center><center><img loading="lazy" src="/posts/a3244b40/21.png" width="600"></center><center><img loading="lazy" src="/posts/a3244b40/22.png" width="600"></center><h3 id="Predicate-Abstraction">4.6. Predicate Abstraction</h3><p><strong>Example</strong></p><ul><li>It abstracts data by only keeping track of certain predicates to represent the data</li><li>Conservative approach reduces the state space, but generates spurious counter-examples</li></ul><center><img loading="lazy" src="/posts/a3244b40/23.png" width="600"></center><center><img loading="lazy" src="/posts/a3244b40/24.png" width="600"></center><h3 id="Combine-Simulation-and-Verification">4.7. Combine Simulation and Verification</h3><ul><li>Improve coverage and reduce verification time by <strong>combining static and dynamic verification</strong></li></ul><center><img loading="lazy" src="/posts/a3244b40/19.png" width="500"></center><ul><li><em>simulation就当是csmith</em></li></ul><h3 id="BMC的克里普克结构-Kripke-structure">4.8. BMC的克里普克结构(Kripke structure)</h3><p>BMC 的克里普克结构(Kripke structure)为一四元组 M＝(S,I,T,ℓ),其中</p><ul><li>$S$ 为 BMC 中 FSM 产生的所有状态集合;</li><li>$I⊆S$,I 为初时状态的集合;</li><li>$T⊆S×S$,T 为状态间转移关系的集合;、</li><li>$ℓ:S→P(A)$,ℓ 为标注状态的函数.</li></ul><div class="row">    <embed src="./theory1.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="参考">5. 参考</h2><ul><li><a href="http://theory.stanford.edu/~barrett/pubs/BKM14.pdf">Problem Solving for the 21st Century - BKM14.pdf</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Security/">Security</category>
      
      <category domain="https://hejueyun.github.io/categories/Security/Software-Security/">Software Security</category>
      
      
      <category domain="https://hejueyun.github.io/tags/sec/">sec</category>
      
      
      <comments>https://hejueyun.github.io/posts/a3244b40/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>软件工程基础-软件质量与其他</title>
      <link>https://hejueyun.github.io/posts/3ff63edb/</link>
      <guid>https://hejueyun.github.io/posts/3ff63edb/</guid>
      <pubDate>Mon, 24 Jan 2022 23:40:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Software-Quality&quot;&gt;1. Software Quality&lt;/h2&gt;&lt;h3 id=&quot;Desirable-Software-Quality-理想的软件质量&quot;&gt;1.1. Desirable Software Quality(理想的软件质量)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;External characteristics： External characteristics are characteristics that a user of the software product is aware of&lt;/li&gt;
&lt;li&gt;Internal : developer directly experience&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;联系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The difference between internal and external characteristics isn’t completely clear-cut because at some level internal characteristics affect external ones. Software that isn’t internally understandable or maintainable impairs your ability to correct defects, which in turn affects the external characteristics of correctness and reliability. Software that isn’t flexible can’t be enhanced in response to user requests, which in turn affects the external characteristic of usability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img loading=&quot;lazy&quot; src=&quot;/posts/3ff63edb/2.png&quot; width=&quot;450px&quot;&gt;&lt;/center&gt;

&lt;p&gt;External characteristics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Correctness&lt;ul&gt;
&lt;li&gt;一个系统在其规格、设计和实现中没有错误的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Usability&lt;ul&gt;
&lt;li&gt;用户学习和使用一个系统的容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Efficiency&lt;ul&gt;
&lt;li&gt;对系统资源的最小化使用，包括&lt;strong&gt;内存和执行时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reliability&lt;ul&gt;
&lt;li&gt;一个系统在规定的条件下，无论何时都能执行所需功能的能力–&lt;strong&gt;具有较长的平均故障间隔时间&lt;/strong&gt;( a long mean time between failures)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Integrity&lt;ul&gt;
&lt;li&gt;完整性的概念包括&lt;strong&gt;限制未经授权的用户访问&lt;/strong&gt;，以及&lt;strong&gt;确保数据被正确访问&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Adaptability&lt;ul&gt;
&lt;li&gt;一个系统在没有修改的情况下，可以在其专门设计之外的应用或环境中使用的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Accuracy&lt;ul&gt;
&lt;li&gt;精确性与正确性不同；它决定了一个系统在多大程度上完成了它所构建的工作(而不是关注错误)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Robustness&lt;ul&gt;
&lt;li&gt;一个系统在无效的输入或紧张的环境条件下继续运行的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;internal quality characteristics：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maintainability&lt;ul&gt;
&lt;li&gt;你可以修改一个软件系统以改变或增加功能、提高性能或纠正缺陷的容易程度&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The ease with&lt;/strong&gt; which you can modify a software system to change or add capabilities, improve performance, or correct defects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Flexibility &lt;ul&gt;
&lt;li&gt;可以修改一个系统的用途或环境的程度，而不是它的专门设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Portability&lt;ul&gt;
&lt;li&gt;你可以修改一个系统以在不同于其专门设计的环境中运行的容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reusability&lt;ul&gt;
&lt;li&gt;你可以在其他系统中使用一个系统的部分的程度和容易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Readability&lt;ul&gt;
&lt;li&gt;你能够阅读和理解一个系统的源代码的难易程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Testability&lt;ul&gt;
&lt;li&gt;你可以对一个系统进行单元测试和系统测试的程度；你可以&lt;strong&gt;验证该系统满足其要求的程度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Understandability&lt;ul&gt;
&lt;li&gt;在系统-组织和详细陈述层面上，你能理解一个系统的难易程度。&lt;strong&gt;与可读性相比，可理解性与系统在更一般的层面上的一致性有关&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Readability is part of understandability&lt;/strong&gt;. But you can have readable methods or functions and an impossible to grasp architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Software-Quality">1. Software Quality</h2><h3 id="Desirable-Software-Quality-理想的软件质量">1.1. Desirable Software Quality(理想的软件质量)</h3><ul><li>External characteristics： External characteristics are characteristics that a user of the software product is aware of</li><li>Internal : developer directly experience</li></ul><p><strong>联系</strong></p><blockquote><p>The difference between internal and external characteristics isn’t completely clear-cut because at some level internal characteristics affect external ones. Software that isn’t internally understandable or maintainable impairs your ability to correct defects, which in turn affects the external characteristics of correctness and reliability. Software that isn’t flexible can’t be enhanced in response to user requests, which in turn affects the external characteristic of usability.</p></blockquote><center><img loading="lazy" src="/posts/3ff63edb/2.png" width="450px"></center><p>External characteristics：</p><ul><li>Correctness<ul><li>一个系统在其规格、设计和实现中没有错误的程度</li></ul></li><li>Usability<ul><li>用户学习和使用一个系统的容易程度</li></ul></li><li>Efficiency<ul><li>对系统资源的最小化使用，包括<strong>内存和执行时间</strong></li></ul></li><li>Reliability<ul><li>一个系统在规定的条件下，无论何时都能执行所需功能的能力–<strong>具有较长的平均故障间隔时间</strong>( a long mean time between failures)</li></ul></li><li>Integrity<ul><li>完整性的概念包括<strong>限制未经授权的用户访问</strong>，以及<strong>确保数据被正确访问</strong></li></ul></li><li>Adaptability<ul><li>一个系统在没有修改的情况下，可以在其专门设计之外的应用或环境中使用的程度</li></ul></li><li>Accuracy<ul><li>精确性与正确性不同；它决定了一个系统在多大程度上完成了它所构建的工作(而不是关注错误)</li></ul></li><li>Robustness<ul><li>一个系统在无效的输入或紧张的环境条件下继续运行的程度</li></ul></li></ul><p>internal quality characteristics：</p><ul><li>Maintainability<ul><li>你可以修改一个软件系统以改变或增加功能、提高性能或纠正缺陷的容易程度<blockquote><p><strong>The ease with</strong> which you can modify a software system to change or add capabilities, improve performance, or correct defects</p></blockquote></li></ul></li><li>Flexibility <ul><li>可以修改一个系统的用途或环境的程度，而不是它的专门设计</li></ul></li><li>Portability<ul><li>你可以修改一个系统以在不同于其专门设计的环境中运行的容易程度</li></ul></li><li>Reusability<ul><li>你可以在其他系统中使用一个系统的部分的程度和容易程度</li></ul></li><li>Readability<ul><li>你能够阅读和理解一个系统的源代码的难易程度</li></ul></li><li>Testability<ul><li>你可以对一个系统进行单元测试和系统测试的程度；你可以<strong>验证该系统满足其要求的程度</strong></li></ul></li><li>Understandability<ul><li>在系统-组织和详细陈述层面上，你能理解一个系统的难易程度。<strong>与可读性相比，可理解性与系统在更一般的层面上的一致性有关</strong></li><li><strong>Readability is part of understandability</strong>. But you can have readable methods or functions and an impossible to grasp architecture</li></ul></li></ul><hr><center><img loading="lazy" src="/posts/3ff63edb/1.png" width="400px"></center><ul><li><strong>最大化某些特征的尝试不可避免地与最大化其他特征的尝试相冲突。从一组相互竞争的目标中找到一个最佳解决方案，是使软件开发成为真正的工程学科的一项活动。</strong></li><li><strong>专注于一个特定的特征并不总是意味着要与另一个特征进行交换。有时一个会伤害另一个，有时会帮助另一个，有时既不伤害也不帮助另一个</strong> Focusing on one external characteristic of software quality can affect other characteristics positively, adversely, or not at all</li></ul><h3 id="Techniques-for-Improving-Software-Quality（提高软件质量的方法）">1.2. Techniques for Improving Software Quality（提高软件质量的方法）</h3><h4 id="Setting-Objectives">1.2.1. Setting Objectives</h4><blockquote><p>One powerful technique for improving software quality is setting explicit quality objectives from among the <strong>external</strong> and <strong>internal</strong> characteristics described in the previous section</p><p>Explicit quality-assurance activity.</p><ul><li>Making the quality-assurance activity explicit makes the priority clear, and programmers will respond accordingly.</li></ul></blockquote><h4 id="Development-Process">1.2.2. Development Process</h4><ul><li><strong>Change-control procedures</strong><ul><li>One big obstacle to achieving software quality is uncontrolled changes. Uncontrolled requirements changes can result in disruption to design and coding. Uncontrolled changes in design can result in code that doesn’t agree with its requirements, inconsistencies in the code, or more time spent modifying code to meet the changing design than spent moving the project forward. 实现软件质量的一个大障碍就是不受控制的变更。不受控制的需求变更会导致设计和编码的中断。不受控制的设计变更会导致代码与需求不一致，代码中的不一致，或者花在修改代码以满足不断变化的设计上的时间比花在推进项目上的时间多</li></ul></li><li><strong>Measurement of results</strong><ul><li>除非对质量保证计划的结果进行测量，否则你将无法知道该计划是否有效</li></ul></li><li><strong>Prototyping</strong><ul><li>Prototyping is the development of realistic models of a system’s key functions. A developer can prototype parts of a user interface to determine usability, critical calculations to determine <strong>execution time</strong>, or typical data sets to determine <strong>memory requirements</strong>. 原型验证是对系统关键功能的现实模型的开发。开发者可以对用户界面的一部分进行原型开发以确定可用性，对关键计算进行原型开发以确定执行时间，或对典型数据集进行原型开发以确定内存需求。</li></ul></li></ul><h3 id="不同质量保证的方法的有效性">1.3. 不同质量保证的方法的有效性</h3><blockquote><p>这个数据所揭示的最有趣的事实是，任何一种技术的模态率都没有超过75%，各种技术平均约为40%。此外，对于最常见的缺陷检测–单元测试和集成测试–模式率只有30-35%。典型的组织使用重测试的缺陷清除方法，只能达到约85%的缺陷清除效率。领先的组织使用更广泛的技术，实现了95%或更高的缺陷清除效率。</p><p>如果项目开发人员要争取更高的缺陷发现率，他们需要使用多种技术组合（if project developers are striving for a higher defect detection rate, they need to use a combination of techniques）</p></blockquote><p>Cost of Finding Defects发现漏洞的成本</p><ul><li>Most studies have found that <strong>inspection</strong>s are cheaper than <strong>testing</strong>. A study at the Software Engineering Laboratory found that <strong>code reading</strong> detected about 80 percent more faults per hour than <strong>testing</strong><br>Cost of Fixing Defects</li><li>the longer a defect remains in the system, the more expensive it becomes to remove. A detection technique that finds the error earlier therefore results in a lower cost of fixing it</li></ul><p>Here’s a recommended combination for achieving higher-than-average quality:</p><ul><li>Formal inspections of all requirements, all architecture, and designs for critical parts of a system</li><li>Modeling or prototyping</li><li>Code reading or inspections</li><li>Execution testing</li></ul><h3 id="When-to-Do-Quality-Assurance">1.4. When to Do Quality Assurance</h3><blockquote><p>the earlier an error is inserted into software, the more entangled it becomes in other parts of the software and the more expensive it becomes to remove. </p></blockquote><ul><li>一个错误越早插入软件，它在软件其他部分的纠缠就越多，消除它的代价就越大。需求中的错误会在设计中产生一个或多个相应的错误，而设计中的错误又会在代码中产生许多相应的错误。一个需求错误会导致额外的架构或错误的架构决策。额外的架构会导致额外的代码、测试用例和文档。或者一个需求错误会导致架构、代码和测试用例被丢弃</li><li><strong>Defects creep into software at all stages</strong><ul><li>质量保证工作应当在每一构建环节都介入 </li><li>It should be planned into the project as work begins; </li><li>it should be part of the technical fiber of the project as work continues; </li><li>and it should punctuate the end of the project, verifying the quality of the product as work ends.</li></ul></li></ul><h3 id="The-General-Principle-of-Software-Quality">1.5. The General Principle of Software Quality</h3><blockquote><p><strong>The General Principle of Software Quality is that improving quality reduces development costs.</strong></p></blockquote><ul><li>这个原则本质上也是个“悖论”paradox</li><li>提高生产力和质量的最好方法是减少代码返工的时间，无论返工是由于需求的变化、设计的变化还是调试的变化</li><li>Compared to the traditional <code>code-test-debug</code> cycle, an enlightened software-quality program saves money</li></ul><img loading="lazy" src="/posts/3ff63edb/11.png" width="550"><blockquote><p>the best way to improve productivity and quality is to reduce the time spent reworking code, whether the rework arises from changes in requirements, changes in design, or debugging. The industry-average productivity for a software product is about 10 to 50 of lines of delivered code per person per day (including all noncoding overhead). It takes only a matter of minutes to type in 10 to 50 lines of code</p></blockquote><img loading="lazy" src="/posts/3ff63edb/9.png" width="550"><ul><li>你是否考虑过一些特性可能与其他特性竞争或互补的方式？</li></ul><h3 id="key-points">1.6. key points</h3><ol><li>Quality is free, in the end, but it requires a reallocation of resources so that <strong>defects are prevented cheaply instead of fixed expensively</strong>.</li><li>Not all quality-assurance goals are simultaneously achievable. Explicitly decide which goals you want to achieve, and communicate the goals to other people on your team.</li><li>No single defect-detection technique is completely effective by itself. Testing by itself is not optimally effective at removing errors. Successful quality-assurance programs use several different techniques to detect different kinds of errors.</li><li>You can apply effective techniques during construction and many equally powerful techniques before construction. The earlier you find a defect, the less intertwined it will become with the rest of your code and the less damage it will cause.</li><li>Quality assurance in the software arena is process-oriented. Software development doesn’t have a repetitive phase that affects the final product like manufacturing does, so the quality of the result is controlled by the process used to develop the software.</li></ol><hr><h2 id="Intellectual-Property-知识产权">2. Intellectual Property 知识产权</h2><blockquote><p>Intellectual property is any articulable, tangible production of a mind whose physical realisations are restricted by law (e.g., in distribution)</p><p>知识产权是任何可阐明的、有形的思想成果，其物质实现受到法律的限制（例如，在分销方面）。</p><hr><p>Copyright is a licensable monopoly of the tangible expression of an idea with respect to reproduction, derivation, display，distribution, and the like.</p><p>版权是对思想的有形表达在复制、衍生、展示、传播等方面的一种可授权的垄断。</p></blockquote><h2 id="程序等价">3. 程序等价</h2><ul><li>如果我们无法区分两个程序（在某种程度上），那么这两个程序就是等价的（以这种方式）。</li><li>Two programs are functionally equivalent just in case they implement exactly the same <strong>functionality</strong>.</li><li>if two programs are <strong>behaviourly</strong> equivalent then they are functionally equivalent.</li><li>这里将等价性定义为“给定相同合法输入，有相同输出”</li></ul><h2 id="Managing-Construction">4. Managing Construction</h2><h3 id="Key-Points">4.1. Key Points</h3><ol><li>Good coding practices can be achieved either through enforced standards or through more light-handed approaches.<ol><li>Encouraging Good Coding</li></ol></li><li>Configuration management, when properly applied, makes programmers’ jobs easier. This especially includes change control.<ol><li><strong>Configuration management is the practice of identifying project artifacts and handling changes systematically so that a system can maintain its integrity over time. Another name for it is “change control.”</strong> It includes techniques for evaluating proposed changes, tracking changes, and keeping copies of the system as it existed at various points in time.</li><li>Software Code Changes、Tool Versions、Machine Configurations、Backup</li></ol></li><li>Good software estimation is a significant challenge. Keys to success are using multiple approaches, tightening down your estimates as you work your way into the project, and making use of data to create the estimates.<ol><li>Use estimating software、algorithmic approach、Have a walk-through meeting for estimates</li></ol></li><li>Measurement is a key to successful construction management. You can find ways to measure any aspect of a project that are better than not measuring it at all. Accurate measurement is a key to accurate scheduling, to quality control, and to improving your development process.</li><li>Programmers and managers are people, and they work best when treated as such</li></ol><h2 id="character">5. character</h2><ol><li>our personal character directly affects your ability to write computer programs.</li><li>The characteristics that matter most are humility, curiosity, intellectual honesty, creativity and discipline, and enlightened laziness.</li><li>The characteristics of a superior programmer have almost nothing to do with talent and everything to do with a commitment to personal development.</li><li>Surprisingly, raw intelligence, experience, persistence, and guts hurt as much as they help.</li><li>Many programmers don’t actively seek new information and techniques and instead rely on accidental, on-the-job exposure to new information. If you devote a small percentage of your time to reading and learning about programming, after a few months or years you’ll dramatically distinguish yourself from the programming mainstream.</li><li>Good character is mainly a matter of having the right habits. To be a great programmer, develop the right habits and the rest will come naturally.</li></ol><h2 id="开发成本">6. 开发成本</h2><ul><li>The unit cost diminishes as the number of units increases<ul><li>So focus on lines of code or bits of functionality</li></ul></li><li><strong>Cost Ratios</strong><ul><li>Before deployment (aka submission)<ul><li>Small fixes are cheap</li></ul></li><li>After deployment (aka submission)<ul><li>Even “small” fixes are expensive (or impossible)</li></ul></li><li>Strategies<ul><li>Avoid late bugs</li><li>Make fixing late bugs cheaper</li></ul></li></ul></li><li>The General <strong>Principle</strong> of Software Quality is that improving quality reduces development costs</li></ul><center><img loading="lazy" src="/posts/3ff63edb/3.png" width="450px"></center><h3 id="Trade-Offs">6.1. Trade-Offs</h3><ul><li>Time for Space (and the reverse)</li><li>Performance for Readability (and the reverse)</li></ul><h3 id="Alternatives">6.2. Alternatives</h3><ul><li>Buy More and Faster Hardware</li><li>Use the Optimiser</li><li>Better compilers&#x2F;frameworks&#x2F;libraries</li></ul><h3 id="Technical-Debt">6.3. Technical Debt</h3><blockquote><p>In software development, technical debt (also known as design debt or code debt) is the implied** cost of additional rework** caused by <strong>choosing an easy(limited) solution</strong> now instead of using a <strong>better approach that would take longer</strong></p><p>技术负债（英语：Technical debt），又译技术债，也称为设计负债（design debt）、代码负债（code debt），是程序设计及软件工程中的一个比喻。指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。 </p></blockquote><ul><li>如果我们等待，就会产生利息<ul><li>我们写的测试越多，以后要改的测试就越多</li><li>可能会导致更对债务</li></ul></li></ul><p>Intentional Vs Unintentional Debt<br>无意的债务&#x3D;&#x3D;意外的或偶然的</p><ul><li>我们可能不知道我们产生了它!</li><li>我们可能不知道有利息！<br>故意的债务 &#x3D;&#x3D; 故意的，有意识地产生的</li><li>需要一个可识别的理由（identifiable rationale）</li><li>有一个范围</li></ul><p>为什么负债</p><ul><li><p>Short-Term Debt</p><ul><li>战术原因 Tactical reasons</li></ul></li><li><p>Long-Term Debt</p><ul><li>战略原因 Strategic reasons</li></ul></li><li><p><strong>重构是还债最常见的方式</strong></p></li><li><p>其余还包括增加测试用例等</p></li></ul><h2 id="Managing-Complexity">7. Managing Complexity</h2><h3 id="No-silver-bullet">7.1. No silver bullet</h3><p>The complexities of software systems lead to difficulties in both accident and essence. According to Brooks, the accidental complexities are largely caused by artificial barriers, including poor programming skills, severe hardware constraints and lack of machine time. On the contrary, the essential complexities, inherent in the nature of the software, are reflected by the hardship of composing the abstract software entity, including specification, design and testing of the conceptual construct, rather than the labour of actual construction.</p><p>What is highlighted in Brooks’ essay is that no once-and-for-all solution to remove the complexity of the software, thus “no silver bullet”. From the aspect of accidental complexities, although problems can be considerably alleviated by the high-level language, time-sharing and unified programming environment, it is impossible to avoid “accidents”, particularly when products increase with size. From the aspect of accidental complexities, the inherent properties of modern software systems determine the difficulty of finding a solution, as technologies that are advanced as potential “silver bullet” yet mostly remain problem-specific. An artificial intelligence implement of computer images, for example, cannot easily transfer to different programming practices. </p><p>However, there are some promising attacks, raised by Brooks, on the conceptual essence. These contain the principles of buy rather than build, rapid prototyping of system and cautious design. </p><p>In general, considering the shrinking marginal benefit of reducing accidents, and the inherent complexity of software systems, finding “silver bullets” to minimize complexity remains challenging yet possible.</p><hr><p>Brooks observes that the major accidental difficulties in software were addressed long ago. For example, accidental difficulties related to clumsy language syntaxes were largely eliminated in the evolution from assembly language to third-generation languages and have declined in significance incrementally since then. Accidental difficulties related to noninteractive computers were resolved when time-share operating systems replaced batch-mode systems. Integrated programming environments further eliminated inefficiencies in programming work arising from tools that worked poorly together.</p><p>Brooks argues that progress on software’s remaining essential difficulties is bound to be slower. The reason is that, at its essence, software development consists of working out all the details of a highly intricate, interlocking set of concepts. The essential difficulties arise from the necessity of interfacing with the complex, disorderly real world; accurately and completely identifying the dependencies and exception cases; designing solutions that can’t be just approximately correct but that must be exactly correct; and so on. Even if we could invent a programming language that used the same terminology as the real-world problem we’re trying to solve, programming would still be difficult because of the challenge in determining precisely how the real world works. As software addresses ever-larger real-world problems, the interactions among the real-world entities become increasingly intricate, and that in turn increases the essential difficulty of the software solutions.</p><p><strong>The root of all these essential difficulties is complexity—both accidental and essential.</strong></p><h3 id="Importance-of-Managing-Complexity">7.2. Importance of Managing Complexity</h3><ul><li>Projects fail most often because of poor requirements, poor planning, or poor management. But when projects do fail for reasons that are primarily technical, the reason is often uncontrolled complexity. The software is allowed to grow so complex that no one really knows what it does. When a project reaches the point at which no one completely understands the impact that code changes in one area will have on other areas, progress grinds to a halt.</li><li>no one’s skull is really big enough to contain a modern computer program (Dijkstra 1972), which means that we as software developers shouldn’t try to cram whole programs into our skulls at once; we should try to organize our programs in such a way that we can safely focus on one part of it at a time.</li><li>Keeping routines short helps reduce your mental workload. Writing programs in terms of the problem domain, rather than in terms of low-level implementation details, and working at the highest level of abstraction reduce the load on your brain.</li></ul><h3 id="How-to-Attack-Complexity">7.3. How to Attack Complexity</h3><ul><li>Minimize the amount of essential complexity that anyone’s brain has to deal with at any one time<ul><li>尽量减少任何人的大脑在任何时候都必须处理的基本复杂性。</li></ul></li><li>Keep <strong>accidental complexity</strong> from needlessly proliferating<ul><li>防止意外的复杂性不必要地扩散</li></ul></li></ul><h2 id="Architecting-How-Much-and-When">8. Architecting: How Much and When?</h2><h3 id="the-Cost-of-Fixing-Software">8.1. the Cost of Fixing Software</h3><center><img loading="lazy" src="/posts/3ff63edb/10.png" width="450px"></center><h3 id="How-Much-Architecting-Is-Enough">8.2. How Much Architecting Is Enough</h3><blockquote><p>The evidence provided across 40 years of data on the degree of increase in software cost-to-fix versus delay-of-fix is that for large projects, the increase from fixing requirements changes and defects during requirements definition to fixing them once the product is fielded continues to be around 100:1. However, this ratio can be significantly reduced by higher investments in early requirements and architecture verification and validation. As shown by the CCPDS-R project data in Figure 10-6, the ratio can approach 1:1 if the high-risk fixes are addressed early.<br>The evidence for small projects continues to show ratios around 5:1, but these can also be flattened by the use of outstanding personnel and by Agile methods, such as pair programming and continuous integration, that shorten the delay-of-fix time. Small, noncritical projects can also spread their architecting activity across the life cycle via refactoring, but need to watch out for making easiest-first architectural commitments that cannot be easily undone by refactoring, such as committing to unscalable COTS products or security-incompatible data and control structures.<br>The evidence provided more recently on the payoff of architecting and risk resolution efforts, such as those on CCPDS-R, is that the location of the highest-payoff “how much architecting is enough” sweet spot is a function of project size and criticality (larger, more critical projects require more architecting investment), but also a function of requirements volatility (more volatile projects would be slowed down by the need to revise extensive documentation). For detailed project planning and budgeting, the sweet-spot numbers need to be adjusted to reflect additional project, personnel, and product-related cost drivers. A recent COSYSMO model is now available to support such adjustments.<br>Very large projects are likely to have elements that are high in criticality and stability (e.g., safety and security-critical elements), as well as elements that are high in requirements volatility (e.g., user interfaces, external-system interfaces, device drivers, database schemas). In such cases, a hybrid approach using Agile methods for the rapidly changing parts and plandriven methods for the more stable and high-criticality parts will work, as long as the overall system is based on an architecture using the [Parnas 1979] information-hiding approach of encapsulating sources of change within modules.<br>Thus, there are no one-size-fits-all solutions for the increasingly rapid change that projects will experience in the future. Large projects or enterprises with a mix of critical and volatile elements are best served by risk-driven process generators, such as the Incremental Commitment Model and risk-driven versions of the Rational Unified Process. These model generators use the degree of developer-supplied evidence of project feasibility to determine project risk. Such evidence is critical to the success of many future projects facing the prospect of having to cope with increasing size, criticality, volatility, and complexity. In addition, the use of such evidence-based models will have the double benefit of reducing risk and adding to the knowledge base of evidence that can be analyzed for further sources of project and enterprise improvement.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://hejueyun.github.io/categories/Software-Engineering/">Software Engineering</category>
      
      
      
      <comments>https://hejueyun.github.io/posts/3ff63edb/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
